<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构数组Array 以数组 nums 为例   声明： int[] nums &#x3D; new int[1]; int[] nums &#x3D; new int[]&amp;#123;0&amp;#125;; Object[] nums &#x3D; list.toArray(); ArrayList 转 Array，类型只能转为 Object   Arrays.equals(int[] nums, new int[]&amp;#123;&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="http://example.com/2021/02/05/Java/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数据结构数组Array 以数组 nums 为例   声明： int[] nums &#x3D; new int[1]; int[] nums &#x3D; new int[]&amp;#123;0&amp;#125;; Object[] nums &#x3D; list.toArray(); ArrayList 转 Array，类型只能转为 Object   Arrays.equals(int[] nums, new int[]&amp;#123;&amp;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/beijing.jpg">
<meta property="article:published_time" content="2021-02-05T13:10:50.000Z">
<meta property="article:modified_time" content="2022-04-01T05:27:00.023Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/beijing.jpg"><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://example.com/2021/02/05/Java/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-01 13:27:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/beijing.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-02-05T13:10:50.000Z" title="Created 2021-02-05 21:10:50">2021-02-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-04-01T05:27:00.023Z" title="Updated 2022-04-01 13:27:00">2022-04-01</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><blockquote>
<p>以数组 nums 为例</p>
</blockquote>
<ul>
<li>声明：<ul>
<li><code>int[] nums = new int[1];</code></li>
<li><code>int[] nums = new int[]&#123;0&#125;;</code></li>
<li><code>Object[] nums = list.toArray();</code> ArrayList 转 Array，类型只能转为 Object</li>
</ul>
</li>
<li><code>Arrays.equals(int[] nums, new int[]&#123;&#125;);</code>：判断数组是否为空。</li>
<li><code>Arrays.toString(nums)</code>：将数组转为字符串以方便打印，否则若直接打印则输出为数组地址；</li>
<li><code>Arrays.fill(nums, 0)</code> 元素赋统一值。数组 nums 的所有元素统一赋值 0，nums 可为任意维数组</li>
<li><code>Arrays.stream(nums).sum()</code> 元素求和</li>
<li><code>Arrays.stream(nums).min()/max().getAsInt();</code> 获取最大值/最小值，返回值为 int 类型数字</li>
<li>复制数组：<ul>
<li><code>Arrays.copyOfRange(T[] original, int from, int to)</code> 将一个原始数组 original，从下标 from 的元素开始复制，直至下标 to 的前一个元素，生成一个新的数组作为<strong>返回值返回</strong>;</li>
<li><code>System.arraycopy(T[] org1, int a, T[] org2, int b, int k)</code> 将数组 org1 起始索引为 a（含），长度为 k 的元素复制（替换）到数组 org2 起始索引为b（含）的后续元素中。</li>
</ul>
</li>
<li><code>Arrays.sort(nums)</code> 元素排序（升序排序）</li>
<li>使用比较器创建内部类对二维数组 int[n][2] nums 排序：<ul>
<li>按 int[i][0] 排序，同理 int[i][1] 排序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];   <span class="comment">// 升序排序</span></span><br><span class="line">        <span class="keyword">return</span> o2[<span class="number">0</span>] - o1[<span class="number">0</span>];   <span class="comment">// 降序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>创建排序类排序，但要求传入的是对象，而不是数组(Array)。如 <code>Colletions.sort(list, new MyComparator());</code>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(o2) - Math.abs(o1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><blockquote>
<p>以数组 list 为例</p>
</blockquote>
<ul>
<li>声明：<ul>
<li><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code>：第二个 &lt;&gt; 参数指定添加元素的类型。若没有指定，则可随意不限类型添加元素（如 add(Integer)、add(String)）</li>
<li><code>List&lt;Integer&gt; list = Lists.newArrayList(1, 2);</code></li>
<li><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;()&#123;&#123;add(0);&#125;&#125;;</code></li>
<li><code>Arrays.asList(nums);</code> Array 转 ArrayList。如 String[] -&gt; <code>List&lt;String&gt;</code>，Integer[] -&gt; <code>List&lt;Integer&gt;</code>；但 int[] -&gt; <code>List&lt;int[]&gt;</code>。但是该方法返回值是 java.util.Arrays 类中一个私有静态内部类 java.util.Arrays.ArrayList，它并非 java.util.ArrayList 类。java.util.Arrays.ArrayList 类具有 set()，get()，contains()等方法，但是不具有添加 add() 或删除 remove() 方法,所以调用后两个方法时方法会报错。</li>
</ul>
</li>
<li><code>list.add(num)</code>：添加元素</li>
<li><code>list.add(index, num)</code>：在指定位置添加元素</li>
<li><code>list.addAll(list1);</code>：合并两个 list；</li>
<li><code>list.remove(num)</code>：移除特定（num）位置元素</li>
<li><code>list.remove((Integer) num)</code>：移除特定元素（需将其强转为 Integer）</li>
<li><code>list.indexOf(num)</code>：返回第一个匹配元素的下标</li>
<li><code>list.lastIndexOf(num)</code>：返回最后一个匹配元素的下标</li>
<li><code>List&lt;List&lt;Integer&gt;&gt; lists = Lists.partition(list, 3)</code>：将 list 集合按指定长度进行切分，返回新的 List&lt;List&lt;&gt;&gt; lists 集合。例子里将 list 按长度 3 进行切分。</li>
<li><code>Iterator&lt;Integer&gt; it = list.iterator();</code>：获取 list 的 iterator 对象，可用于调用 <code>it.next()</code> 获取数组下一元素或调用 <code>it.hasNext()</code> 判断数组是否存在下一元素。但无 <code>it.peek()</code> 方法。</li>
<li><code>list.sort(Comparator.comparing(Stu::getId))</code>：对 list 中的 Stu 对象排序，例子中是按 Stu 的 id 升序排序。</li>
<li><code>list1.equals(list2)</code>：对比两个列表的各个元素是否相等。</li>
<li><code>Collections.copy(list1, list2);</code>：将 list2 中的元素复制到 list1 中。要求 list1.size() &gt;= list2.size()，且仅覆盖 list1 中前 list2.size() 个元素。</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><blockquote>
<p>LinkedList 是一个继承于 AbstractSequentialList 的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。</p>
</blockquote>
<ul>
<li>声明：<ul>
<li><code>List&lt;Integer&gt; = new LinkedList&lt;&gt;()</code>：普通队列（先进先出）；</li>
<li><code>Deque&lt;Integer&gt; = new LinkedList&lt;&gt;()</code>：双端队列，亦可用作栈；</li>
<li><code>List/Deque&lt;Integer&gt; = new LinkedList&lt;&gt;(Arrays.asList(nums))</code>：其中 nums 是 int[] 数组。该语句将 java.util.Arrays.ArrayList 转化为 java.util.LinkedList，使其可使用 add/remove() 方法。</li>
</ul>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote>
<p>以字符串 s 为例</p>
</blockquote>
<ul>
<li><code>s.length()</code>：获取字符串长度；</li>
<li><code>s.toCharArray()</code>：将字符串 s 转化为字符数组；</li>
<li>遍历字符串字符：<ul>
<li><code>s.charAt(i); i++;</code>：通过 i 递增依次将字符串元素取出来；</li>
<li><code>s.subString(i, i+1); i++;</code>：同理 1；</li>
<li><code>s.toCharArray()</code>：将字符串转化为字符数组再通过循环遍历；</li>
</ul>
</li>
<li>查找字符串是否包含某字符：<ul>
<li><code>s.contains(String str)</code>：若包含 str 子字符串，则返回 true；否则返回 false。</li>
<li><code>s.indexOf(char c)</code>：若包含字符 c，则返回对应下标，否则返回-1；</li>
</ul>
</li>
<li>查找字符串中某字符的索引：<ul>
<li><code>s.indexOf(char/String c)</code>：从前往后查找字符 c，返回最先找到的下标，否则返回 -1；</li>
<li><code>s.indexOf(char/String c, int startIndex)</code>：从下标 startIndex 开始查找，返回第一个查找到的字符 c 的下标；</li>
<li><code>s.lastIndexOf(char/String c)</code>：从后往前查找字符 c，返回最先找到的下标；</li>
<li><code>s.lastIndexOf(char/String c, int startIndex)</code>：从下标 startIndex 开始从后往前查找，返回第一个查找到的字符 c 的下标。</li>
</ul>
</li>
<li>替换字符串中某类字符为另一字符：<ul>
<li><code>s.replace(char/String c1, char/String c2)</code>：全局替换，其中 c1 为被替换字符，c2 为替换字符；</li>
<li><code>s.replaceAll(String str1, String str2)</code>：全局替换，和 1 类似，但支持正则表达式替换；</li>
<li><code>s.replaceFirst(String str1, String str2)</code>：部分替换，仅替换字符串中第一个匹配的字符为另一字符，支持正则表达式。</li>
</ul>
</li>
<li>切割字符串（返回字符串）：<ul>
<li><code>s.substring(int startIndex)</code>：切割自 startIndex 开始的字符串，类似 [startIndex, ]；</li>
<li><code>s.substring(int startIndex, int endIndex)</code>：切割自 startIndex 开始，endIndex 结尾的字符串，类似 [startIndex, endIndex)。</li>
</ul>
</li>
<li>切割字符串（返回数组）：<ul>
<li><code>s.split(String str)</code>：按字符串 str 切割 s，生成的数组会先从后往前遍历去掉空字符串再返回。</li>
<li><code>s.split(String str, int limit)</code>：按字符串 str 切割 s，生成的数组从前往后留下 limit 个元素后返回（不管是否是空字符串）。默认值是 -1，即返回全部元素。</li>
</ul>
</li>
</ul>
<p><strong>补充</strong></p>
<ul>
<li>字符串 - 数字互转<ul>
<li><code>Integer.parseInt(String s)</code>：字符串 s 转数字；</li>
<li><code>String.valueOf(int num)</code>：数字转字符串</li>
</ul>
</li>
<li>字符 - 数字互转<ul>
<li><code>int a = c - &#39;0&#39;;</code>：字符转数字；</li>
<li><code>char c = (char) a</code>：数字转字符；</li>
</ul>
</li>
<li>字符 - 字符串互转<ul>
<li><code>char c = s.charAt(i);</code>：字符串转字符；</li>
<li><code>String s = String.valueOf(c);</code>：字符转字符串。</li>
</ul>
</li>
</ul>
<h3 id="StringBuilder-StringBuffer"><a href="#StringBuilder-StringBuffer" class="headerlink" title="StringBuilder/StringBuffer"></a>StringBuilder/StringBuffer</h3><blockquote>
<p>以 sb 为例</p>
</blockquote>
<ul>
<li><code>sb.length()</code>：获取字符串长度；</li>
<li>声明：<ul>
<li><code>StringBuilder sb = new StringBuilder();</code></li>
<li><code>StringBuilder sb = new StringBuilder(String s);</code></li>
</ul>
<strong>同理 StringBuffer</strong></li>
<li><code>sb.append(int/char/String c);</code>：添加字符</li>
<li><code>sb.insert(int index, char/String c);</code>：在指定位置添加字符</li>
<li>删除字符：<ul>
<li><code>sb.delete(int start, int end)</code>：删除指定区间的子字符串，该区间为 [start, end)；</li>
<li><code>sb.deleteCharAt(int index);</code>：删除指定位置的字符</li>
</ul>
</li>
<li><code>sb.toString();</code>：转化成字符串格式</li>
<li><code>sb.replace(int startIndex, int endIndex, String str)</code>：将 sb 的从 startIndex（含）到 endIndex（不含）的子字符串替换为 str。</li>
</ul>
<h3 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h3><blockquote>
<p>每次添加新的字符串时，添加在声明时指定的间隔符</p>
</blockquote>
<ul>
<li>声明：<ul>
<li><code>StringJoiner sj = new StringJoiner(&quot;, &quot;);</code>：每次新添加字符串时，在后面添加’, ‘：</li>
<li><code>StringJoiner sj = new StringJoiner(&quot;, &quot;, &quot;Hello &quot;, &quot;!&quot;);</code>：每次新添加字符串时，在后面添加’, ‘，同时指定“开头”(Hello)和“结尾”(!)：</li>
</ul>
</li>
<li><code>sj.add(String s)</code>：参数必须为 String 类型</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li>声明：<code>Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</code></li>
<li><code>set.add();</code>：添加元素（添加成功返回true，失败则返回false（已有该元素)）</li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><strong>元素为键值对，一个 map 中仅能含一个键(Key)，可以在多个键中存有相同的值(value)。</strong></p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li><p>添加元素：</p>
<ul>
<li><code>map.put(Key, Value);</code>：添加一对键值对</li>
<li><code>map.putAll(map);</code>：添加 map 中的键值对</li>
</ul>
</li>
<li><p><code>map.get(Object Key);</code>：根据 key 获取指定 value</p>
</li>
<li><p><code>map.remove(Object Key);</code>：根据键删除键值对</p>
</li>
<li><p><code>map.containsKey(Object Key);</code>：查找是否存在键为 Key 的键值对，若有，则返回 true；若无，则返回 false</p>
</li>
<li><p><code>map.containsValue(Object Value);</code>：查找是否存在值为 Value 的键值对，若有，则返回 true；若无，则返回 false</p>
</li>
<li><p><code>map.getOrDefault(key, value);</code>：若map中含有该键key，则使用该键的值；否则使用默认值value</p>
</li>
<li><p>for 循环遍历 map 中的键值对：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中通过entry.getKey()获取键，通过entry.getValue()获取值</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Key, Value&gt; entry : map.entrySet())</span><br></pre></td></tr></table></figure></li>
<li><p>以 List&lt;&gt; 形式获取 map 中的元素：</p>
<ul>
<li><code>map.keySet()</code>：获取 map 中的键</li>
<li><code>map.values()</code>：获取 map 中的值，返回的是 Collection 接口的 list，而不是 List 接口的，需通过 <code>new ArrayList&lt;&gt;()</code> 强转。<br><code>for(Object Key : map.keySet()/map.values())</code> for 循环遍历获取 map 键/值</li>
</ul>
</li>
<li><p><code>map.computeIfAbsent(K key, Function remappingFunction);</code>：获取 map 中某 key 的 value，若该 key 不存在，按函数 remappingFunction 新创建 value 并赋给该 key，并作为方法返回值返回</p>
</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li>声明：<ul>
<li><code>Map&lt;Object Key, Object Value&gt; map = new HashMap&lt;&gt;();</code></li>
<li><code>HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;()&#123;&#123;put("a","b");&#125;&#125;;</code>声明并初始化</li>
</ul>
</li>
</ul>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p><strong>红黑树，元素（键值对）按照键的自然顺序排序（如自然数，按照 1，2，3…的顺序排序）</strong></p>
<ul>
<li>声明：<code>TreeMap&lt;Object Key, Object Value&gt; map = new TreeMap&lt;&gt;();</code></li>
<li>获取首键的值：<code>map.firstKey();</code></li>
<li>获取尾键的值：<code>map.lastKey();</code></li>
</ul>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><blockquote>
<p>以栈 stack 为例</p>
</blockquote>
<ul>
<li>声明：<ul>
<li><code>Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</code>：使用 stack 类声明</li>
<li><code>Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();</code>：使用双端队列声明</li>
</ul>
</li>
<li><code>stack.push(int value);</code>：压入元素</li>
<li><code>stack.peek();</code>：取出栈顶元素（若栈为空，则报NullPointException异常）</li>
<li><code>stack.pop();</code>：取出栈顶元素并删除</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><ul>
<li>声明：<code>Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</code>：普通队列</li>
<li>添加元素至队尾：<ul>
<li><code>queue.offer(int value);</code>（成功则返回 true，失败返回 false）</li>
<li><code>queue.put(int value);</code>（无返回值，若队列满则阻塞）</li>
<li><code>queue.add(int value);</code>（成功则返回 true，失败则抛出 IIIegaISlabEepeplian 异常）</li>
</ul>
</li>
<li>返回队列头部元素：<ul>
<li><code>queue.peek();</code>（若队列为空，则返回 null）</li>
<li><code>queue.element();</code>（若队列为空，则抛出 NoSuchElementException 异常）</li>
</ul>
</li>
<li>移除并返回队列头部元素：<ul>
<li><code>queue.poll();</code>（若队列为空，则返回null）</li>
<li><code>queue.take();</code>（若队列为空，则阻塞）</li>
<li><code>queue.remove();</code>（若队列为空，则抛出 NoSuchElementException 异常）</li>
</ul>
</li>
</ul>
<h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><blockquote>
<p>双端队列，除有普通队列的方法外，还有如下方法</p>
</blockquote>
<ul>
<li>声明： <code>Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</code>：双端队列</li>
<li>添加元素：<ul>
<li>至队头：<code>queue.addFirst();</code></li>
<li>至队尾：<code>queue.addLast();</code></li>
</ul>
</li>
<li>返回队列元素：<ul>
<li>返回队头元素：<code>queue.peekFirst();</code></li>
<li>返回队尾元素：<code>queue.peekLast();</code></li>
</ul>
</li>
<li>移除队列元素：<ul>
<li>移除队头元素：<code>queue.removeFirst();</code></li>
<li>移除队尾元素：<code>queue.removeLast();</code></li>
</ul>
</li>
</ul>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p><strong>优先级队列实现了 queue 接口（因此可使用 Queue 方法），属升序队列，数组形式，左侧为队头，右侧为队尾，本质是小根堆。每次插入元素会自动重新排序，以确保队列元素保持为升序顺序。</strong><br><strong>优先级队列每次以 O(1) 时间复杂度取出队列权值最小的元素（即队头元素），以 O(logn) 插入新元素。</strong></p>
<ul>
<li>声明：<ul>
<li>小根堆：<code>PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();</code></li>
<li>大根堆：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
简化版：<code>PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((o1, o2)-&gt;o2.compareTo(o1));</code></li>
</ul>
</li>
</ul>
<hr>
<h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><ul>
<li><code>Math.sqrt(double num)</code> 开根号</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><strong>^（异或运算）</strong><br>同 0 同 1 的异或为 0，不同 0、1 的异或为 1。异或运算的性质：</p>
<ol>
<li>异或运算满足交换律和结合律；</li>
<li>任何整数和自身做异或运算的结果都等于0；</li>
<li>任何整数和0做异或运算的结果都等于自身</li>
</ol>
<p><strong>&lt;&lt; 和 &gt;&gt;（左移运算符和右移运算符）</strong></p>
<ul>
<li>左移运算符：在二进制形式下是数字的每一位左移一位（每一位增加两倍），因此十进制形式下是数字变为原来的两倍。</li>
<li>右移运算符：同理，在二进制形式下是数字的每一位右移一位（每一位减少两倍），因此十进制形式下是数字变为原来的二分之一。</li>
</ul>
<hr>
<h1 id="Java-注解"><a href="#Java-注解" class="headerlink" title="Java 注解"></a>Java 注解</h1><p>注解就是某种注解类型的一个实例，我们可以用它在某个类上进行标注，这样编译器在编译我们的文件时，会根据我们自己设定的方法来编译类。</p>
<img src="/2021/02/05/Java/%E6%B3%A8%E8%A7%A31.jpg" class="">

<h2 id="标准元注解"><a href="#标准元注解" class="headerlink" title="标准元注解"></a>标准元注解</h2><p>标准元注解是自定义注解的注解，主要包含 4 个，都位于 java.lang.annotation 包中，我们创建自定义注解时会用到 4 个标准元注解：</p>
<ul>
<li>@Documented：用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。是一个标记注解，没有成员。</li>
<li>@Inherited：是一个标记注解，阐述了某个被标注的类型是被继承的。使用了 @Inherited 修饰的注解类型被用于一个 class 时该 class 的子类也有了该注解。</li>
<li>@Retention：可以用来修饰注解，是注解的注解，称为元注解。Retention 注解有一个属性 value，是 RetentionPolicy 类型的，Enum RetentionPolicy 是一个枚举类型。这个枚举决定了 Retention 注解应该如何去保持，也可理解为 Rentention 搭配 RententionPolicy 使用。若按生命周期来划分，RetentionPolicy 可分为 3 类：<ul>
<li>RetentionPolicy.SOURCE：注解只保留在源文件，当 Java 文件编译成 class 文件的时候，注解被遗弃；</li>
<li>RetentionPolicy.CLASS：注解被保留到 class 文件，但 jvm 加载 class 文件时候被遗弃，这是默认的生命周期；</li>
<li>RetentionPolicy.RUNTIME：注解不仅被保存到 class 文件中，jvm加载 class 文件之后，仍然存在；</li>
</ul>
  <strong>这 3 个生命周期分别对应于：Java源文件(.java文件) —&gt; .class文件 —&gt; 内存中的字节码。</strong><br>  一般如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解，比如 @Deprecated 使用 RUNTIME 注解<br>  如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS 注解；<br>  如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，使用 SOURCE 注解。</li>
<li>@Target：说明了注解所修饰的对象范围：注解可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。修饰范围枚举：<ul>
<li>ElementType.PACKAGE：用于描述包</li>
<li>ElementType.TYPE：用于描述类、接口(包括注解类型) 或enum声明，最常用</li>
<li>ElementType.METHOD：作用于方法</li>
<li>ElementType.CONSTRUCTOR：作用于构造器</li>
<li>ElementType.FIELD：作用于域/属性</li>
<li>ElementType.PARAMETER：用于描述参数</li>
<li>ElementType.LOCAL_VARIABLE：用于描述局部变量</li>
</ul>
</li>
</ul>
<h2 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h2><ul>
<li>@Service：用于标注业务层组件（service 层）</li>
<li>@Controller：用于标注控制层组件（controller 层）。@Controller 用来响应页面，@Controller必须配合模版来使用</li>
<li>@Data：<ul>
<li>@Data 可以为类提供读写功能，从而不用写 get、set 方法。</li>
<li>@Data 提供 equals()、hashCode()、toString() 方法。</li>
</ul>
</li>
<li>@RestController：@RestController = @Controller + @ResponseBody。是 2 个注解的合并效果，即指定了该 controller 是组件，又指定方法返回的是 String 或 json 类型数据。</li>
<li>@Resource：默认按 byName 自动注入,如果找不到再按 byType 找 bean，如果还是找不到则抛异常，无论按 byName 还是 byType 如果找到多个，则抛异常。可以手动指定 bean,它有 2 个属性分别是 name 和 type，使用 name 属性，则使用 byName 的自动注入，而使用 type 属性时则使用 byType 自动注入。</li>
<li>@RequestMapping：处理映射请求的注解，用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。有6个属性。<ul>
<li>value：指定请求的实际地址，指定的地址可以是URI Template 模式；</li>
<li>method：指定请求的 method 类型， GET、POST、PUT、DELETE等；</li>
<li>consumes：指定处理请求的提交内容类型（Content-Type）</li>
<li>produces：指定返回的内容类型，仅当 request 请求头中的(Accept)类型中包含该指定类型才返回；</li>
<li>params：指定 request 中必须包含某些参数值，才让该方法处理；</li>
<li>headers：指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。</li>
</ul>
</li>
<li>@Qualifier：按照 byName 的方式注入 bean</li>
<li>@PostConstruct：在构造方法和 init 方法（如果有的话）之间得到调用，且只会执行一次。</li>
<li>@ControllerMonitor：配置监控</li>
<li>@EnableAspectJAutoProxy：该注解用来启用自动代理功能。</li>
</ul>
<p><strong>AOP 注解</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903925112373262#heading-18">Spring AOP使用讲解</a></p>
</blockquote>
<ul>
<li>@Aspect：切面。将一个 java 类定义为切面类，表示一个横切进业务的一个对象。它里面包含切入点（Pointcut）和通知（Advice）。使用@Aspect 注解的切面类必须是一个 bean(不管以何种方式声明)，否则切面不会生效，因为 AspectJ 自动代理只会为使用 @Aspect 注解的 bean 创建代理类。</li>
<li>@Pointcut：定义切入点（被该注解定义的切入点可被应用于后续通知中复用）。表示需要切入的位置，比如某些类或者某些方法，也就是先定一个范围。切点方法：<code>private void 无参数方法</code>，方法名为切点名。Spring AOP 支持以下 10 种类型表达式：<ul>
<li>execution：一般用于指定方法的执行，用的最多。<br>一般形式：<code>execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)</code>。<br><code>eg：@Pointcut(&quot;execution(* chapter04.concert.Performance.perform(..))&quot;)</code>，其中 <code>execution(* chapter04.concert.Performance.perform(..))</code> 被称为 AspectJ 切点表达式。解析如下：<ul>
<li>execution：在方法执行时触发</li>
<li>*：表明我们不关心方法返回值的类型，即可以是任意类型</li>
<li>chapter04.concert.Performance.perform：使用全限定类名和方法名指定要添加前置通知的方法（chapter04.concert 是包名，Performance 是类名，perform 是方法名）</li>
<li>(..)：方法的参数列表使用(..)，表明我们不关心方法的入参是什么，即可以是任意类型</li>
</ul>
</li>
<li>within：指定某些类型的全部方法执行，也可用来指定一个包。</li>
<li>this：Spring Aop是基于代理的，生成的bean也是一个代理对象，this就是这个代理对象，当这个对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop 将生效。</li>
<li>target：当被代理的对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop 将生效。</li>
<li>args：当执行的方法的参数是指定类型时生效。</li>
<li>@annotation：当执行的方法上拥有指定的注解时生效。<code>eg：@Pointcut(&quot;@annotation(ControllerMonitor)&quot;)</code></li>
<li>@args：当执行的方法参数类型上拥有指定的注解时生效。</li>
<li>@target：当代理的目标对象上拥有指定的注解时生效。</li>
<li>@within：与@target类似，看官方文档和网上的说法都是 @within 只需要目标对象的类或者父类上有指定的注解，则 @within 会生效，而 @target 则是必须是目标对象的类上有指定的注解。而根据笔者的测试这两者都是只要目标类或父类上有指定的注解即可。</li>
<li>bean：当调用的方法是指定的 bean 的方法时生效。</li>
</ul>
</li>
<li>@Around：Advice（通知）的一种，环绕切入点执行也就是把切入点包裹起来执行。</li>
<li>@Before：Advice（通知）的一种，切入点的方法体执行之前执行。</li>
<li>@After：Advice（通知）的一种，在切入点正常运行结束后执行。</li>
<li>@AfterReturning：Advice（通知）的一种，在切入点正常运行结束后执行，异常则不执行。<code>eg：@AfterReturning(value=&quot;pointCut()&quot;, returning = &quot;returnVal&quot;)</code>，解析如下：<ul>
<li>value：指定切入点，可复用被 @Pointcut 修饰的方法，eg 中的 pointCut() 正是被 @Pointcut 修饰的方法</li>
<li>returning：切入方法返回的值，该值”returnVal”可作为被修饰方法的参数</li>
</ul>
</li>
<li>@AfterThrowing：Advice（通知）的一种，在切入点运行异常时执行。<code>eg：@AfterThrowing(value=&quot;pointCut()&quot;, throwing = &quot;e&quot;)</code>，解析如下：<ul>
<li>value：指定切入点，可复用被 @Pointcut 修饰的方法，eg 中的 pointCut() 正是被 @Pointcut 修饰的方法</li>
<li>throwing：切入方法抛出的异常，该值”e”可作为被修饰方法的参数</li>
</ul>
  <strong>通知执行顺序：@Around -&gt; @Before -&gt; @After -&gt; @AfterReturning/@AfterThrowing</strong></li>
</ul>
<p><strong>补充：@After 和 @AfterReturning</strong><br>不管目标方法是否执行成功，@After 注解都会执行，但 @AfterReturning 注解只会在目标方法执行成功时执行。</p>
<h2 id="Java-测试注解"><a href="#Java-测试注解" class="headerlink" title="Java 测试注解"></a>Java 测试注解</h2><ul>
<li>@Test：一般测试类</li>
<li>@BeforeClass：每次测试类执行前执行一次，主要用来初使化公共资源等</li>
<li>@AfterClass：每次测试类执行完成后执行一次，主要用来释放资源或清理工作</li>
<li>@Before：每个测试案例执行前都会执行一次</li>
<li>@After：每个测试案例执行完成后都会执行一次</li>
<li>@Test(expected=xxxException.class)：测试是否报异常（抛出异常测试通过）</li>
<li>@Test(timeout=1000)：测试运行时间（timeout 时间内执行完通过）</li>
<li>@Mock：创建一个Mock</li>
<li>@InjectMocks：创建一个实例，其余的由用 @Mock（或 @Spy）注解创建的 mock 注入到该实例中。</li>
<li>@Tag：可用于从测试计划中过滤测试用例；</li>
<li>@RunWith：JUnit 用例都是在 Runner（运行器）来执行的，通过 @RunWith 注解可以为测试类指定一个特定的 Runner。<br>  <strong>补充</strong><br>  @RunWith(MockitoJUnitRunner.class) 与 MockitoAnnotations.initMocks(this) 语句对比，二者功能类似，体现在如下两点：<ol>
<li>都可以为 UT 提供框架使用的自动验证。在写UT时，若在 mock 数据有语法或者书写错误，框架使用的自动验证会在单元测试运行的时候报告出来。</li>
<li>对 UT 提供 mock 初始化工作：在单元测试中使用 @Mock, @Spy, @InjectMocks 等注解时，需要进行初始化后才能使用。</li>
</ol>
</li>
</ul>
<h2 id="lombok-注解"><a href="#lombok-注解" class="headerlink" title="lombok 注解"></a>lombok 注解</h2><p>需要安装 lombok 插件，并添加 lombok 的 Maven 依赖</p>
<ul>
<li>@Setter/@Getter ：可以为相应的属性自动生成Getter/Setter方法</li>
<li>@Slf4j：一个日志标准，提供了日志接口、获取具体日志对象的方法</li>
</ul>
<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><p><strong>注解对象解析</strong><br>通过 debug 可以知道，注解是一个 Proxy 实例。里面仅含一个属性 h，属性 h 是一个 AnnotationInvocationHandler 类型的对象。h 对象中包含一个 memberValues 对象（LinkedHashMap 类型），里面装着 key 就是我们自定义注解的属性，value 就是被赋的值。举例如下，其中 foo 是注解实例：</p>
<img src="/2021/02/05/Java/%E6%B3%A8%E8%A7%A32.jpg" class="">
<p><strong>动态修改注解的值</strong><br>AnnotationInvocationHandler 类的部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6182022883658399397L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现 memberValues 对象是 private final 修饰的。因此若要修改 memberValues 的值，需先通过反射修改 memberValues 的访问权限，再修改 memberValues 的值。<br>所以动态修改注解的值的方法为：通过反射得到注解的代理对象，然后得到代理对象的 memberValues 属性，修改访问权限，更新注解的 key 对应的属性值。eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Foo &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionAnnotationTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 Bar 实例</span></span><br><span class="line">        Bar bar = <span class="keyword">new</span> Bar();</span><br><span class="line">        <span class="comment">// 获取 Bar 的 value 字段，该字段被 Foo 注解</span></span><br><span class="line">        Field field = bar.getClass().getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取 val 字段上的 Foo 注解实例</span></span><br><span class="line">        Foo foo = field.getAnnotation(Foo.class);</span><br><span class="line">        <span class="comment">// 获取 Foo 注解实例的 value 属性值</span></span><br><span class="line">        String value =  foo.value();</span><br><span class="line">        <span class="comment">// 打印该值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;修改之前的注解值：&quot;</span> + value);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;------------以下是修改注解的值------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取 foo 这个代理实例所持有的 InvocationHandler</span></span><br><span class="line">        InvocationHandler invocationHandler = Proxy.getInvocationHandler(foo);</span><br><span class="line">        <span class="comment">// 获取 AnnotationInvocationHandler 的 memberValues 字段</span></span><br><span class="line">        Field declaredField = invocationHandler.getClass().getDeclaredField(<span class="string">&quot;memberValues&quot;</span>);</span><br><span class="line">        <span class="comment">// 因为这个字段是 private final 修饰，所以要打开权限</span></span><br><span class="line">        declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 获取 (Map)memberValues。该 map 中含所有注解实例</span></span><br><span class="line">        Map memberValues = (Map) declaredField.get(invocationHandler);</span><br><span class="line">        <span class="comment">// 修改 value 属性值</span></span><br><span class="line">        memberValues.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;test.annotation.new.value&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取 foo 的 value 属性值</span></span><br><span class="line">        String newValue = foo.value();</span><br><span class="line">        System.out.println(<span class="string">&quot;修改之后的注解值：&quot;</span> + newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>常用方法</strong></p>
<ul>
<li>isAnnotationPresent()。判断类/方法/成员变量是否被某注解修饰<ul>
<li><code>boolean isExist = c.isAnnotationPresent(Foo.class);</code>。其中 c 是 Class 对象。</li>
<li><code>boolean isExist = m.isAnnotationPresent(Foo.class);</code>。其中 m 是 Method 对象。</li>
<li><code>boolean isExist = f.isAnnotationPresent(Foo.class);</code>。其中 f 是 Field 对象。</li>
</ul>
</li>
<li>getAnnotation()。获取被某注解修饰的类/方法/成员变量的该注解实例。在赋值前需要使用类型强转<ul>
<li><code>Foo foo = (Foo) c.getAnnotation(Foo.class);</code></li>
<li><code>Foo foo = (Foo) m.getAnnotation(Foo.class);</code></li>
<li><code>Foo foo = (Foo) f.getAnnotation(Foo.class);</code></li>
</ul>
</li>
<li>getAnnotations()。获取类/方法/成员变量上面的所有注解实例。<ul>
<li><code>Annotation[] as = c.getAnnotations();</code></li>
<li><code>Annotation[] as = m.getAnnotations();</code></li>
<li><code>Annotation[] as = f.getAnnotations();;</code></li>
</ul>
</li>
<li>获取注解实例的成员变量：<code>foo.value();</code>。其中 value 是成员变量</li>
<li>判断某注解实例是否是某注解类的对象：<code>if(foo instanceof Foo)</code></li>
<li>获取注解实例的 AnnotationInvocationHandler 对象：<code>InvocationHandler invocationHandler = Proxy.getInvocationHandler(foo);</code></li>
<li>获取 AnnotationInvocationHandler 的 memberValues 成员变量：<code>Field f = invocationHandler.getClass().getDeclaredField(&quot;memberValues&quot;);</code></li>
<li>将 invocationHandler 传回成员变量 f 获得指定注解实例：<code>Foo foo = ((Map)f.get(invocationHandler))s.get(&quot;foo&quot;)</code>。</li>
</ul>
<p><strong>使用自定义注解</strong><br>使用注解的语法：<br>@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)</p>
<hr>
<h1 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h1><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/java-class-forname.html">Java class.forname 详解</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fengyuzhengfan/article/details/38086743">Class.forName()的作用与使用总结</a></p>
</blockquote>
<p>Java 程序在运行时，Java 运行时系统一直对所有的对象进行所谓的运行时类型标识。这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是 Class 类。Class 类封装一个对象和接口运行时的状态，当装载类时，Class 类型的对象自动创建。<br>Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个 Class 对象。<br>基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。 </p>
<h3 id="获取-Class-对象（三种方法）"><a href="#获取-Class-对象（三种方法）" class="headerlink" title="获取 Class 对象（三种方法）"></a>获取 Class 对象（三种方法）</h3><ol>
<li>getClass() 方法<br>最常见的产生 Class 对象的方法。getClass() 方法是 Object 里的方法，在 java 中，Object 类是所有类的超类，因此任何一个类，都有 getClass() 方法。该方法用于获取对象的运行时对象的类。<br><code>MyObject x;    Class c = x.getClass();</code></li>
<li>Class.forName()<br>使用 Class 类中的静态方法 forName() 获得与字符串参数对应的 Class 对象：获得字符串参数中指定的类，并初始化该类<br><code>Class c = Class.forName(&quot;com.test.MyObject&quot;);</code> 其中 com.test 是包名， MyObject 是类名。</li>
<li>T.class<br>如果 T 是一个 Java 类型，那么 T.class 就代表了匹配的类对象。<br><code>Class c = MyObject.class;</code></li>
</ol>
<h3 id="Class-对象的常用方法"><a href="#Class-对象的常用方法" class="headerlink" title="Class 对象的常用方法"></a>Class 对象的常用方法</h3><ul>
<li>getName()<br>一个 Class 对象描述了一个特定类的属性，Class 类中最常用的方法 getName 以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。</li>
<li>newInstance()<br>newInstance() 方法可以为 Class 类创建一个实例。例如：<code>x.getClass().newInstance()</code>，创建了一个同 x 一样类型的新实例。newInstance() 方法调用默认构造器（无参数构造器）初始化新建对象。<br>  <strong>在初始化一个类，并生成一个实例的时候，newInstance() 方法和 new 关键字的区别：</strong><ul>
<li>newInstance() 是方法，new 是关键字；</li>
<li>创建对象的方式不一样，前者是使用类加载机制，后者是创建一个新类。</li>
<li>从JVM的角度看，我们使用关键字 new 创建一个类的时候，这个类可以没有被加载。但是使用 newInstance() 方法的时候，就必须保证：1、这个类已经加载；2、这个类已经连接了。而完成上面两个步骤的正是 Class 的静态方法 forName() 所完成的，这个静态方法调用了启动类加载器，即加载 java API 的那个加载器。现在可以看出，newInstance() 实际上是把 new 这个方式分解为两步，即首先调用 Class 加载方法加载某个类，然后实例化。这样分步的好处是显而易见的：我们可以在调用 class 的静态加载方法 forName 时获得更好的灵活性，提供了一种降耦的手段。</li>
<li>newInstance: 弱类型，低效率，只能调用无参构造。new: 强类型，相对高效，能调用任何public构造。</li>
</ul>
</li>
<li>getClassLoader()<br>返回该类的类加载器。</li>
<li>getSuperclass()<br>返回此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。</li>
<li>isArray()<br>判定此 Class 对象是否表示一个数组类。</li>
</ul>
<h3 id="成员变量常用方法"><a href="#成员变量常用方法" class="headerlink" title="成员变量常用方法"></a>成员变量常用方法</h3><blockquote>
<p>student 是 Student 类的对象，name 是 student 的一个公共成员变量，setName(String name) 是 Student 类的一个公共成员方法。c 是 Class 对象。field 是 Field 类型的一个对象。</p>
</blockquote>
<ul>
<li>getField()<br>  <code>Field nameField = c.getField(&quot;name&quot;);</code> 获取类的 public 修饰的某指定成员变量（含基类）</li>
<li>getDeclaredField()<br>  <code>Field nameField = c.getDeclaredField(&quot;name&quot;);</code> 获取类的任意指定成员变量（不含基类）</li>
<li>getFields()<br>  <code>Field[] fields = c.getFields();</code> 获取类的所有 public 成员变量，包括基类</li>
<li>getDeclaredFields()<br>  <code>Field[] fields = c. getDeclaredFields();</code> 获取类自身的所有成员变量，不包括基类</li>
<li>getName()<br>  <code>String name = field.getName();</code> 获取成员变量名。field 是 Field[] 的一个元素。<br>  获取到成员变量后，使用 field.set(“成员变量所在类的对象”, “成员变量的值”) 给成员变量赋值</li>
<li>getModifiers()<br>  <code>int modifiers = field.getModifiers();</code> 获取成员属性修饰符。1 代表的是 public，2 代表的是 private</li>
<li>get()<br>  <code>Object value = field.get(student);</code> 获取对象该属性的值</li>
<li>set()<br>  <code>field.set(obj, value);</code> 设置对象 obj 该属性的值为 value</li>
<li>isAccessible()<br>  <code>boolean accessFlag = field.isAccessible();</code> 获取对象的访问权限</li>
<li>setAccessible()<br>  <code>field.setAccessible(true);</code> 设置对象的访问权限。在这里是将其设置为可访问。</li>
</ul>
<p><strong>同理适用于成员方法，但仍有以下不同：</strong></p>
<ul>
<li>getDeclaredMethod()<br>  <code>Method method = c.getDeclaredMethod(&quot;setName&quot;, String.class);</code> 获取类的任意指定成员方法（不含基类）。第一个参数是方法名，第二个参数是方法的参数类型（若有多个类型，逗号间隔添加）</li>
<li>invoke()<br>  <code>method.invoke(student, name);</code> 执行对象的该成员方法。第一个参数是对象，第二个参数是参数</li>
</ul>
<p><strong>获取到成员方法后，使用 method.invoke(student, “方法的参数”) 调用（反射）方法</strong><br><strong>若成员变量/方法为 private，必须进行 field/method.setAccessible() 操作</strong></p>
<p><strong>补充：setAccessible(true)用法及意义：</strong><br>Accessible 属性继承自 AccessibleObject 类，功能是启用或禁用安全检查（是否检查成员修饰符，如 private 等）。值为 true 表示反射的对象在使用时应该取消 Java 语言访问检查，即忽略成员修饰符。同时由于JDK的安全检查耗时较多，所以 setAccessible(true) 也可提升反射速度。<br>setAccessible() 可作用于两处：</p>
<ol>
<li>作用于方法上：method.setAccessible(true);</li>
<li>作用于属性上：field.setAccessible(true);</li>
</ol>
<h3 id="Class-的一些使用技巧"><a href="#Class-的一些使用技巧" class="headerlink" title="Class 的一些使用技巧"></a>Class 的一些使用技巧</h3><ul>
<li>forName 和 newInstance 结合起来使用，可以根据存储在字符串中的类名创建对象。例如<br><code>Object obj = Class.forName(s).newInstance();</code></li>
<li>虚拟机为每种类型管理一个独一无二的 Class 对象。因此可以使用 == 操作符来比较类对象。例如：<br><code>if(e.getClass() == Employee.class)</code></li>
</ul>
<hr>
<h1 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h1><h2 id="ThreadPoolTaskExecutor"><a href="#ThreadPoolTaskExecutor" class="headerlink" title="ThreadPoolTaskExecutor"></a>ThreadPoolTaskExecutor</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li><p>使用 java comfig：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ThreadPoolTaskExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">  <span class="comment">// 核心线程数</span></span><br><span class="line">  poolExecutor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">// 最大线程数</span></span><br><span class="line">  poolExecutor.setMaxPoolSize(<span class="number">15</span>);</span><br><span class="line">  <span class="comment">// 队列大小</span></span><br><span class="line">  poolExecutor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">  <span class="comment">// 线程最大空闲时间</span></span><br><span class="line">  poolExecutor.setKeepAliveSeconds(<span class="number">300</span>);</span><br><span class="line">  <span class="comment">// 拒绝策略</span></span><br><span class="line">  poolExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">  <span class="comment">// 线程名称前缀</span></span><br><span class="line">  poolExecutor.setThreadNamePrefix(<span class="string">&quot;my-pool-&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> poolExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 xml config</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;taskExecutor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;corePoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;8&quot;</span>/&gt;</span> <span class="comment">&lt;!--核心线程数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;16&quot;</span>/&gt;</span> <span class="comment">&lt;!--最大线程数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;keepAliveSeconds&quot;</span> <span class="attr">value</span> =<span class="string">&quot;3000&quot;</span>/&gt;</span> <span class="comment">&lt;!--线程最大空闲时间 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queueCapacity&quot;</span> <span class="attr">value</span>=<span class="string">&quot;200&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 队列大小 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;threadNamePrefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;my-pool-&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>rejectedExecutionHandler字段用于配置拒绝策略，常用的拒绝策略如下：</p>
<ul>
<li>AbortPolicy，用于被拒绝任务的处理程序，它将抛出 RejectedExecutionException。</li>
<li>CallerRunsPolicy，用于被拒绝任务的处理程序，它直接在 execute 方法的调用线程中运行被拒绝的任务。</li>
<li>DiscardOldestPolicy，用于被拒绝任务的处理程序，它放弃最旧的未处理请求，然后重试execute。</li>
<li>DiscardPolicy，用于被拒绝任务的处理程序，默认情况下它将丢弃被拒绝的任务。</li>
</ul>
<p><strong>补充</strong></p>
<ul>
<li>为了实现某些特殊的业务需求，用户可以选择使用自定义策略，只需实现 RejectedExecutionHandler 接口即可。</li>
<li>建议配置 threadNamePrefix 属性，出问题时可以更方便的进行排查。</li>
</ul>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><ul>
<li>无返回值的任务使用 execute(Runnable)</li>
<li>有返回值的任务使用 submit(Runnable)</li>
</ul>
<h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><ol>
<li>当一个任务被提交到线程池时，首先查看线程池的核心线程是否都在执行任务，否就选择一条线程执行任务，是就执行第二步。</li>
<li>查看核心线程池是否已满，不满就创建一条线程执行任务，否则执行第三步。</li>
<li>查看任务队列是否已满，不满就将任务存储在任务队列中，否则执行第四步。</li>
<li>查看线程池是否已满，不满就创建一条线程执行任务，否则就按照策略处理无法执行的任务。</li>
</ol>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>调用 shutdown 或者 shutdownNow，两者都不会接受新的任务，而且通过调用要停止线程的 interrupt 方法来中断线程，有可能线程永远不会被中断，不同之处在于 shutdownNow 会首先将线程池的状态设置为 STOP，然后尝试停止所有线程（有可能导致部分任务没有执行完）然后返回未执行任务的列表。而 shutdown 则只是将线程池的状态设置为 shutdown，然后中断所有没有执行任务的线程，并将剩余的任务执行完。</p>
<h3 id="配置线程个数"><a href="#配置线程个数" class="headerlink" title="配置线程个数"></a>配置线程个数</h3><ul>
<li>如果是 CPU 密集型任务，那么线程池的线程个数应该尽量少一些，一般为 CPU 的个数 + 1 条线程。</li>
<li>如果是 IO 密集型任务，那么线程池的线程可以放的很大，如 2 * CPU 的个数。</li>
<li>对于混合型任务，如果可以拆分的话，通过拆分成 CPU 密集型和 IO 密集型两种来提高执行效率；如果不能拆分的的话就可以根据实际情况来调整线程池中线程的个数。</li>
</ul>
<h3 id="监控线程池状态"><a href="#监控线程池状态" class="headerlink" title="监控线程池状态"></a>监控线程池状态</h3><p>常用状态：</p>
<ul>
<li>taskCount：线程需要执行的任务个数。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数。</li>
<li>largestPoolSize：线程池曾经创建过的最大线程数量。</li>
<li>getPoolSize：获取当前线程池的线程数量。</li>
<li>getActiveCount：获取活动的线程的数量</li>
</ul>
<p><strong>通过继承线程池，重写 beforeExecute，afterExecute 和 terminated 方法来在线程执行任务前，线程执行任务结束，和线程终结前获取线程的运行情况，根据具体情况调整线程池的线程数量。</strong></p>
<hr>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>IoC 容器：具有依赖注入功能的容器。通过阅读配置元数据（可通过 XML，Java 注释或 Java 代码来表示）提供的指令，IOC 容器可以创建、实例化对象，定位、配置应用程序中的对象及建立这些对象间的依赖。通常 new 一个实例，控制权由程序员控制，而”控制反转”是指 new 实例工作不由程序员来做而是交给 Spring 容器来做。</p>
</li>
<li><p>Bean 定义：bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。Bean 由容器提供的配置元数据创建，是构成应用程序的支柱。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">class</td>
<td align="left">必需。用来指定该 bean 定义中的 bean 类</td>
</tr>
<tr>
<td align="left">id/name</td>
<td align="left">必需。bean 的唯一标识符</td>
</tr>
<tr>
<td align="left">scope</td>
<td align="left">默认作用域为 singleton，指定该 bean 定义所创建对象的作用域</td>
</tr>
<tr>
<td align="left">constructor-arg</td>
<td align="left">配置基于构造函数的依赖注入</td>
</tr>
<tr>
<td align="left">properties</td>
<td align="left">配置基于设值函数的依赖注入</td>
</tr>
<tr>
<td align="left">autowiring mode</td>
<td align="left">自动装配</td>
</tr>
<tr>
<td align="left">lazy-initialization mode</td>
<td align="left">延迟初始化。IoC 容器在 bean 第一次被请求时，而不是在启动时去创建一个 bean 实例</td>
</tr>
<tr>
<td align="left">initialization 方法</td>
<td align="left">在 bean 的所有必需的属性被容器设置之后，调用回调方法</td>
</tr>
<tr>
<td align="left">destruction 方法</td>
<td align="left">当包含该 bean 的容器被销毁时，调用回调方法</td>
</tr>
</tbody></table>
</li>
<li><p>Bean 作用域</p>
<table>
<thead>
<tr>
<th align="left">作用域</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton</td>
<td align="left">默认值。在 Spring IoC 中容器仅存在一个同名 Bean 实例，Bean 以单例方式存在</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left">每次从容器中调用 Bean 时，都返回一个新的实例</td>
</tr>
<tr>
<td align="left">request</td>
<td align="left">仅适用 WebApplicationContext 环境。每次 HTTP 请求都会创建一个新的 Bean</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">同上。同一个 HTTP Session 共享一个 Bean，不同 Session 使用不同的 Bean</td>
</tr>
<tr>
<td align="left">global-session</td>
<td align="left">同上。一般用于 Portlet 应用环境</td>
</tr>
</tbody></table>
</li>
<li><p>Bean 生命周期：Bean 定义——Bean 初始化——Bean 的使用——Bean 销毁。其中 xml 配置文件中的 init-method/destroy-method 参数分别适用于 Bean 初始化/Bean 销毁阶段</p>
</li>
</ul>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><blockquote>
<p>基于 Beans.xml 配置文件。使用 <code>&lt;bean&gt;</code> 元素来声明 bean。<br>通过使用 XML 配置文件中的 <code>&lt;constructor-arg&gt;</code> 和 <code>&lt;property&gt;</code> 元素来注入依赖。</p>
</blockquote>
<p><strong>基于构造函数/设值函数的依赖注入，本质是通过被注入对象作为函数参数传入，以使容器识别该类的 bean 并注入 bean 的过程</strong></p>
<h3 id="基于构造函数"><a href="#基于构造函数" class="headerlink" title="基于构造函数"></a>基于构造函数</h3><p>当容器调用带有一组参数的类构造函数时，基于构造函数的 DI 就完成了，其中每个参数代表一个对其他类的依赖。</p>
<ul>
<li>若构造函数的参数为类的对象，则在 bean 定义中，需指定<strong>引用属性</strong>的值为参数类的 bean id。如<code>&lt;constructor-arg ref=&quot;spellChecker&quot;/&gt;</code></li>
<li>若构造函数的参数为基本类型，则在 bean 定义中，需指定参数类型和值。如<code>&lt;constructor-arg type=&quot;int&quot; value=&quot;2001&quot;/&gt;</code></li>
</ul>
<p>若构造函数传入多个参数，需指定依赖注入的顺序：</p>
<ul>
<li>根据构造函数参数的顺序确定依赖在 bean 定义中的顺序；</li>
<li>根据构造函数参数的顺序，使用 index 属性显示指定依赖注入的顺序。如 <code>&lt;constructor-arg index=&quot;0&quot; value=&quot;2001&quot;/&gt;</code></li>
</ul>
<h3 id="基于设值函数"><a href="#基于设值函数" class="headerlink" title="基于设值函数"></a>基于设值函数</h3><p>若容器调用一个无参的构造函数或一个无参的静态 factory 方法来初始化 bean，容器需通过在 bean 上调用设值函数（set方法）注入依赖。</p>
<ul>
<li>若依赖注入为引用，则使用 ref 属性。如  <code>&lt;property name=&quot;spellChecker&quot; ref=&quot;spellChecker&quot;/&gt;</code></li>
<li>若依赖注入为基本类型，则使用 value 属性。如 <code>&lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;</code></li>
</ul>
<p>也可通过 p-namespace 以一种更简洁的方式重写：</p>
<ul>
<li>若依赖注入为引用：<code>p:spellChecker-ref=&quot;spellChecker&quot;</code></li>
<li>若依赖注入为基本类型：<code>p:name=&quot;John Doe&quot;</code></li>
</ul>
<h3 id="注入内部-beans"><a href="#注入内部-beans" class="headerlink" title="注入内部 beans"></a>注入内部 beans</h3><p>以设值函数引用的依赖注入为例：免去 ref 属性，改为配置 bean id 和 class 地址。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textEditor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tutorialspoint.TextEditor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;spellChecker&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;spellChecker&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tutorialspoint.SpellChecker&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Beans-自动装配"><a href="#Beans-自动装配" class="headerlink" title="Beans 自动装配"></a>Beans 自动装配</h2><blockquote>
<p>使用 <code>&lt;bean&gt;</code> 元素的 <code>autowire</code> 属性为一个 bean 定义指定自动装配模式。</p>
</blockquote>
<p>Spring 容器可以在不使用 <code>&lt;constructor-arg&gt;</code> 和 <code>&lt;property&gt;</code> 元素的情况下自动装配相互协作的 bean 之间的关系，这有助于减少编写一个大的基于 Spring 的应用程序的 XML 配置的数量。</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">无</td>
<td align="left">默认设置，它意味着没有自动装配。此时应参考“依赖注入”一章显性配置依赖注入</td>
</tr>
<tr>
<td align="left">byName</td>
<td align="left">由属性名自动装配。XML 配置文件中 bean 的 autowire 的属性需设置为 byName，此时 Spring 容器会注入配置文件中被定义为相同名称的 beans 属性</td>
</tr>
<tr>
<td align="left">byType</td>
<td align="left">由属性数据类型自动装配。XML 配置文件中 bean 的 autowire 的属性需设置为 byType。此时 Spring 容器会注入配置文件中被定义名称与数据类型相同的 beans 属性。若存在不止一个这样的 bean，则抛出异常</td>
</tr>
<tr>
<td align="left">constructor</td>
<td align="left">类似于 byType，但该值适用于构造函数参数类型</td>
</tr>
</tbody></table>
<h2 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h2><p>从 Spring 2.5 开始就可以使用注解来配置依赖注入，而不是采用 XML 来描述一个 bean 连线。你可以使用相关类，方法或字段声明的注解，将 bean 配置移动到组件类本身。<br>Spring 容器在默认情况下不打开注解连线，需在 Spring 配置文件中启用它：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Required</td>
<td align="left">适用于 bean 的 setter 方法，被注入的 bean 需在 xml 配置文件中配置，否则抛出 BeanInitializationException 异常</td>
</tr>
<tr>
<td align="left">@Autowired</td>
<td align="left">适用于 bean 的 setter 方法，非 setter 方法，构造函数和属性</td>
</tr>
<tr>
<td align="left">@Qualifier</td>
<td align="left">若有多个相同类型（指 class 相同，但 bean id 不同）的 bean，通过 @Qualifier 注解可指定确切的 bean，避免混乱</td>
</tr>
<tr>
<td align="left">JSR-250 Annotations</td>
<td align="left">基于 JSR-250 的注释，它包括 @PostConstruct， @PreDestroy 和 @Resource 三种</td>
</tr>
<tr>
<td align="left">@PostConstruct</td>
<td align="left">需和 xml 配置文件中的 <code>init-method</code> 搭配使用。指定一个方法，该方法在 bean 的实例化阶段会立即被调用</td>
</tr>
<tr>
<td align="left">@PreDestroy</td>
<td align="left">需和 xml 配置文件中的 <code>destroy-method</code> 搭配使用。指定一个方法，该方法在 bean 从容器中删除之前被调用</td>
</tr>
<tr>
<td align="left">基于 java 的注解</td>
<td align="left">包括 @Configuration、@Bean、@Import、@Scope，其中 @Configuration、@Bean 需搭配使用</td>
</tr>
<tr>
<td align="left">@Configuration</td>
<td align="left">被 @Configuration 注解的类表示可以使用 Spring IoC 容器作为 bean 定义的来源</td>
</tr>
<tr>
<td align="left">@Bean</td>
<td align="left">被 @Bean 注解的方法将返回一个 bean 对象，该 bean 被注册在 Spring 应用程序的上下文中。通过 initMethod/destroyMethod 参数支持指定任意的初始化和销毁的回调方法</td>
</tr>
<tr>
<td align="left">@Import</td>
<td align="left">允许从另一个配置类中加载 @Bean 定义</td>
</tr>
<tr>
<td align="left">@Scope</td>
<td align="left">指定 Bean 的范围。默认范围是单实例</td>
</tr>
</tbody></table>
<p>注解配置的加载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(HelloWorldConfig.class); </span><br><span class="line">   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);</span><br><span class="line">   helloWorld.setMessage(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   helloWorld.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP 是 Aspect Oriented Programming 的缩写，意思是：面向切面编程，它是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。<br>可以认为 AOP 是对 OOP（Object Oriented Programming 面向对象编程）的补充，主要使用在日志记录，性能统计，安全控制等场景，使用 AOP 可以使得业务逻辑各部分之间的耦合度降低，只专注于各自的业务逻辑实现，从而提高程序的可读性及维护性。<br>Spring AOP 模块提供拦截器来拦截一个应用程序。例如，当执行一个方法时，你可以在方法执行之前或之后添加额外的功能。</p>
<p><strong>开启 AOP</strong></p>
<ul>
<li>在 xml 配置文件中配置：<code>&lt;aop:aspectj-autoproxy/&gt;</code></li>
<li>需导入以下库文件：<ul>
<li>aspectjrt.jar</li>
<li>aspectjweaver.jar</li>
<li>aspectj.jar</li>
<li>aopalliance.jar</li>
</ul>
</li>
</ul>
<p><strong>切面（Aspect）</strong><br>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容：切点指定了程序何时进入切面，通知确定了程序在什么时候执行切面代码。<br>使用示例：定义一个切面类<br><code>@Aspect</code><br><code>public class MonitorAspect &#123;&#125;</code></p>
<p><strong>切点（Pointcut）</strong><br>切点是为了缩小切面所通知的连接点的范围，即切面在何处执行。我们通常使用明确的类和方法名称，或者利用正则表达式定义所匹配的类和方法名称来指定切点。<br>使用示例：定义一个切点，指定在注解 @ControllerMonitor 修饰的方法处进入切面<br><code>@Pointcut(&quot;@annotation(ControllerMonitor)&quot;)</code><br><code>public void pointCut() &#123;&#125;</code></p>
<p><strong>通知（Advice）</strong><br>在 AOP 术语中，切面要完成的工作被称为通知，通知定义了切面要做什么。<br>Spring 切面有 5 种类型的通知，分别是：</p>
<ul>
<li>环绕通知(Around)：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为（即在通知代码中调用了被通知方法）</li>
<li>前置通知(Before)：在目标方法被调用之前调用通知功能</li>
<li>后置通知(After)：在目标方法完成之后调用通知，此时不关心方法的输出结果是什么</li>
<li>返回通知(AfterReturning)：在目标方法成功执行之后调用通知</li>
<li>异常通知(AfterThrowing)：在目标方法抛出异常后调用通知</li>
</ul>
<p>使用示例：环绕被通知的方法<br><code>@Around(value = &quot;pointCut()&quot;)</code></p>
<p><strong>连接点（Join point）</strong><br>连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时、修改某个字段时。<br>即该连接点是进入通知函数的一个参数对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.SourceLocation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JoinPoint</span> </span>&#123;  </span><br><span class="line">   <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;         <span class="comment">//连接点所在位置的相关信息  </span></span><br><span class="line">   <span class="function">String <span class="title">toShortString</span><span class="params">()</span></span>;     <span class="comment">//连接点所在位置的简短相关信息  </span></span><br><span class="line">   <span class="function">String <span class="title">toLongString</span><span class="params">()</span></span>;     <span class="comment">//连接点所在位置的全部相关信息  </span></span><br><span class="line">   <span class="function">Object <span class="title">getThis</span><span class="params">()</span></span>;         <span class="comment">//返回 AOP 代理对象  </span></span><br><span class="line">   <span class="function">Object <span class="title">getTarget</span><span class="params">()</span></span>;       <span class="comment">//返回目标对象  </span></span><br><span class="line">   Object[] getArgs();       <span class="comment">//返回被通知方法参数列表  </span></span><br><span class="line">   <span class="function">Signature <span class="title">getSignature</span><span class="params">()</span></span>;  <span class="comment">//返回当前连接点签名  </span></span><br><span class="line">   <span class="function">SourceLocation <span class="title">getSourceLocation</span><span class="params">()</span></span>;   <span class="comment">//返回连接点方法所在类文件中的位置  </span></span><br><span class="line">   <span class="function">String <span class="title">getKind</span><span class="params">()</span></span>;        <span class="comment">//连接点类型  </span></span><br><span class="line">   <span class="function">StaticPart <span class="title">getStaticPart</span><span class="params">()</span></span>; <span class="comment">//返回连接点静态部分  </span></span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProceedingJoinPoint</span> <span class="keyword">extends</span> <span class="title">JoinPoint</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;               <span class="comment">//执行目标方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;  <span class="comment">//传入的新的参数去执行目标方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JoinPoint 对象<br>JoinPoint 对象封装了 SpringAop 中切面方法的信息，在切面方法中添加 JoinPoint 参数，就可以获取到封装了该方法信息的 JoinPoint 对象。</li>
<li>ProceedingJoinPoint 对象<br>ProceedingJoinPoint 对象是 JoinPoint 的子接口，该对象只用在 @Around 的切面方法中</li>
</ul>
<p>使用示例：环绕被通知的方法<br><code>@Around(value = &quot;pointCut()&quot;)</code><br><code>public Object handlingAround(ProceedingJoinPoint joinPoint) throws Throwable &#123;&#125;</code></p>
<hr>
<h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>Lambda 表达式，也可称为闭包。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>
<h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><p>lambda 表达式的语法格式如下：<code>(parameters) -&gt; expression</code>或<code>(parameters) -&gt;&#123; statements; &#125;</code>。<br><strong>举例：</strong></p>
<ul>
<li>不需要参数,返回值为 5：<code>() -&gt; 5</code></li>
<li>接收一个参数(数字类型)，返回其2倍的值：<code>x -&gt; 2 * x</code></li>
<li>接收 2 个参数(数字)，并返回他们的差值：<code>(x, y) -&gt; x – y</code></li>
<li>接收 2 个 int 型整数，返回他们的和：<code>(int x, int y) -&gt; x + y</code></li>
<li>接收一个 string 对象，并在控制台打印，不返回任何值(看起来像是返回void)：<code>(String s) -&gt; System.out.print(s)</code></li>
</ul>
<hr>
<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><ul>
<li>多个不同的类继承同一个类，各个子类对于父类的同一个对象名，实际拥有独立的对象。</li>
<li>try finally 之间有 return，即 try - return - finally，则它们的执行顺序是：进入 try，执行 return 后的表达式，然后执行 finally 中的语句，最后 return。</li>
<li>Google Guava 中 Joiner 的学习（<a target="_blank" rel="noopener" href="https://github.com/google/guava/wiki/StringsExplained#joiner">官方网站</a>）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过 null 值</span></span><br><span class="line">Joiner result = Joiner.on(<span class="string">&quot;; &quot;</span>).skipNulls().join(<span class="string">&quot;Harry&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;Ron&quot;</span>, <span class="string">&quot;Hermione&quot;</span>);</span><br><span class="line">Assert.assertEquals(result, <span class="string">&quot;Harry; Ron; Hermione&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换 null 值</span></span><br><span class="line">Joiner result = Joiner.on(<span class="string">&quot;; &quot;</span>).useForNull(<span class="string">&quot;Zou&quot;</span>).join(<span class="string">&quot;Harry&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;Ron&quot;</span>, <span class="string">&quot;Hermione&quot;</span>);</span><br><span class="line">Assert.assertEquals(result, <span class="string">&quot;Harry; Zou; Ron; Hermione&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用在对象上，会调用对象的 toString() 函数</span></span><br><span class="line">Joiner result = Joiner.on(<span class="string">&quot;,&quot;</span>).join(Arrays.asList(<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>));</span><br><span class="line">Assert.assertEquals(result, <span class="string">&quot;1,5,7&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MapJoiner 的使用，将 map 转换为字符串</span></span><br><span class="line">Map map = ImmutableMap.of(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">Joiner result = Joiner.on(<span class="string">&quot;; &quot;</span>).withKeyValueSeparator(<span class="string">&quot;=&quot;</span>).join(map);</span><br><span class="line">Assert.assertEquals(result, <span class="string">&quot;k1=v1; k2=v2&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>项目部署相关：<ul>
<li><a target="_blank" rel="noopener" href="https://www.wuquejs.cn/bt-javaweb-tomcat.html">使用宝塔面板部署JavaWeb项目的两种方法(war版)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/88b300c217c2?utm_campaign=haruki">IDEA部署项目到云服务器(未编译版)</a></li>
</ul>
</li>
<li>Java 测试：<ul>
<li>Mock：我们希望能在测试中，规避外部依赖的各种问题，专心测试单元逻辑，因此引入了mock。<br>在测试过程中，mock需要同时承担<strong>伪造输入依赖</strong>和<strong>验证输出依赖</strong>两方面职责。构造指定类虚拟的对象： <code>Mockito.mock(***.class)</code>。</li>
</ul>
</li>
<li>类初始化概念：类被加载之后，jvm 已经获得了一个描述类结构的 Class 实例。但是还需要进行类初始化操作之后才能正常使用此类，类初始化操作就是执行一遍类的静态语句，包括静态变量的声明还有静态代码块。</li>
<li>阅读源码：<ul>
<li>对于异常检测/特殊情况判断的 if 条件，可直接跳过</li>
</ul>
</li>
<li>深度优先遍历：化大为小，小处需有承接。</li>
<li>Scanner 相关：在 nextInt() 方法之后，会产生一个输入回车符待捕获，因此需要添加 nextLine()。</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/05/03/%E9%9D%A2%E8%AF%95/"><img class="prev-cover" src="/img/beijing.jpg" onerror="onerror=null;src='/img/touxiang.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">面试</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zourunxin"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">多总结！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Array"><span class="toc-text">Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-text">LinkedList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder-StringBuffer"><span class="toc-text">StringBuilder&#x2F;StringBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringJoiner"><span class="toc-text">StringJoiner</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-text">字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap"><span class="toc-text">TreeMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack"><span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue"><span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deque"><span class="toc-text">Deque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PriorityQueue"><span class="toc-text">PriorityQueue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-text">运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-text">算术运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E6%B3%A8%E8%A7%A3"><span class="toc-text">Java 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-text">标准元注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E6%B3%A8%E8%A7%A3"><span class="toc-text">Spring 注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%B5%8B%E8%AF%95%E6%B3%A8%E8%A7%A3"><span class="toc-text">Java 测试注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lombok-%E6%B3%A8%E8%A7%A3"><span class="toc-text">lombok 注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-text">注解开发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%8F%8D%E5%B0%84"><span class="toc-text">Java 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Class-%E7%B1%BB"><span class="toc-text">Class 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Class-%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">获取 Class 对象（三种方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Class 对象的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">成员变量常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-text">Class 的一些使用技巧</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">Java 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolTaskExecutor"><span class="toc-text">ThreadPoolTaskExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-text">配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-text">拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-text">提交任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">关闭线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%B8%AA%E6%95%B0"><span class="toc-text">配置线程个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-text">监控线程池状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">基于构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%AE%BE%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-text">基于设值函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E5%86%85%E9%83%A8-beans"><span class="toc-text">注入内部 beans</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Beans-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-text">Beans 自动装配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">基于注解的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP"><span class="toc-text">AOP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-text">语法格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-text">基本知识</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/01/26/%E9%87%91%E8%9E%8D%E6%9C%AF%E8%AF%AD/" title="金融术语">金融术语</a><time datetime="2022-01-26T05:47:08.000Z" title="Created 2022-01-26 13:47:08">2022-01-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/25/%E5%B7%A5%E5%85%B7%E7%B1%BB/" title="工具类">工具类</a><time datetime="2021-10-25T04:13:44.000Z" title="Created 2021-10-25 12:13:44">2021-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/03/%E9%9D%A2%E8%AF%95/" title="面试">面试</a><time datetime="2021-05-03T07:37:48.000Z" title="Created 2021-05-03 15:37:48">2021-05-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/02/05/Java/" title="Java">Java</a><time datetime="2021-02-05T13:10:50.000Z" title="Created 2021-02-05 21:10:50">2021-02-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div></div></body></html>