<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面试问一句答一句，不要自顾自答Leetcode一般 字符串个数统计相关：无论字符串是数字 or 字符形式，统计方式可利用一维数组统计各字符出现次数。 数字：int[10]，cnt[c - ‘0’]++； 小写字母：int[26]，cnt[c - ‘97’]（97 - 122）； 大写字母：int[26]，cnt[c - ‘65’]（65 - 90）；    递归（dfs）看见树一般都是递归，可能还">
<meta property="og:type" content="article">
<meta property="og:title" content="面试">
<meta property="og:url" content="http://example.com/2021/05/03/%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="面试问一句答一句，不要自顾自答Leetcode一般 字符串个数统计相关：无论字符串是数字 or 字符形式，统计方式可利用一维数组统计各字符出现次数。 数字：int[10]，cnt[c - ‘0’]++； 小写字母：int[26]，cnt[c - ‘97’]（97 - 122）； 大写字母：int[26]，cnt[c - ‘65’]（65 - 90）；    递归（dfs）看见树一般都是递归，可能还">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/beijing.jpg">
<meta property="article:published_time" content="2021-05-03T07:37:48.000Z">
<meta property="article:modified_time" content="2022-03-12T11:17:15.332Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/beijing.jpg"><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://example.com/2021/05/03/%E9%9D%A2%E8%AF%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-12 19:17:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/beijing.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-05-03T07:37:48.000Z" title="Created 2021-05-03 15:37:48">2021-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-03-12T11:17:15.332Z" title="Updated 2022-03-12 19:17:15">2022-03-12</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面试问一句答一句，不要自顾自答"><a href="#面试问一句答一句，不要自顾自答" class="headerlink" title="面试问一句答一句，不要自顾自答"></a>面试问一句答一句，不要自顾自答</h1><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h2><ul>
<li>字符串个数统计相关：无论字符串是数字 or 字符形式，统计方式可利用一维数组统计各字符出现次数。<ul>
<li>数字：int[10]，cnt[c - ‘0’]++；</li>
<li>小写字母：int[26]，cnt[c - ‘97’]（97 - 122）；</li>
<li>大写字母：int[26]，cnt[c - ‘65’]（65 - 90）；</li>
</ul>
</li>
</ul>
<h2 id="递归（dfs）"><a href="#递归（dfs）" class="headerlink" title="递归（dfs）"></a>递归（dfs）</h2><p><strong>看见树一般都是递归，可能还会用到回溯</strong></p>
<ul>
<li>实现方式：深度优先遍历，隐式使用了栈。对于树而言，有三种实现方式：先序/中序/后序遍历。</li>
<li>本质是遍历结点，多应用于树和图类的数据结构。如，可用于遍历树结点或构造树：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化</a><br>有两种回溯处理方式：<ul>
<li>递归利用回溯：即当前层的处理结果依赖下面层的处理返回结果，递归方法需有返回值；一般递归语句后有其他处理逻辑。（可利用记忆化）</li>
<li>递归不利用回溯：即当前层的处理结果不依赖下面层的处理返回结果，仅与该层及前面层有关；一般递归语句后无其他处理逻辑。</li>
</ul>
</li>
<li>需注意：<ul>
<li>递归函数的参数建议是中间值；</li>
<li>不变的变量用作全局变量，不要作为参数使用。</li>
</ul>
</li>
</ul>
<h2 id="回溯（backTrack）"><a href="#回溯（backTrack）" class="headerlink" title="回溯（backTrack）"></a>回溯（backTrack）</h2><ul>
<li>实现方式：在循环体里进行递归。</li>
<li>本质：循环的作用是枚举所有情况；递归的作用是若某种结果不符合题解要求，则回溯，若符合题解要求，则立即返回。</li>
<li>回溯的本质是利用循环 + 递归枚举所有可能的情况。</li>
<li>记忆化：回溯的当前层的状态与未来层的状态关联，与过去层的状态无关。因此若当前层状态计算得到，则可存储以记忆，此后再来到当前层，则可直接返回。</li>
</ul>
<p><strong>回溯与动态规划的不同之处在于，回溯需要更换前面已经确定的值</strong></p>
<h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><ul>
<li>实现方式：将每一层次遍历的结点存入队列中，在访问时取出来。循环 + 队列实现。</li>
<li>本质是遍历结点，多应用于树和图类的数据结构。</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul>
<li>实现方式：通过数组记录各个状态的值，当前状态的值与前面的某一个/两个状态的值相关<strong>（后面一句话也可以理解为，当前状态的值会影响若干未来状态的值，也可在遍历到当前状态时，不断更新未来状态的值实现动态规划）</strong>；</li>
<li>若是当前状态的值由过去若干状态的值计算得到，则其特点是：<ul>
<li>一个子问题求解得到结果后，以后的计算过程就不会修改它，只会使用它；</li>
<li>只解决每个子问题一次。</li>
</ul>
</li>
<li>若当前状态的值用于计算得到未来若干状态的一部分值，则其特定是：<ul>
<li>可能需要多个状态的值综合计算才能得到未来某个状态的值；（即若是二维数组，则每次更新，可为更新某片区域的值，而不是（固有想法式的）更新某个值。）；</li>
</ul>
</li>
<li>使用动态规划 dp 数组时，若是由前一状态计算得到当前状态，则可多分配一行一列空间给数组，可省略越界判断。</li>
<li>对于需要使用两次动态规划的题目（如求两次不同路径的最大求和），则可有两种解法：<ol>
<li>若数据量较小，则使用四维 dp 数组，使用四重循环。dp[i][j][k][l] 表示到达在第 (i,j)、(k,l) 两个点的路径的最大求和。</li>
<li>若想优化，则使用三维 dp 数组，使用三重循环。dp[k][i][j] 表示步长为 k 时，到达第 (i,k-i+1)、(j,k-j+1) 两个点的路径的最大求和。</li>
</ol>
</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><ul>
<li>流程：<ul>
<li>需要两个指针：pre、cur；</li>
<li>初始值：pre = null、cur = head；</li>
<li><code>while(cur != null)</code>，循环体里需记录 cur 的 next listnode。</li>
<li><code>return pre;</code></li>
</ul>
</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>若想找窗口内元素最小值，并保留该最小值，窗口移动并继续找最小值，实现方法可用栈。</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>多用递归、回溯、和广度优先遍历。</p>
<ul>
<li>一些性质：<ul>
<li>完全二叉树：第 k 层最多有 2 ^ (k - 1) 个结点，该树最多有 2 ^ k - 1 个结点。</li>
</ul>
</li>
<li>后序遍历：类似回溯，当前结点仅与左右子孩子的值相关。若回溯过程发现返回一个值不够，应当考虑返回两个值（组成一个数组）。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">打家劫舍 III</a></li>
<li>若树结点含标号，且标号各不相同，则可使用数组来存储。其中，数组下标为树结点标号，元素值为树根节点到标号结点的路径长度。对于计算路径长度相关的题极有帮助。<code>nodes[y] = nodes[x] + val;</code>，其中 y 为当前标号结点，x 为 y 的父节点，val 为从 x 到 y 的路径值大小。</li>
</ul>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul>
<li>存储方式：二维数组和链表</li>
<li>二维数组存储：<ul>
<li>普通数组 int 存储：遍历时需对周边结点判断是否存在边及越界；</li>
<li>ArrayList 实现的数组：遍历时循环元素即可。</li>
</ul>
</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul>
<li>实现方式：定义左边界和右边界，循环 <code>while(left &lt; right&gt;</code>，在循环体里计算 mid，再进行元素比较。</li>
<li>若需要在循环结束后保留 mid 的值，则在比较元素时可设置 <code>right = mid, left = mid + 1</code>。</li>
</ul>
<p><strong>延伸</strong><br>对两个有序数组二分查找它们的中位数，在不能合并数组的情况下，对 k (k = (n1 + n2) / 2) 进行二分。n1、n2 分别是两个数组的长度。<br>即上面的问题可转化为查找两个数组所有元素的第 k 大元素，流程：</p>
<ol>
<li>初始 <code>idx1, idx2 = 0;</code>，分别是两个数组的初始指针；</li>
<li><code>half = k / 2;</code>并更新 <code>mid1 = idx1 + half - 1;</code> 和 mid2；</li>
<li>对比 nums1[mid1] 和 nums2[mid2]，缩小 k 值，更新 idx1 或 idx2；</li>
<li>直至其中一个数组元素遍历完或 k == 1，即可返回中位数。</li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul>
<li>流程：<ol>
<li>选首元素作为待排序元素，后面的所有元素与首元素一一比较。</li>
<li>left 指针为首元素后一位，right 指针为最后一位元素。</li>
<li>循环 <code>while(left &lt; right)</code>。</li>
<li>right 元素与首元素比较。若大于等于，right 指针左移；否则指针停止。</li>
<li>left 元素与首元素比较。若小于，left 指针右移；否则指针停止。</li>
<li>交换 left 和 right 指针位置的元素。</li>
<li>直到跳出循环，比较首元素与 right 元素大小，若小于等于，则交换首元素和 right - 1 元素；否则交换首元素和 right 元素。此时首元素位置确定。</li>
<li>分治 1 - 6。</li>
</ol>
</li>
</ul>
<h3 id="无序数组计算最长递增子序列长度（不要求连续）"><a href="#无序数组计算最长递增子序列长度（不要求连续）" class="headerlink" title="无序数组计算最长递增子序列长度（不要求连续）"></a>无序数组计算最长递增子序列长度（不要求连续）</h3><ul>
<li>流程：<ol>
<li>新建 <code>int[] dp</code> 数组，大小与无序数组大小相同；</li>
<li>遍历无序数组元素，使用二分查找定位 dp 数组替换该元素的位置，替换该元素；</li>
<li>若元素比 dp 数组的最右侧元素（最大值）要大，则新增成为 dp 数组最大元素值（dp 数组最右侧）；</li>
<li>无序数组遍历结束后，dp 数组元素个数即为该无序数组最长递增子序列长度。<br>补充：dp 数组为遍历无序数组过程中构建的有序数组。整个过程时间复杂度 O(nlogn)，也用到了贪心算法的思想。</li>
</ol>
</li>
</ul>
<h2 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h2><h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><p>假设有 N 个物品，每个物品有重量和价值两个属性，其中第 i 个物品的重量为 w[i]，价值为 v[i]。张三现在有一个可装 W 重量物品的背包，问如何才能实现价值最大化？<br>一般解决一种问题：该问题似乎通过对 价值/重量 排序，然后从大到小取物品即可。但是，在边界上，细节非常多，所以这道题，看起来这么解可以。但实际上，仍需使用动态规划。<br>通用是使用二维 dp 数组，但一维空间复杂度更好，为 O(W)。时间复杂度只能为 O(NW)。理论上，计算得到的 dp 数组必须有序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= w[i]; j--) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[W];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>计算数组中满足某条件的所有子窗口的个数。<br>使用双指针标记窗口左边界和有边界，窗口内状态的记录（如各元素出现的次数）通过新数组（若给定数组元素有范围）或 Map 保存。优先移动右指针，若窗口满足所需条件，开始统计计算并移动左指针。</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集的最终形态是，每个集合都是一棵树。</p>
<ul>
<li>核心组成：<ul>
<li>标记父子关系的数组 <code>int[] parent</code>（若数据范围有区间）或 map；</li>
<li>初始化 <code>init()</code> 方法，用于初始化数组（或 map）；</li>
<li><code>union()</code> 方法，用于联结两个存在关系的结点或树（本质是联结根节点），使用 <code>father[x] = y</code>。在此处要处理，两个树之间的联结逻辑（谁做谁的父节点）；</li>
<li><code>getRoot</code> 方法，找到要联结结点的根节点。</li>
</ul>
</li>
</ul>
<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p><strong><a target="_blank" rel="noopener" href="https://www.nowcoder.com/question/next?pid=30440638&qid=1664953&tid=53022867">两个序列</a></strong><br>虽然给的是两个数组的比较，但解法类似。<br>如题目要求：存在两个数组，所有元素和个数均相同，但顺序可能不同，问最少经过多少次操作后 ａ 数组和 b 完全相同（操作限于在 a 数组两端元素取出并插入任一位置，cost 为 1）。<br>该题可转化为，根据 a 数组元素值在 b 数组中的位置，更新元素值为 b 数组的索引。即若 <code>a[i] = b[j]; a[i] = j;</code>，如此，可通过求 a 数组中最长连续递增子序列的长度，通过 n - 长度即为编辑距离（n 为 a 数组元素个数）。</p>
<p><strong><a target="_blank" rel="noopener" href="https://www.nowcoder.com/question/next?pid=30579184&qid=1712511&tid=53354990">多多的字符变换</a></strong><br>题目：有两个字符串，可进行如下两种操作：1. 交换任意两个相邻的字符，代价为 0；2. 将任意一个字符 a 修改成字符 b，代价为 |a - b|（绝对值）。问最少经过多少代价可使 a 和 b 字符串相同。<br>解：因为交换任意两个相邻字符 cost 为 0，则可对两个字符串排序，再一一比较，不相同便计算 cost，累加的 cost 值即为编辑距离。</p>
<h3 id="通过概率求-Pi"><a href="#通过概率求-Pi" class="headerlink" title="通过概率求 Pi"></a>通过概率求 Pi</h3><p>在一个半径为 1 的 1/4 圆上，通过随机数 <code>Random random = new Random(); a = random.nextDouble(); b = random.nextDouble();</code> 获得 a、b，若 <code>a^2 + b^2 &lt; 1</code>，说明该点在园内，统计指标 <code>count++</code>。最后，根据 <code>4 * count / N</code> 计算得到 Pi 的近似值。其中 N 是循环求随机数的次数，越大越好。</p>
<h3 id="高精度法"><a href="#高精度法" class="headerlink" title="高精度法"></a>高精度法</h3><p>有高精乘和高精加两种。以高精加为例：<br>若一系列数相加得到的结果很大，大于计算机所能存储的数值类型，则在相加过程中，使用列表表示该数。列表中的每个元素是该数的其中一位（从左到右增大），对于加法，对应位相加，记录进位的值；对于乘法，乘数乘以每一位，记录进位的值。最终更新列表，把该列表的元素取出来转化成字符串，并逆转，即为所求的数。</p>
<h3 id="柱状图中最大矩形"><a href="#柱状图中最大矩形" class="headerlink" title="柱状图中最大矩形"></a>柱状图中最大矩形</h3><p>一个一维数组，数组中每个元素表示一个高为元素值，宽为 1 的矩形，两两元素形成的矩形相贴近。求该一维数组形成的柱状图中，能形成的最大矩形的面积。<br>若使用两重循环，根据每个元素找最大宽计算矩形面积，则会超时；<br>故使用两个数组 <code>int[] left, right;</code>，分别记录下标为 i 的元素所能到达的最左边界和最右边界（能到达的意思是边界处的元素比 i 处的元素值要小），则 i 处元素所能构成的最大矩形的面积为 (右边界 - 左边界) * i 处元素值。left 和 right 数组的构造分别通过从左至右的元素遍历和从右至左的元素遍历的单调递增栈完成。</p>
<h3 id="数组中找出区间和与-M-整除的区间个数"><a href="#数组中找出区间和与-M-整除的区间个数" class="headerlink" title="数组中找出区间和与 M 整除的区间个数"></a>数组中找出区间和与 M 整除的区间个数</h3><ol>
<li>构造数组的前缀和；</li>
<li>构造前缀和 % M 数组：<code>int[] map = new int[M];</code></li>
<li>计算前缀和取余后的值 x，区间总和 += map[x]；</li>
<li><code>map[x]++;</code></li>
</ol>
<h3 id="蓄水池算法"><a href="#蓄水池算法" class="headerlink" title="蓄水池算法"></a>蓄水池算法</h3><blockquote>
<p>一种采样算法</p>
</blockquote>
<p>在不知道数据规模的情况下，要求等概率的获取某元素。<br>如，已知一个数组必存在一个最大值（未知），该最大值在数组中出现次数为 1 次或多次。求问如何在一次遍历（时间复杂度 O(n)），空间复杂度 O(1) 的条件下等概率输出该最大值的任一下标。<br>维护数组最大值变量，每次发现该最大值时，以 1 / 最大值个数的概率更新下标；若发现了更大的值，则更新最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 蓄水池采样;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[index]) &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[index]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (random.nextDouble() &lt; <span class="number">1</span> / count)</span><br><span class="line">                    index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li><code>Scanner sc = new Scanner(System.in);</code>：获取输入捕获器；</li>
<li><code>sc.nextInt();</code>：获取终端输入的整数，以空格或回车作为结束；（该方法不会捕获空格/回车）</li>
<li><code>sc.nextLine();</code>：获取终端输入的一行字符串，以回车（换行）作为结束；</li>
<li><code>Random random = new Random(); random.nextDouble();</code>：获取 0 - 1 的随机数（double 类型）</li>
<li>一个数取模一次和取模 n 次得到的结果相同。取模适用结合律（先加再模亦或先模再加结果相同）</li>
<li>赋值运算符 <code>=</code> 的优先级没有三元运算符 <code>?:</code> 高；</li>
<li>遇到 x / y = a / b 的等式时，有两种解决办法：<ol>
<li>令 a / b = t，则 x / y = t；</li>
<li>令 x / y = (a * unit) / (b * unit)。则 x = a * unit，y = b * unit。</li>
</ol>
</li>
<li>求 a 和 b 的最大公约数：令 <code>a, b = b, a % b;</code>。</li>
<li>若有一数列 <code>int[] nums</code>，则该数列的中位数满足如下性质：要求找到任一整数 x，该数满足 <code>nums[i] - x</code> 的和为最小。</li>
<li><strong>求和求积注意数据越界。（使用 long 最保险）</strong></li>
<li>long = long + int，无报错，且只要 int 的数据无越界，则 long + int 后不会导致越界。</li>
<li>要形成一种思维，如果算法一般形式（如动态规划）无法解决问题，应当扩充使用空间的大小，把状态都存起来。二维 - 三维都是可以接受的。</li>
<li>看到回溯可解时不要害怕超出时间复杂度，可使用记忆化。</li>
<li>求最长非递减子序列时，要判断是否要求子序列连续。若要求，则是 O(n) 时间复杂度；若不要求，则是 O(n2) 时间复杂度（使用动态规划）。</li>
<li>计算矩阵中最大矩形面积时，使用二维数组存储所有点的左侧最大矩形长度。再遍历所有点，结合上侧点的左侧最大矩形长度和能到达的最大宽度，计算矩形面积。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-rectangle/">最大矩形</a></li>
<li>若终端输入可能含 long 类型，则必须 <code>long num = sc.nextLong();</code>，若使用 <code>sc.nextInt()</code>，则会报错。</li>
<li>输出后若想结束任务，可使用 return。</li>
<li>面对小数，若想仅保留一位小数，则对小数取整，可得到整数；对小数乘 10 再 %10，可得小数点后第一位小数，拼接即为一位小数。</li>
<li>类型转化和运算符同在时，类型转换优先级高，因此需对运算符公式加括号。</li>
<li>在乘法中，若想积出现 0，则乘数必须含 2 和 5 的质因数。2 和 5 的成对数决定 0 的个数。</li>
</ul>
<hr>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.html#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">CS-Notes-网络基础</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/o960w7/">校招基础知识讲解</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ekz8lr/">计算机网络面试突击</a></p>
</blockquote>
<h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><p><strong>基本知识</strong></p>
<ul>
<li>路由选择协议；</li>
<li>TCP 连接三次握手过程，及为什么；</li>
<li>TCP 断连四次挥手过程，及为什么；</li>
<li>TCP 粘包问题及解决方法；</li>
</ul>
<p><strong>详细</strong></p>
<ul>
<li>ipv4 和 ipv6 的区别<ul>
<li>地址长度：ipv4 的地址长度为 32 位（4bytes），ipv6 的地址长度为 128 位（16bytes）</li>
<li>地址表示：ipv4 地址用小数表示，ipv6 地址用十六进制表示</li>
<li>包头大小：ipv4 包头的基本大小是 20bytes（可扩展 40bytes），ipv6 是 40bytes</li>
<li>安全性：ipv6 内置了 IPsec，提供身份验证和加密。但在 ipv4 中是可选的，如果在适当的 IPv4 选项格式中实现 AH 和 ESP 头，IPv4 也可以使用这种安全性功能</li>
</ul>
</li>
<li>TCP 基本概念<ul>
<li>通过超时重传保证数据可靠传输。</li>
<li>发送窗口大小 = 由接收方返回的窗口大小和发送方自己维护的拥塞窗口大小共同确定。</li>
<li>流量控制：接收方控制发送方发送数据的频率的方法，可通过在确认报文段中的窗口大小来控制。</li>
<li>拥塞控制：发送方在遇到网络拥塞时的应对算法。<ul>
<li>慢开始：cwnd = 1，每次确认 cwnd 翻倍。</li>
<li>拥塞避免：当 cwnd &gt;= ssthresh 时进入，每次确认 cwnd 加 1。</li>
</ul>
  <strong>此时若出现超时，则 ssthresh = cwnd/2，并重新执行慢开始</strong><ul>
<li>快重传：发送方收到对某个字节连续三次的确认。</li>
<li>快恢复：ssthresh = cwnd/2，cwnd = ssthresh。</li>
</ul>
  <strong>若发送方发现了快重传现象，则执行快恢复</strong></li>
</ul>
</li>
<li>TCP 半连接队列和全连接队列<ul>
<li>半连接队列：也称 SYN 队列，客户端发来 SYN 连接请求时，服务端会把该连接存储到半连接队列</li>
<li>全连接队列：也称 accept 队列，第三次握手时服务端接收到客户端发来的 ACK 后，内核会将半连接移除，然后创建全新的连接，将其添加到 accept 队列。    </li>
</ul>
  <strong>TCP/IP协议中，listen()、connect()和accept()函数和三次握手间的关系</strong><ul>
<li>服务器调用 listen 监听特定端口号</li>
<li>客户端调用 connect 来请求与服务端通过三次握手建立 TCP 连接</li>
<li>服务器的 listen() 函数负责三次握手的交互过程。连接建立后，往 accept 队列中添加一个成功的连接。</li>
<li>服务器调用 accept() 从 accept 队列中取出一条成功的 tcp 连接</li>
</ul>
</li>
<li>TCP 四次挥手过程中的 CLOSED_WAIT 和 TIME_WAIT：<br> 服务器在收到客户端发送的 FIN 报文并回答了 ACK 报文后，会进入 CLOSED_WAIT 状态，以保证服务器在关闭连接之前将待发送的数据发送完成。<br> 客户端在收到服务器发送的 FIN 报文并回答了 ACK 报文后，会进入 TIME_WAIT 状态。TIME_WAIT 本质是一个 2MSL 的计时器，MSL（Maximum Segment Lifetime）指一段 TCP 报文在传输过程中的最大生命周期。2MSL 是为了确保服务器已经收到了客户端发送的 ACK 确认报文。<br> TIME_WAIT 状态可能导致的问题：在高并发短连接的业务场景中，服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的处在 TIME_WAIT 状态的连接，服务器维护每个连接都需要一个 socket。也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。<br> 解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80_1.png" class=""></li>
<li>TCP 攻击<ul>
<li>Flood 攻击：如发送海量的 SYN 报文，请求连接而又不建立连接<strong>（三次握手建立 TCP 连接的缺点）</strong>；</li>
<li>连接耗尽攻击：TCP 三次握手建立连接后不再发送报文但一直维持连接，消耗 TCP 连接资源</li>
</ul>
  <strong>如何防范 SYN 泛洪攻击</strong><ul>
<li>降低 SYN timeout，使主机尽快释放半连接及其占用的资源；</li>
<li>设置 SYN cookie，如果短时间内收到了某个 IP 的重复 SYN 请求，我们就可以认为受到了攻击</li>
</ul>
</li>
<li>UDP 如何保证可靠性<ul>
<li>有序性：添加序列号</li>
<li>丢包：确认和超时重传</li>
<li>协议字段：标识当前使用的协议</li>
</ul>
</li>
<li>TCP 和 UDP 的区别<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/3.png" class="">
<ul>
<li>TCP 保证可靠交付（序列号和确认、超时重传、流量控制、拥塞控制），UDP 尽最大努力交付，可靠性由应用层保证</li>
<li>TCP 仅支持一对一通信，UDP 支持一对一、一对多、多对一和多对多通信</li>
</ul>
</li>
<li>DNS 过程（由域名找 ip）<ul>
<li>在浏览器中输入域名后，浏览器首先检查缓存中是否有该域名解析过的ip地址，若有，解析结束</li>
<li>若没有，浏览器会到操作系统缓存中（即hosts文件）查看是否有该域名对应的ip地址，若命中，解析结束；</li>
<li>若没有找到，就会请求本地域名服务器来解析，一般情况下解析到这步就完成了</li>
<li>若还没有，本地域名服务器则会迭代查询（一般情况下）根域名服务器，顶级域名服务器和权限域名服务器，找到目标ip，缓存和返回给用户，解析结束</li>
</ul>
</li>
<li>DNS 污染、DNS 劫持<ul>
<li>DNS 污染：指的是用户访问一个地址，国内的服务器(非 DNS)监控到用户访问的已经被标记地址时，服务器伪装成 DNS 服务器向用户发回错误的地址的行为。范例，访问 Youtube、Facebook 之类网站等出现的状况。</li>
<li>DNS 劫持：就是指用户访问一个被标记的地址时，DNS 服务器故意将此地址指向一个错误的 IP 地址的行为。</li>
</ul>
</li>
<li>数字证书的内容<ul>
<li>证书的版本信息；</li>
<li>证书的序列号，每个证书都有一个唯一的证书序列号；</li>
<li>证书所使用的签名算法；</li>
<li>证书的发行机构名称，命名规则一般采用X.500格式；</li>
<li>证书的有效期，通用的证书一般采用UTC时间格式；</li>
<li>证书所有人的名称，命名规则一般采用X.500格式；</li>
<li>证书所有人的公开密钥；</li>
<li>证书发行者对证书的签名。</li>
</ul>
</li>
<li>TLS 握手详细过程<ul>
<li>“client hello” 消息：客户端通过发送 “client hello” 消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个 “client random” 随机字符串。</li>
<li>“server hello” 消息：服务器发送 “server hello” 消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和 “server random” 随机字符串。</li>
<li>验证：客户端对服务器发来的证书进行验证，确保对方的合法身份。</li>
<li>“premaster secret”字符串：客户端向服务器发送另一个随机字符串”premaster secret (预主密钥)”，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。</li>
<li>使用私钥：服务器使用私钥解密”premaster secret”。</li>
<li>生成共享密钥：客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 KEY。</li>
<li>客户端就绪：客户端发送经过共享密钥 KEY加密过的”finished”信号。</li>
<li>服务器就绪：服务器发送经过共享密钥 KEY加密过的”finished”信号。</li>
<li>达成安全通信：握手完成，双方使用对称加密进行安全通信。</li>
</ul>
</li>
<li>OSI七层网络模型和各层协议<ul>
<li>应用层：通过应用程序间的交互来完成特定的网络应用。有 DNS 协议、HTTP 协议、DHCP 协议、FTP 协议、SMTP、POP3、IMAP 协议</li>
<li>表示层：使通信的应用程序能够解释交换数据的含义。（编码和解码）</li>
<li>会话层：负责建立、管理和终止表示层实体之间的通信会话。</li>
<li>传输层：为两台主机进程之间的通信提供服务。有 TCP、UDP 协议</li>
<li>网络层：选择合适的网间路由和交换节点，确保数据按时成功传送。有 IP 协议、ICMP 协议</li>
<li>数据链路层：将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。有 CSMA/CD 协议、ARP 协议（ARP 缓存表存在内存里）、PPP 协议</li>
<li>物理层：实现计算机节点之间比特流的透明传送    </li>
</ul>
  <strong>OSI 七层网络模型和 TCP/IP 网络模型</strong><img src="/2021/05/03/%E9%9D%A2%E8%AF%95/7.jpg" class=""></li>
<li>四层负载均衡和七层负载均衡<br> 四层负载均衡：是通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器与请求客户端建立TCP连接，然后发送Client请求的数据。<br> 七层负载均衡：也称内容交换，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的服务器。七层负载均衡服务器起了一个代理服务器的作用<br> <strong>区别：</strong><ul>
<li>四层负载服务器不需要和客户端建立TCP连接，但七层负载服务器需要，并起到了代理服务器的作用。</li>
<li>七层负载服务器可以有效防止SYN Flood攻击，使网站更安全</li>
<li>七层负载服务器使整个网络更“智能化”，能把对图片类的请求转发到图片服务器并可以使用缓存技术，对文字的请求转发到文字服务器并可以使用压缩技术</li>
</ul>
</li>
<li>客户端和服务器是如何建立连接的<br> 通过 socket。socket 作为一种通信机制，可用于对 ip 地址和端口号进行描述。一般过程大概如下：服务端至少两个 socket，其中一个用于接受客户端发来的连接请求，并不负责与客户端通信。每当服务器成功接受客户端的请求时，在服务器端会创建一个与客户端进行通信的 socket。在客户端，通过创建一个 socket 对象对 TCP 连接初始化</li>
<li>客户端最多与服务器同时建立多少个 TCP 连接<br>  <strong>背景：</strong>网络通信过程中服务端监听一个固定的端口,客户端主动发起连接请求后要经过三次握手才能与服务器建立起一个 tcp 连接    <ul>
<li>客户端每次发起一个 tcp 连接时,系统会随机选取一个空闲的端口,该端口是独占的不能与其他 tcp 连接共享,因此理论上一台机器有多少空闲的端口,就能对外发起多少个 tcp 连接</li>
<li>根据 tcp/ip 协议,端口 port 使用16位无符号整数 unsigned short 来存储,因此本地端口一共有 2^16=65536 个,即 0-65535,其中 0~1023 是预留端口,0有特殊含义不能使用,1024以下端口都是超级管理员用户(如 root)才可以使用，因此就算使用 root 权限，一台机器最多能使用的端口也只有 65535 个。</li>
<li>但实际上 linux 限制了可使用端口号区间为 [32768, 60999]，即实际对外可建立的连接默认最大只有 28232 个</li>
</ul>
  <strong>服务端最多可建立连接数</strong><ul>
<li>因为受服务器资源、操作系统的限制，linux 内核默认文件描述符最大值是 1024，也就是说默认支持最大并发连接是 1024 个。</li>
</ul>
</li>
<li>Unicode 和 UTF-8 有何区别<ul>
<li>Unicode 是「字符集」，UTF-8 是「编码规则」；</li>
<li>广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和 UTF-8、UTF-16、UTF-32 等编码规则。    </li>
</ul>
  <strong>其中</strong><ol>
<li>字符集：为每一个「字符」分配一个唯一的 ID（学名为码位/码点/Code Point）</li>
<li>编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）</li>
</ol>
</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#%E4%B8%80-%E3%80%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">CS-Notes-HTTP</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/">计算机网络面试突击</a></p>
</blockquote>
<p><strong>基本知识</strong></p>
<ul>
<li>http 的九种请求方法</li>
<li>http 五类状态码和 9 个状态码</li>
<li>cookie 和 session 的对比（三点）</li>
<li>https 的优点（http 的缺点）、缺点；</li>
<li>http1.1 的新特性，http2.0 的新特性</li>
<li>get 和 post 方法的对比（六种）</li>
<li>HTTP/3</li>
</ul>
<p><strong>详细</strong></p>
<ul>
<li><p>HTTP 报文组成：</p>
<ul>
<li>请求报文：请求行、请求头、空行、请求体；</li>
<li>响应报文：响应行、响应头、空行、响应体。</li>
</ul>
</li>
<li><p>HTTP 请求完整过程</p>
<ul>
<li>根据域名和 DNS 解析到服务器的IP地址 (DNS + CDN)</li>
<li>通过 ARP 协议获得 IP 地址对应的物理机器的 MAC 地址</li>
<li>浏览器对服务器发起 TCP 3 次握手</li>
<li>建立 TCP 连接后发起 HTTP 请求报文</li>
<li>服务器响应 HTTP 请求，将响应报文返回给浏览器</li>
<li>短连接情况下，请求结束则通过 TCP 四次挥手关闭连接。长连接在没有访问服务器的若干时间后，进行连接的关闭；</li>
<li>浏览器得到响应信息中的 HTML 代码， 并请求 HTML 代码中的资源（如 js、css、图片等）</li>
<li>浏览器对页面进行渲染并呈现给用户</li>
</ul>
<p>  <strong>HTTPS 请求过程在 TCP 和 HTTP 之间增加了 SSL 协议</strong></p>
</li>
<li><p>HTTPs<br> HTTPs 是以安全为目标的 HTTP 通道，在 http 的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPs 在 HTTP 的基础下加入 SSL/TLS 协议。<br> <strong>加密算法：</strong></p>
<ul>
<li>对称加密算法</li>
<li>非对称加密算法</li>
<li>哈希算法</li>
</ul>
</li>
<li><p>HTTP/1.1</p>
<ul>
<li>长连接：指 TCP 的长连接。HTTP 在一次数据传输结束后不会立马断开 TCP 连接，而是保留一段时间，期间若有新的 HTTP 请求，则复用该 TCP 连接。服务端可通过请求头来设置长连接保持的时间，若在大于设置时间里没有 HTTP 请求，则服务端发送 FIN 报文主动断开 TCP 连接。</li>
<li>流水线：指客户端在同一条长连接上连续发出请求，而不用等待响应返回的技术，以减少延迟。但目前浏览器基本没有默认启用。</li>
</ul>
</li>
<li><p>HTTP/2.0</p>
<ul>
<li>HTTP/1.x 的缺陷<ul>
<li>客户端需要使用多个连接才能实现并发和缩短延迟；</li>
<li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li>
<li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li>
</ul>
</li>
<li>二进制分帧层：通过帧和流，帧标识该帧属于哪个流，来避免 HTTP/1.x 的线头阻塞问题。<ul>
<li>线头阻塞问题：HTTP 响应的顺序必须为 HTTP 请求的顺序，若 HTTP 某响应报文阻塞，而后续响应报文完成却不能发送，即为线头阻塞问题。</li>
</ul>
</li>
<li>服务端推送：HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求。</li>
<li>首部压缩：通信双方各自缓存一份头部字段表。在 HTTP 报文头中，每次仅发送改变了的头部字段。</li>
</ul>
</li>
<li><p>HTTP/3</p>
<ul>
<li>HTTP/3 是在 QUIC 基础上发展起来的，其底层使用 UDP 进行数据传输，上层仍然使用 HTTP/2。在 UDP 与 HTTP/2 之间存在一个 QUIC 层，其中 TLS 加密过程在该层进行处理。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">CS-Notes</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/o9kvv5/">校招基础知识详解</a></p>
</blockquote>
<h2 id="一般系统"><a href="#一般系统" class="headerlink" title="一般系统"></a>一般系统</h2><p><strong>基本知识</strong></p>
<ul>
<li>进程的六种调度算法</li>
<li>进程同步</li>
<li>进程间的六种通信方式和线程间的三种通信方式</li>
<li>死锁的四个必要条件及解决的策略</li>
<li>虚拟内存的六种页面置换算法</li>
<li>磁盘的三种磁盘调度算法</li>
</ul>
<p><strong>详细</strong></p>
<ul>
<li>进程和线程<ul>
<li>进程是操作系统分配资源的基本单位,线程是CPU调度的基本单位</li>
<li>系统开销上：创建、切换和销毁进程都比创建、切换和销毁线程的开销要大</li>
<li>通信上：线程可通过共享进程内存空间实现通信，进程需借助IPC通信</li>
<li>一个进程由一个或多个线程组成（至少有一个线程），线程是一个进程中代码的不同执行路线</li>
<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；   </li>
</ul>
 <strong>为什么使用多线程而不是多进程</strong><ul>
<li>创建和销毁上：线程分配的资源少，效率更高</li>
<li>上下文切换上：线程切换较进程切换开销少</li>
</ul>
 <strong>为什么需要多进程</strong><ul>
<li>进程是程序的一次执行过程，不同程序需要不同进程；</li>
<li>需要独立内存空间的情况下，需要新建进程。</li>
</ul>
</li>
<li>fork函数<ul>
<li>fork() 函数通过系统调用创建一个与原来进程几乎完全相同的进程，这两个进程可以做相同的事，但如果初始参数或传入的变量不同，两个进程也可以做不同的事</li>
<li>fork() 被调用后，返回给父进程子进程的进程id；返回给子进程0；如果出现错误，返回一个负值</li>
</ul>
</li>
<li>IPC区别<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/2.png" class=""></li>
<li>单核 cpu 多任务下，单线程执行快还是多线程执行快<ul>
<li>如果是 cpu 密集型作业：单线程执行快，因为多线程切换会浪费 cpu 时间</li>
<li>如果是 I/O 密集型作业：多线程执行快，因为能充分利用线程阻塞期间 cpu 的时间</li>
</ul>
</li>
<li>进程切换和线程切换的区别<br>  对于linux来说，线程和进程的最大区别就在于地址空间。<ul>
<li>进程切换分两步：<ul>
<li>切换页目录以使用新的地址空间；</li>
<li>切换内核栈和硬件上下文。</li>
</ul>
</li>
<li>对于线程切换：仅需切换内核栈和硬件上下文，无需切换页目录。</li>
</ul>
</li>
<li>进程通信的管道类型：<br>  <strong>管道本质是 FIFO 文件</strong><ul>
<li>匿名管道：<ul>
<li>管道是半双工的，数据在同一时刻只能单向通信；</li>
<li>需要双方同时通信时，需要建立起两个管道；</li>
<li>只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。</li>
</ul>
</li>
<li>命名管道：可在同一台计算机的不同进程之间或在跨越一个网络的不同计算机的不同进程之间，也仅支持半双工通信。    </li>
</ul>
  <strong>管道通信的缺点</strong><ul>
<li>仅支持半双工通信，要想全双工需要额外开一个管道</li>
<li>管道存在内存中，缓冲区有限</li>
<li>若管道已满，写进程会被阻塞；若管道已空，读进程会被阻塞</li>
</ul>
</li>
<li>线程间通信方式：<ul>
<li>消息队列</li>
<li>全局变量</li>
<li>使用事件 CEvent 类实现</li>
</ul>
</li>
<li>线程共享进程哪些资源，独有哪些资源<ul>
<li>共享：堆、全局变量、静态变量、文件等公共资源</li>
<li>独享：栈、寄存器（进程的副本）</li>
</ul>
</li>
<li>线程挂掉后进程一定会挂吗？<ul>
<li>总体来说，线程没有独立的地址空间，如果崩溃，会产生 SIGSEGV (Segmentation Violation/Fault)信号，如果没有错误处理的 handler，OS 一般直接杀死进程。</li>
<li>但就算是有 handler 了处理，一般也会导致程序崩溃，因为很有可能其他线程或者进程的数据被破坏了。</li>
</ul>
</li>
<li>协程：又称微线程，有点像子程序，但在子程序执行过程中，可以产生中断，转而执行其它程序，待其他程序执行完毕后，转回来执行原来的程序。这一过程不是函数调用，也没有发生线程切换，因此效率极高。</li>
<li>用户态和内核态<br>  用户态：运行应用程序<br>  内核态：运行操作系统程序，操作硬件<br>  <strong>区别：</strong><ul>
<li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其占有的处理器是可被抢占的</li>
<li>处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。</li>
</ul>
  <strong>通常来说，以下三种情况会导致用户态到内核态的切换：</strong><ul>
<li>系统调用</li>
<li>异常</li>
<li>外围设备中断</li>
</ul>
  <strong>如何避免内核态和用户态的频繁切换</strong><ul>
<li>减少线程切换。如使用无锁并发编程（CAS 算法）、避免创建不必要的线程、使用线程</li>
<li>若是因为 I/O 导致的切换，则使用用户进程缓冲区，并结合使用预读和延迟写方法</li>
</ul>
</li>
<li>内存大小<ul>
<li>2 ^ 10 = 1K</li>
<li>2 ^ 20 = 1M</li>
<li>2 ^ 30 = 1G</li>
<li>2 ^ 40 = 1T</li>
<li>2 ^ 50 = 1P</li>
<li>2 ^ 60 = 1e</li>
</ul>
</li>
<li>虚拟内存<ul>
<li>目的：使用逻辑内存，使程序拥有更大的可用内存。</li>
<li>本质：根据寻址总线（如 64 位）形成的虚拟空间，进程启动时分配的是该虚拟空间。虚拟空间与物理内存存在映射，但只会映射进程当时需要的页，而不是全部映射。</li>
<li>寻址：内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。对于虚拟地址，其前面若干位为页面号（对应页表的 index），查找页表得到对应的页框号，页框号拼接虚拟地址剩余的后面若干位形成页框地址。即完成寻址。</li>
<li>调页：在寻址中，若标识位指示该页不在内存中，则需将该页从磁盘中调入内存。</li>
<li>缺页：若在调页中发现该进程在内存没有足够空间存放新页，则操作系统调用页面置换算法，将选择的页调出内存，将需要的页调入内存。</li>
</ul>
</li>
<li>虚拟内存的页和段的区别<ul>
<li>页的大小固定，段的大小可动态扩展</li>
<li>分页存在内存碎片，分段没有</li>
<li>分页地址是一维的，分段地址是二维的</li>
<li>分页透明，分段需要程序员显示的划分每个段</li>
</ul>
  <strong>操作系统分页的好处：</strong><ul>
<li>是操作系统实现虚拟内存的基础</li>
<li>允许进程申请的内存空间不连续</li>
<li>减少内存碎片</li>
</ul>
  <strong>分页为什么是一维的：</strong><ul>
<li>操作时给出地址，即可根据该地址计算出页号和页内偏移量（这得益于页大小是固定的），而不需要显示划分</li>
</ul>
</li>
</ul>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><strong>基本知识</strong></p>
<ul>
<li>再看一遍 Linux 的文件系统、文件、进程管理；</li>
<li>再看一遍 socket。</li>
</ul>
<p><strong>详细</strong></p>
<ul>
<li><p>IO 多路复用</p>
<ul>
<li>指单个进程同时处理多个网络连接的 IO 的能力</li>
<li>Linux 下提供了 select、poll 和 epoll 系统调用实现 IO 多路复用</li>
<li>当用户进程调用了 select，会进入阻塞状态。select 会轮询负责的所有 socket，当 select 中的某个 socket 数据准备好时，select 会返回。这个时候用户进程再调用 read 操作，将数据从内核缓冲区拷贝到用户进程缓冲区</li>
</ul>
</li>
<li><p>进程的内存结构</p>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/1.png" class=""></li>
<li><p>Nginx 的优点</p>
<ul>
<li>内存消耗少</li>
<li>稳定性高： 用于反向代理，宕机的概率微乎其微</li>
<li>支持高并发连接：原因主要是 Nginx 使用了最新的 epoll（Linux2.6 内核）和 kqueue（freeBSD）网路 I/O 模型</li>
<li>支持热部署：启动容易，且能够在不间断服务的情况下，对软件版本进行升级</li>
<li>支持 Rewrite 重写 </li>
<li>成本低廉</li>
<li>配置简单  </li>
</ul>
</li>
<li><p>常用操作<br>  <strong>查看端口号被哪个进程占用</strong></p>
<ul>
<li>lsof -i:端口号</li>
<li>netstat -tunlp|grep 端口号</li>
</ul>
<p> <strong>进程查看和杀死命令</strong></p>
<ul>
<li>ps 命令用于查看当前正在运行的进程</li>
<li>kill 命令用于终止进程</li>
</ul>
</li>
<li><p>硬链接和软链接</p>
<ul>
<li>硬链接：文件名指向索引节点</li>
<li>软链接：特殊的文件，存储另一文件的路径信息</li>
</ul>
</li>
<li><p>零拷贝对比</p>
<table>
<thead>
<tr>
<th align="center">拷贝方式</th>
<th align="center">CPU拷贝次数</th>
<th align="center">DMA拷贝次数</th>
<th align="center">上下文切换次数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">传统方式</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">mmap + write</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">sendfile</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">sendfile + DMA</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
</tbody></table>
<p> <strong>缺点</strong></p>
<ul>
<li>mmap + write：当 mmap 一个文件时，若该文件被另一个进程所截获，则 write 系统调用会因为访问非法地址而被 SIGBUS 信号终止。 可通过使用文件的租界锁解决</li>
<li>sendfile：仅适用于无需用户态处理的程序</li>
<li>sendfile + DMA：除了 sendfile 一样的问题，还有需要硬件和驱动程序的支持</li>
</ul>
</li>
<li><p>Ctrl + C/Z</p>
<ul>
<li>ctrl + C：强制中断执行当前交互程序的进程</li>
<li>ctrl + Z：将任务中断,但是此任务并没有结束,他仍然在进程中他只是维持挂起的状态</li>
</ul>
</li>
<li><p>实体链接和符号链接的区别：实体链接不能对目录进行链接，符号链接可以</p>
</li>
<li><p>waitpid() 和 wait() 相比的区别：</p>
<ul>
<li>多了参数 pid，指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHILD 信号</li>
<li>多了 options 参数，可选为 WNOHANG 和 WUNTRACED 两个选项，若参数为 WNOHANG，可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/java-interview-highlights/">Java 面试突击</a><br><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/">CS Note</a></p>
</blockquote>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html">JUC 锁: 锁核心类 AQS 详解</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903695298068487">Synchronize 和 ReentrantLock 区别</a></p>
</blockquote>
<p><strong>基本知识</strong></p>
<ul>
<li>线程池好处</li>
<li>线程池参数</li>
<li>线程池提交任务的过程</li>
<li>关闭线程池的方法</li>
<li>Java 并发里的 JUC-AQS</li>
<li>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li>
<li>可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ul>
<p><strong>详细</strong></p>
<ul>
<li>可见性问题：可见性与 Java 的内存模型有关，模型采用缓存与主存的方式对变量进行操作，也就是说，每个线程都有自己的缓存空间，对变量的操作都是在缓存中进行的，之后再将修改后的值返回到主存中。但这也带来了问题：有可能 线程1 在将共享变量修改后，还没有来的及将缓存中的变量返回给主存中，线程2 就要对该共享变量进行修改，那么 线程2 拿到的值是主存中未被修改的值，这就是可见性的问题。<strong>可通过缓存一致性协议（MESI）解决。</strong></li>
<li>volatile 关键字<ul>
<li>能保证可见性。变量经 volatile 修饰后，汇编指令中会有一个 LOCK 前缀指令，当该变量被修改时，会引发两件事情：<ol>
<li>将当前处理器缓存行的数据写回到系统内存；</li>
<li>这个写回内存的操作会使得在其他处理器缓存的该内存地址无效。<br>即当一个共享变量被 volatile 修饰时，它会保证修改的值被立即更新到主存，当有其他线程需要读取时，它会去内存中读取新值，这就保证了可见性。</li>
</ol>
</li>
<li>能保证有序性。volatile 可以禁止指令进行重排序优化。</li>
<li>不保证原子性。对于 i++ 操作：在某一时刻线程1 将 i 的值取出放到 cpu 缓存中，然后再将此值放置到寄存器A 中，在 A 中该值自增1（寄存器A 中保存的是中间值，没有直接修改 i，因此其他线程并不会获取到这个自增 1 的值）。如果在此时线程2 也执行同样的操作，获取值 i=10 ,自增 1 变为 11，然后马上刷入主内存。此时由于线程2 修改了 i 的值，线程1 中的 i=10 的值缓存失效，重新从主内存中读取，变为 11。接下来线程1 恢复。将自增过后的 A寄存器值 11 赋值给 cpu 缓存的 i。这样就出现了线程安全问题。</li>
<li>使用场合：不要将 volatile 用在 getAndOperate 场合，仅仅 set 或者 get 的场景是适合 volatile 的。</li>
<li>内存屏障：<ul>
<li>在每个 volatile 写操作前插入 StoreStore 屏障，在写操作后插入 StoreLoad 屏障；</li>
<li>在每个 volatile 读操作前插入 LoadLoad 屏障，在读操作后插入 LoadStore 屏障；</li>
</ul>
</li>
</ul>
  <strong>补充：Java 中变量的运算过程：</strong>线程先从内存中取该值放到线程缓存空间中，然后 cpu 读取缓存值放到寄存器运算，运算后结果返回线程缓存空间，再返回主存中。</li>
<li>synchronized 关键字<ul>
<li>实现细节：<ul>
<li>若是同步代码块，则在代码块前后分别添加 monitorenter 和 monitorexit 字节码指令。在执行 monitorenter 指令时，首先尝试获取对象锁，或把锁的计算器加 1；在执行 monitorexit 指令时会将锁计算器减 1，当计算器为 0 时，锁就被释放了。</li>
<li>若是同步方法，则 JVM 从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否被声明为同步方法</li>
</ul>
</li>
<li>四种锁状态<ul>
<li>无锁状态</li>
<li>偏向锁：通过对比 Mark Word 解决加锁问题（若获取锁的线程是 Mark Word 里记录的锁偏向的线程，则该线程直接获取锁），避免执行 CAS 操作（只有在置换 ThreadID 时使用 CAS 操作）。</li>
<li>轻量级锁：通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。</li>
<li>重量级锁：将除了拥有锁的线程以外的线程都阻塞。</li>
</ul>
</li>
</ul>
  <strong>膨胀式锁分配策略：</strong>锁可以升级但不可以降级</li>
<li>关键字 synchronized 和 volatile 的对比（五种）</li>
<li>synchronized 和 ReentrantLock 对比<ul>
<li>相同点：加锁方式同步、阻塞式同步，都属于可重入锁。</li>
<li>不同点：<ul>
<li>API 层面：Synchronized 是 java 语言的关键字，是原生语法层面的互斥，需要 jvm 实现；ReentrantLock 是 JDK 1.5 之后提供的 API 层面的互斥锁，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成。</li>
<li>使用方式上：synchronized 既可以修饰方法，也可以修饰代码块；ReentrantLock 只适用于代码块，使用 <code>lock.lock()</code>、<code>lock.unlock()</code> 方法上锁/解锁。</li>
<li>等待可中断：synchronized 不支持等待可中断，ReentrantLock 支持。</li>
<li>公平锁：synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁。</li>
<li>锁绑定多个条件：ReentrantLock 可以同时绑定多个 Condition 对象，只需多次调用 newCondition 方法即可；synchronized 中，锁对象的 wait()、notify() 或 notifyAll() 方法可以实现一个隐含的条件。但如果要和多于一个的条件关联的时候，就不得不额外添加一个锁。</li>
</ul>
</li>
</ul>
  <strong>等待可中断：</strong>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。等待可中断特性对处理执行时间非常长的同步块很有帮助。<br>  <strong>公平锁：</strong>公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序来依次获得锁；非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁，即不保证按申请的时间顺序来依次获得锁。<br>  <strong>可重入锁：</strong>获取锁的线程可重复获取该锁，则称为可重入锁。<ul>
<li>ReentrantLock 补充：<ul>
<li>为保证锁释放，每一个 lock() 动作，建议都立即对应一个 try-catch-finally unlock() 动作。</li>
</ul>
</li>
</ul>
</li>
<li>AQS 相关（AbstractQueuedSynchronizer 抽象队列同步器）<ul>
<li>就 ReentrantLock 来说，AQS 是它的一个对象，是 ReentrantLock 用来实现加锁和释放锁的关键性的核心组件</li>
<li>核心变量 state：0 表示未上锁，非 0 表示已上锁，非 0 值表示上锁的线程重入该锁的次数</li>
<li>记录加锁线程的变量：该变量记录加锁的线程，用于实现可重入锁</li>
<li>阻塞队列：ReentrantLock 是互斥锁，所有申请锁失败的线程都会进入阻塞队列</li>
</ul>
</li>
<li>Java的锁分类（7大类）<ul>
<li>偏向锁/轻量级锁/重量级锁</li>
<li>可重入锁/不可重入锁</li>
<li>共享锁/独占锁</li>
<li>公平锁/非公平锁</li>
<li>悲观锁/乐观锁</li>
<li>自旋锁/非自旋锁</li>
<li>可中断锁/不可中断锁</li>
</ul>
</li>
<li>Java 创建线程的方式（也即如何实现多线程）<ul>
<li>通过继承 Thread 类（该类实现了 Runnable 接口）：重写 run() 方法，调用 start() 方法创建新线程。<br>如 <code>new ThreadTest().start();</code>，其中 ThreadTest 类继承了 Trread 类。</li>
<li>通过实现 Runnable 接口：创建该类的示例，将该实例作为 Thread 类的 target 对象新建线程。如 <code>ThreadTest tt = new ThreadTest(); new Thread(tt, &quot;新线程1&quot;).start();</code>，其中 ThreadTest 实现了 Runnable 接口。</li>
</ul>
  <strong>补充</strong>：run() 方法的方法体就是线程要完成的任务</li>
<li>start() 和 run() 的区别<ul>
<li>当程序调用 Thread 类 start() 方法，会创建一个新线程。此时该线程处于就绪（可运行）状态，并没有运行，一旦得到 cpu 时间片，才开始执行 run() 方法。</li>
<li>若程序直接调用 run() 方法，则是程序当前运行线程执行 run() 方法。</li>
</ul>
</li>
<li>Java 常见的几种线程池（五种）<ul>
<li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程（数量没有限制）。</li>
<li>newFixedThreadPool：创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</li>
<li>newSingleThreadExecutor：只创建一个工作者线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
<li>newScheduleThreadPool：创建一个定长的线程池，支持定时的以及周期性的任务执行。可基于该线程池设计定时任务类，每个调度任务都会分配到线程池中的一个线程去执行。也就是说，任务是并发执行，互不影响。</li>
</ul>
</li>
<li>Java 线程的状态<ul>
<li>初始状态（NEW）：线程已经构建，尚未启动。</li>
<li>运行状态（RUNNABLE）：包括就绪（READY）和运行中（RUNNING）两种状态，统称为运行状态。</li>
<li>阻塞状态（BLOCKED）：线程被锁阻塞。</li>
<li>等待状态（WAITING）：线程需要等待其他线程做出特定动作（通知或中断）。</li>
<li>超时等待状态（TIME_WAITING）：不同于等待状态，超时等待状态可以在指定的时间自行返回。</li>
<li>终止状态（TERMINATED）：当前线程已经执行完毕。</li>
</ul>
  <strong>阻塞状态</strong><ul>
<li>线程争用锁失败进入阻塞状态</li>
</ul>
  <strong>等待状态</strong><ul>
<li>锁对象调用wait()方法（无指定超时时间）后线程进入等待状态</li>
</ul>
  <strong>超时等待状态</strong><ul>
<li>线程调用sleep(int timeout)或锁对象wait(int timeout)方法后线程进入超时等待状态，在等待指定时间后会返回</li>
</ul>
  <strong>sleep()和wait()方法区别</strong><ul>
<li>sleep()方法仅支持超时等待，wait()支持等待和超时等待状态</li>
<li>sleep()释放CPU执行权，但不释放同步锁；wait()释放CPU执行权，也释放同步锁，使得其他线程可以使用同步控制块或者方法。</li>
<li>只有锁对象才能调用wait()和notify()方法，sleep()方法不由锁对象调用</li>
</ul>
</li>
<li>线程安全问题<ul>
<li>运算结果错误（i++）</li>
<li>对象没有在正确的时间、地点被发布或初始化</li>
<li>活跃性问题，如死锁、活锁、饥饿</li>
</ul>
</li>
<li>ThreadLocal() 类：ThreadLocal 是 JDK 包提供的一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据。通过 get 和 set 方法可以获取和设置当前线程对应的值。</li>
<li>Copy-On-Write：一种读写分离的并发策略。在多线程下共享的某个对象，当有人想修改内容的时候，就会创建该对象的副本，对副本进行修改，修改完后将原本的引用指向副本。<ul>
<li>优点：<ul>
<li>读取性能很高，因为读取的时候是无锁的，比较适合读多写少的场景；</li>
<li>采用读写分离策略，允许读取的时候修改集合数据，没有 fail-fast 机制；</li>
</ul>
</li>
<li>缺点：<ul>
<li>内存占用问题。相比不读写分离，内存多占用了一倍；</li>
<li>数据一致性问题，CopyOnWrite 只保证数据的最终一致性，并不能保证数据的实时一致性。所以对数据实时一致性要求比较高的场景不适合使用CopyOnWrite容器。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E4%B8%80%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F">CS Note</a></p>
</blockquote>
<p><strong>基础知识</strong></p>
<ul>
<li>GC ROOTS的四类对象</li>
<li>垃圾收集算法；</li>
<li>CMS 和 G1 收集器</li>
<li>JVM 的内存分配与回收策略</li>
<li>类的加载过程</li>
</ul>
<p><strong>详细</strong></p>
<ul>
<li><p>运行时数据区域</p>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/java_2.jpg" class=""></li>
<li><p>JVM的回收过程：大致如下，调用垃圾回收器——判断对象是否可回收（引用计数法和根搜索算法）——调用垃圾回收算法（标记—清除算法、复制算法、标记—整理算法、分代收集算法）</p>
</li>
<li><p>双亲委派模型</p>
<ul>
<li>类加载器之间有层级关系，从上到下依次为：启动类加载器、扩展类加载器、应用程序类加载器和用户自定义类加载器。除了顶层的启动加载类（又称引导加载类），其他的类加载器（扩展类加载器、应用程序类加载器、用户自定义加载器）都要有自己的父类加载器</li>
<li>类加载器间的父子关系一般通过组合关系实现，而不是继承关系</li>
<li>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</li>
</ul>
<p> <strong>好处：</strong>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p>
<p> <strong>补充：</strong>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
</li>
<li><p>内存泄漏相关</p>
<ul>
<li>定义：内存泄漏是指程序动态分配的堆内存因某种原因程序未释放或无法释放，造成系统内存浪费的情况。它会导致程序运行速度减慢甚至系统崩溃的后果</li>
<li>Java的内存泄漏和C++的内存泄露有什么不同：在C++中，如果需要动态分配一块内存，程序员需要负责这块内存的整个生命周期，这样很灵活，但过程却很繁琐，程序员容易因为疏忽忘记释放内存，从而导致内存泄漏；在Java有垃圾回收机制，它负责自动回收不再使用的内存</li>
<li>Java中还会有内存泄漏的情况吗？ 有，Java 的内存泄露通常情况下表现为一个内存对象的生命周期超出了程序需要它的时间长度。比如无效的使用static字段</li>
</ul>
</li>
<li><p>引用计数法和根搜索算法（或可达性分析法）</p>
<ul>
<li>引用计数法根据对象的引用计数判断对象是否可回收，若对象的引用计数为0，则回收对象；根搜索算法回收的是从GC ROOTS开始搜索不可达的对象</li>
<li>引用计数法存在循环引用的问题，根搜索算法可能导致浮动垃圾和对象消失问题</li>
</ul>
</li>
<li><p>JVM的根搜索算法——三色标记</p>
<ul>
<li>三色标记分别是：黑色、灰色、白色<br>黑色：根对象，或者该对象与它的子对象都被扫描过<br>灰色：对象本身被扫描，但是还有没扫描该对象的子对象<br>白色：未被扫描的对象，如果扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</li>
<li>浮动垃圾：GC中已经标黑的对象，在并发过程中引用链断掉，导致应为白色的垃圾对象仍是黑色的现象。解决办法：留给下次垃圾回收处理</li>
<li>对象消失问题需满足以下两个必要条件：<ol>
<li>赋值器插入了一条或多条从黑色对象到白色对象的引用</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ol>
</li>
</ul>
<p>   <strong>解决办法</strong></p>
<ul>
<li>增量更新（CMS使用）：当一个白色对象被黑色对象引用，将黑色对象重新标记为灰色，让垃圾回收器重新扫描。</li>
<li>原始快照（G1使用）：在灰色对象要删除和白色对象的引用时，将该引用记录下来，在并发扫描结束后，重现这些记录的引用对象，类似浮动垃圾的处理。</li>
</ul>
</li>
<li><p>JVM的栈和堆</p>
<ul>
<li>栈中存放基本类型的数据或对象的引用变量，堆存放的是new创建的数组或对象</li>
<li>栈中的对象可以共享，堆中的不可以</li>
<li>栈的存取速度较快</li>
<li>栈中数据大小和生命周期可以确定，当没有引用指向数据时，数据便会消失；堆中的对象由垃圾回收器负责回收，因此大小和生命周期都不确定</li>
</ul>
</li>
<li><p>Java类加载机制</p>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.png" class=""></li>
</ul>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://dunwu.github.io/javacore/concurrent/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_1-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">Java 内存模型</a></p>
</blockquote>
<ul>
<li><p>Java内存模型</p>
<ul>
<li>Java内存模型规定了所有变量都存储在主内存内，此处主内存隶属于Java虚拟机内存的一部分，而虚拟机内存是操作系统分配的。每条Java线程还有自己的工作内存(类比上面的高速缓存)，工作内存中保存了被该线程使用到的变量的主内存的副本，线程对变量的所有操作都在工作内存中进行，Java线程之间的变量值传递都通过主内存来完成。<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/5.jpg" class=""></li>
</ul>
<p>  <strong>Java内存模型定义了8种原子性操作，其中前4条是作用于主内存，后4条作用于工作内存：</strong></p>
<ul>
<li>lock 锁定，将一个变量标识为线程独占状态</li>
<li>unlock 解锁，将锁定状态的变量解除锁定，释放后的变量才可以被其他变量锁定</li>
<li>read 读取，将变量从主内存传输到线程的工作内存中，待之后的load加载</li>
<li>write 写入，把store操作从工作内存中得到的变量值写入主内存的变量中</li>
<li>load 加载，将read后从主内存得到的变量值加载到工作内存的变量副本中</li>
<li>use 使用，把工作内存中的一个变量值传递给字节码执行引擎，等待字节码指令使用</li>
<li>assign 赋值，把一个从执行引擎接收到的值赋值给工作内存的变量</li>
<li>store 存储，把工作内存中一个变量的值传送到主内存中，以便随后的write使用</li>
</ul>
</li>
<li><p>硬件层的内存屏障</p>
<ul>
<li>分类：Load Barrier 和 Store Barrier，即读屏障和写屏障。</li>
<li>作用：<ul>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li>
</ul>
</li>
<li>Load Barrier：在指令前插入 Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据；</li>
<li>Store Barrier：在指令后插入 Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</li>
</ul>
</li>
<li><p>java 内存屏障</p>
<ul>
<li>分类：LoadLoad、StoreStore、LoadStore、StoreLoad，即上述两种的组合，以完成一系列的屏障和数据同步功能。</li>
<li>LoadLoad 屏障：对于这样的语句 Load1; LoadLoad; Load2，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。</li>
<li>StoreStore 屏障：对于这样的语句 Store1; StoreStore; Store2，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。</li>
<li>LoadStore 屏障：对于这样的语句 Load1; LoadStore; Store2，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据被读取完毕。</li>
<li>StoreLoad 屏障：对于这样的语句 Store1; StoreLoad; Load2，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>基本知识</strong></p>
<ul>
<li>Object类中的通用方法（至少背6个）</li>
</ul>
<p><strong>详细</strong></p>
<ul>
<li><p>ArrayList</p>
<ul>
<li>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</li>
<li>数组的默认大小逻辑为 10，实际大小为数组内的元素个数。</li>
</ul>
<p>  <strong>添加元素</strong></p>
<ul>
<li>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够</li>
<li>如果不够时，需要使用 grow() 方法进行扩容，新容量大约是旧容量的 1.5 倍左右。</li>
<li>扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中</li>
</ul>
</li>
<li><p>Hashmap</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/java1024/p/13488714.html">HashMap面试题及答案</a></p>
</blockquote>
<ul>
<li>Hashmap 的存储结构为数组 + 链表，使用拉链法解决冲突，JDK1.7 使用头插法插入结点，JDK1.8 使用尾插法插入节点（避免循环引用）</li>
<li>默认大小为 16，容量必须为 2 的整数次幂，每次扩容为原来容量的两倍</li>
<li>默认装载因子为 0.75，即当 Hashmap 中键值对数量大于等于容量 * 0.75时，Hashmap 将自动扩容</li>
<li>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。</li>
<li>Hashmap 是线程不安全的</li>
</ul>
<p>  <strong>get 过程（JDK 1.8）</strong></p>
<ol>
<li>调用 hash 方法计算 hash 值；</li>
<li>调用 getNode() 方法。若数组为 null 则直接返回 null；</li>
<li>若数组不为 null，则位运算 hashcode &amp; (n - 1) 获取索引位置（n 为 map 的容量大小）；</li>
<li>对比索引位置首元素/key 的 hash 值和首元素的 key/查询 key 的值，若相同，则直接返回该首元素；</li>
<li>否则，若该索引位置是红黑树，则调用红黑树的 get 方法获取 value；</li>
<li>若不是红黑树，则进行 do while 循环比较获取。</li>
</ol>
<p>  <strong>put操作过程（JDK 1.8）</strong></p>
<ol>
<li>调用 hash 方法计算 hash 值；</li>
<li>再去看数组是否为空，为空的话就对数组进行初始化；</li>
<li>利用计算出来的 hash 值计算索引位置；</li>
<li>若该索引位置上的元素为 null，则直接插入 key/value 对；（插入后需 ++size 看容量是否超过阈值，若超过则需扩容）；</li>
<li>若不为 null，则 put 的 key 和索引位置的第一个元素进行比较（比较 hash 值和 key 值）<ol>
<li>若相同，则覆盖新 value 值，并返回旧 value 值；</li>
<li>若不相同，判断当前链表是否是红黑树：<ol>
<li>若不是，则遍历链表。若存在该 key 则更新 value；否则尾插法该 key/value 对；</li>
<li>若是，则调用红黑树的 put 方法。（插入后需 ++size 看容量是否超过阈值，若超过则需扩容）</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>  <strong>核心：</strong></p>
<ol>
<li>计算得到 hashcode 后，通过 hashcode &amp; (n - 1) 计算得到索引位置；</li>
<li>查询 key 的语句：first.hash == hash &amp;&amp; first.key = key。需对比查询结点的 hash 值和 key 值。</li>
<li>确定索引位置后，需判断当前索引位置是否为 null，是否是红黑树。</li>
</ol>
<p>  <strong>扩容过程</strong></p>
<ul>
<li>创建一个新的HashMap，该map的容量为原容量的两倍</li>
<li>调用resize()把原HashMap中的键值对重新插入到newTable中</li>
</ul>
<p>  <strong>Map的容量为什么必须为2的n次方</strong></p>
<ul>
<li>在查找过程中，根据key计算得到hash值后，需取模计算桶下标。若桶的大小为2的整数次方，则对capacity取模的过程可转化为对capacity - 1做与运算的过程，这个计算方式效率更高</li>
<li>在扩容重新计算桶下标过程中，若容量为2的整数次方，以原容量为16为例，则新容量为32。则原来hash值在第五位为0的键值对在新map中仍在与原map相同下标的桶处；为1的键值对在新map中为在原map桶中下标+16的桶处</li>
</ul>
<p>  <strong>HashMap为什么是线程不安全</strong></p>
<ul>
<li>JDK1.7中会在transfer()过程中出现循环引用</li>
<li>JDK1.8中会在put操作过程中造成数据覆盖</li>
</ul>
<p>  <strong>循环引用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next;   <span class="comment">// 第一步，假设线程一执行到这里就被调度挂起了</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">    e.next = newTable[i];       <span class="comment">// 第二步</span></span><br><span class="line">    newTable[i] = e;            <span class="comment">// 第三步</span></span><br><span class="line">    e = next;                   <span class="comment">// 第四步</span></span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>初始情况，线程1 和线程2 都执行到该步；<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A81.png" class=""></li>
<li>线程1 执行 <code>Entry&lt;K,V&gt; next = e.next;</code>、<code>e.next = newTable[i];</code> 后被挂起；<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A82.png" class=""></li>
<li>线程2 开始执行，执行完一轮、及 <code>Entry&lt;K,V&gt; next = e.next;</code> 后如图；<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A84.png" class=""></li>
<li>线程2 执行 <code>e.next = newTable[i];</code>，造成循环引用<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A85.png" class=""></li>
</ul>
</li>
<li><p>Hashtable 和 ConcurrentHashMap</p>
<ul>
<li>HashTable 类使用 synchronize 来做线程安全，全局只有一把锁</li>
<li>ConcurrentHashMap 在 JDK1.7 使用 segmant（分段锁）实现，自 JDK 1.8 使用 CAS（Compare and Swap）操作实现，</li>
<li>ConcurrentHashMap 也实现了在链表长度大于等于8时自动转化为红黑树</li>
</ul>
<p>  <strong>CAS 操作</strong></p>
<ul>
<li>概念：CompareAndSwap 的缩写，即比较并替换。CAS 需要有 3 个操作数：内存地址 V，旧的预期值 A，即将要更新的目标值 B。</li>
<li>执行：当且仅当内存地址 V 的值与预期值 A 相等时，将内存地址 V 的值修改为 B，否则就什么都不做。整个比较并替换的操作是一个原子操作。</li>
<li>存在的问题：<ul>
<li>ABA 问题：变量更新若为 A-B-A，则无法识别。解决办法：添加版本号。</li>
<li>若循环时间过长，将导致 CPU 开销变大。</li>
<li>只适用于变量，不能保证代码块的原子性。</li>
</ul>
</li>
<li>适用场景：线程冲突小的场景（可能还有任务执行时间短的场景）</li>
</ul>
<p>  <strong>ConcurrentHashMap 中的 size 操作（JDK1.7）</strong></p>
<ul>
<li>每个 segment 中维护一个 count 变量，记录该 segment 中键值对的数量</li>
<li>size 操作会统计所有    segment 的 count 并累计起来</li>
<li>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。重试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此重试次数为 3。如果重试的次数超过 3 次，就需要对每个 Segment 加锁。</li>
</ul>
</li>
<li><p>String相关</p>
<ul>
<li>String 类用 final 修饰，代表 String 类不可被继承。</li>
<li>用于存储字符串值的 char[] value 数组用 private 和 final 修饰，其中，final 可以保证 value 的引用地址不会被修改，但是不能保证数组中的值不会被修改，而 private 能够保证值不会被外部修改。这样就能保证 String 类的不可变性。</li>
</ul>
<p>  <strong>不可变性的好处</strong></p>
<ul>
<li>使得JVM可以实现字符串常量池；字符串常量池可以在程序运行时节约很多内存空间，因为不同的字符串变量指向相同的字面量时，都是指向字符串常量池中的同一个对象。这样一方面能够节约内存，另一方面也提升了性能。</li>
<li>保证了安全性。比如：若在 HashMap 中使用 StringBuilder 作为键的类型，因为 StringBuilder 可以改变，则可能导致 HashMap 中某个键被改变成与另一键相同，从而出现键不唯一的情况</li>
</ul>
<p>  <strong>equals源码分析</strong></p>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/6.png" class=""></li>
<li><p>哈夫曼树：带权路径长度最小的二叉树。</p>
<ul>
<li>路径长度：指结点到根结点的分支次数</li>
<li>带权：指叶结点的权值；</li>
<li>叶结点的带权路径长度：指叶结点的权值与路径长度的乘积值；</li>
<li>树的带权路径长度：指树的所有叶结点的带权路径长度之和。</li>
</ul>
</li>
<li><p>Java 的 “==” 和 “equals”</p>
<ul>
<li>“==” 仅适用于基本类型数据（如字符）比较，若用于对象（如字符串），则比较的是对象地址；</li>
<li>“equals” 用于比较对象，但该方法不能作用于基本数据类型的变量。此外，equalsIgnoreCase() 方法还可实现不区分大小写比较两个字符串</li>
</ul>
</li>
<li><p>Java 的 static 关键字<br>  <strong>static 方法（静态方法）</strong></p>
<ul>
<li>静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有 this 的；一般使用类名访问；</li>
<li>静态方法中不能访问类的非静态成员变量和非静态成员方法，但非静态成员方法中是可以访问静态成员方法/变量的</li>
<li>最常见的 static 方法就是 main 方法，因为程序在执行 main 方法的时候没有创建任何对象，因此只有通过类名来访问。</li>
</ul>
<p>  <strong>static 变量（静态变量）</strong></p>
<ul>
<li>静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。</li>
<li>非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li>
<li>static 成员变量的初始化顺序按照定义的顺序进行初始化。</li>
</ul>
<p>  <strong>static 代码块（静态代码块）</strong></p>
<ul>
<li>static 块可以置于类中的任何地方，类中可以有多个 static 块。在类初次被加载的时候，会按照 static 块的顺序来执行每个 static 块，并且只会执行一次。</li>
</ul>
<p>  <strong>补充</strong></p>
<ul>
<li>通过 this 能够访问静态成员变量</li>
<li>static 不允许用来修饰局部变量（Java 中是这样）</li>
<li>static 代码块先于构造方法执行，因为 static 代码块在类加载的时候就执行，构造方法在创建对象的时候才执行</li>
</ul>
</li>
<li><p>Java 的 final 关键字<br>  <strong>final 类</strong></p>
<ul>
<li>当用 final 修饰一个类时，表明这个类不能被继承。</li>
<li>final类中的所有成员方法都会被隐式地指定为 final 方法。</li>
</ul>
<p>  <strong>final 方法</strong></p>
<ul>
<li>把方法锁定，以防任何继承类重写</li>
<li>类的 private 方法会隐式地被指定为 final 方法</li>
</ul>
<p>  <strong>final 变量</strong></p>
<ul>
<li>如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改</li>
<li>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象</li>
</ul>
</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Blue-Keroro/p/8875898.html">Java 泛型详解 </a></p>
</blockquote>
<p><strong>基本知识</strong></p>
<ul>
<li>Java 反射</li>
</ul>
<p><strong>详细</strong></p>
<ul>
<li><p>Java 单例模式</p>
<ul>
<li>组成：<ul>
<li>一个私有构造函数：确保不能通过构造函数来创建对象示例；</li>
<li>一个私有静态变量：确认对象地址不会被改变；</li>
<li>一个公有静态函数：返回唯一的静态变量（对象）。</li>
</ul>
</li>
<li>实现：<ul>
<li>懒汉式：线程不安全<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>饿汉式：线程安全<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>泛型</p>
<ul>
<li>定义：泛型，即“参数化类型”。本质是在不创建新类型的情况下，通过泛型指定不同类型来控制形参具体限制的类型。</li>
<li>特性：<ul>
<li>泛型只在编译阶段有效，在编译之后程序会采取去泛型化的措施。</li>
<li>泛型的类型参数只能是类类型，不能是简单类型。</li>
</ul>
</li>
</ul>
</li>
<li><p>Java里的几种内部类：</p>
<ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>嵌套内部类</li>
<li>匿名内部类<br>内部类可以访问外部类的成员，在内部类构造的时候，会将外部类的引用传递进来，并且作为内部类的一个属性，所以内部类会持有一个其外部类的引用。</li>
</ul>
</li>
<li><p>迭代器：Iterator 类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
</li>
<li><p>常见的五种运行时异常</p>
<ul>
<li>IndexOutOfBoundsException - 下标越界异常</li>
<li>NullPointerException - 空指针引用异常</li>
<li>ClassCastException - 类型强制转换异常</li>
<li>ArithmeticException - 算术运算异常</li>
<li>NegativeArraySizeException - 数组大小错误异常（数组大小为负数）</li>
</ul>
</li>
<li><p>重写和重载</p>
<ul>
<li>Override：重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。（返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类</li>
<li>Overload：重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。</li>
</ul>
</li>
<li><p>Java 引用和 C++ 指针的区别</p>
<ul>
<li>类型：引用的值是 Java 封装了的地址，可以转换成字符串查看，长度也可以不必担心。C++ 指针是一个装地址的变量，长度一般是计算机字长，可以认为是个 int。</li>
<li>所占内存：引用声明时没有实体，不占空间。C++ 指针在声明之后用到才会赋值，若用不到则不会分配内存。</li>
<li>初始值：引用初始值为 java 关键字 null。C++ 指针是 int 类型，若不初始化指针，则值不固定，这很危险。</li>
<li>计算：引用不可以计算。C++ 指针是 int，他可以计算，如 ++ 或 –，所以经常用指针来代替数组下标。</li>
<li>内存泄露：Java 引用不会产生内存泄露。C++ 指针是容易产生内存泄露的，所以程序员要小心使用，及时回收。</li>
</ul>
</li>
<li><p>抽象类和接口<br>  <strong>相同点</strong></p>
<ul>
<li>都不能被实例化</li>
</ul>
<p>  <strong>不同点</strong></p>
<ul>
<li>接口是对某一个行为动作的抽象，而抽象类是对类的抽象（包括了属性和对应的行为）</li>
<li>接口可以实现多实现，抽象类只能单继承</li>
<li>接口中定义的方法不能实现，抽象类中的方法可以部分实现。</li>
<li>接口中的域默认的为public static final，即不可更改的动作。而抽象类中可以被任意权限修饰符修饰，static/非static，final/非final，可以有抽象方法和非抽象方法。<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/4.png" class=""></li>
</ul>
<p>  <strong>interface的应用场合</strong></p>
<ul>
<li>类与类之前需要特定的接口进行协调，而不在乎其如何实现。</li>
<li>作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。</li>
<li>需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。</li>
<li>需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。</li>
</ul>
<p>  <strong>abstract class的应用场合</strong><br>  <em>一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：</em></p>
<ul>
<li>定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。</li>
<li>某些场合下，只靠纯粹的接口不能满足类与类之间的协调，而需要类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。</li>
<li>规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能</li>
</ul>
</li>
<li><p>类与接口</p>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/java_1.png" class="">
<ul>
<li>实现关系：类实现接口</li>
<li>泛化关系：类继承类</li>
<li>依赖关系：表现为四种形式，以 A 类依赖于 B 类举例来说<ul>
<li>B 为 A 的局部变量</li>
<li>调用 B 的静态方法</li>
<li>B 作为 A 的方法参数</li>
<li>B 作为 A 的方法的返回值</li>
</ul>
</li>
<li>聚合关系：体现的是整体与部分的拥有关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期</li>
<li>组合关系：体现整体与部分间的包含关系。此时整体与部分是不可分的</li>
</ul>
<p>  <strong>在Java中，仅从类代码本身是区分不了聚合和组合的。</strong></p>
</li>
</ul>
<hr>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/o9zra2/">校招基础知识详解</a><br><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E4%B8%80%E3%80%81%E4%BA%8B%E5%8A%A1">CS-Notes</a></p>
</blockquote>
<h2 id="通识"><a href="#通识" class="headerlink" title="通识"></a>通识</h2><p><strong>知识点</strong></p>
<ul>
<li>数据库的事务四大特性、四种并发一致性问题和四个隔离级别</li>
<li>封锁</li>
<li>MVCC</li>
<li>Next-Key Locks</li>
<li>关系数据库设计理论</li>
<li>索引优化</li>
</ul>
<p><strong>详细</strong></p>
<ul>
<li>数据库索引：<br>  索引是对数据库表中的一个或多个列进行排序的结构。<ul>
<li>优点：<ul>
<li>通过创建唯一索引，能够在索引和数据上建立一对一的映射，增加数据的唯一性的特点；</li>
<li>能够提高数据的检索和排序速度</li>
<li>能够加快表与表之间的连接速度</li>
<li>建立索引后，在信息查询过程中可以使用优化隐藏器</li>
</ul>
</li>
<li>缺点（索引建多的坏处）<ul>
<li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li>
<li>更多的索引意味着需要更多的空间</li>
<li>数据量小的表不需要建立索引，建立会增加额外的索引开销</li>
</ul>
</li>
<li>联合索引：又叫复合索引、多列索引。查询时从左到右的使用索引中的字段，因此需遵循最左侧原则，即数据的最左匹配特性。联合索引可以在指定值查询、范围查询和排序中使用，但需注意的是，一旦使用了范围查询，则范围查询列以后的所有列索引失效。</li>
<li>聚簇索引和非聚簇索引的区别：<ul>
<li>聚簇索引查询结果的顺序就是数据的物理存储的顺序，非聚簇索引则与数据的物理存储顺序无关；</li>
<li>聚簇索引的叶结点就是数据节点，非聚簇索引的叶结点还是索引</li>
<li>聚簇索引具有唯一性，一张表只能设置一个聚簇索引</li>
</ul>
</li>
<li>索引失效<ul>
<li>查询条件中有 or，则部分条件中的索引失效。若想索引生效，则 or 查询中的每一列均需加索引</li>
<li>复合索引不满足最左侧原则</li>
<li>Like 中以‘%’开头</li>
<li>需要类型转换</li>
<li>where 中索引列有运算</li>
<li>where 中索引列使用了函数</li>
<li>如果 mysql 觉得全表扫描更快时（数据量少）</li>
</ul>
</li>
<li>对什么样的表和列应该建立索引<ul>
<li>经常需要搜索、范围查询和排序的列</li>
<li>在作为主键的列</li>
<li>经常用在连接的列，即外键上</li>
</ul>
</li>
<li>主键索引和非主键索引区别<ul>
<li>主键索引也被称为聚簇索引,叶子节点存放的是整行数据; 而非主键索引被称为二级索引,叶子节点存放的是主键的值。</li>
<li>因此查询过程中，主键索引仅需查询该索引的b+树，非主键索引在查询完该索引的b+树时，仅获得主键值，因此仍需到主键索引的b+树上再查一次数据</li>
</ul>
</li>
<li>索引的数据结构：Hash 结构、二叉搜索树、红黑树、B 树、B+ 树。</li>
</ul>
</li>
<li>存储结构<ul>
<li>红黑树：<ul>
<li>一种二叉查找树，但在每个节点增加一个存储位表示结点的颜色，可以是 Red 或 Black</li>
<li>通过对任何一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的</li>
</ul>
  <strong>红黑树的五个性质：</strong><ul>
<li>每个节点要么是红的要么是黑的</li>
<li>根节点是黑的</li>
<li>每个叶节点（叶节点即指树尾端NIL指针或NULL结点）都是黑的</li>
<li>如果一个结点是红的，那么它的两个儿子都是黑的</li>
<li>对于任意结点而言，其到叶结点的所有路径都包含相同数目的黑结点</li>
</ul>
</li>
<li>B/B+ 树的优点——与红黑树比（二叉树）：出度更多，树高 h 更小，在查找过程中磁盘 IO 次数更少。</li>
<li>B+ 树相对 B 树的优点：<ul>
<li>非叶结点不保存数据，仅保留指向下一结点的指针，磁盘页（每一结点）能存储更多指针，较B树能有更大的出度，树高更小；</li>
<li>B+ 树查询必须查找到叶子节点，查询更稳定；</li>
<li>B+ 树的范围查找较 B 树更快，将随机 IO 变为顺序 IO（B+ 树索引是有序的，它的叶子结点是双向连接，即同时用双向链表维护叶结点）。<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93_1.png" class="" title="B树">
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93_2.png" class="" title="B+树"></li>
</ul>
</li>
<li>B+树索引和hash索引的区别<ul>
<li>时间复杂度上，B+树索引为O(logn)，hash索引为O(1)</li>
<li>B+树索引支持排序和分组，但hash索引不支持</li>
<li>B+树索引支持部分查找和精确查找，hash索引仅支持精确查找</li>
</ul>
</li>
</ul>
</li>
<li>存储引擎<ul>
<li>InnoDB：MySQL的默认存储引擎，实现了四个标准的隔离级别，默认级别是可重复读。在可重复读级别下，通过多版本并发控制（MVCC）+ Next-Key Locks防止幻影读。InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。<br>  <strong>特点</strong><ul>
<li>主索引是聚簇索引，在索引中保留了数据，避免直接读磁盘，加快了查询效率；</li>
<li>从磁盘读取数据时，使用可预测性读；</li>
<li>对于频繁查询的数据，会自动创建自适应哈希索引；</li>
<li>使用插入缓冲区加速插入操作</li>
<li>支持在线热备份</li>
</ul>
  <strong>InnoDB的七种类型的锁</strong><ul>
<li>共享/排它锁(Shared and Exclusive Locks)</li>
<li>意向锁(Intention Locks)</li>
<li>记录锁(Record Locks)</li>
<li>间隙锁(Gap Locks)</li>
<li>临键锁(Next-key Locks)</li>
<li>插入意向锁(Insert Intention Locks)</li>
<li>自增锁(Auto-inc Locks)</li>
</ul>
  <strong>InnoDB什么时候行锁什么时候表锁</strong><ul>
<li>InnoDB行锁是通过索引上的索引项来实现的，InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁。</li>
</ul>
</li>
</ul>
</li>
<li>事务和锁<ul>
<li>事务：一组不可再分割的操作集合（工作逻辑单元）；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；</li>
<li>乐观锁和悲观锁<ul>
<li>乐观锁：假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会对数据是否冲突进行检测。乐观锁适用于读操作多的场景，可通过CAS和版本快照实现</li>
<li>悲观锁：在访问某条数据时，为避免该数据被修改，会对该数据进行加锁以防止并发，保证同步区的互斥性。适合写操作多的场景，可java中synchronize关键字（的重量级锁）实现</li>
</ul>
</li>
<li>两段锁协议<br>  <strong>规则</strong><ul>
<li>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁。</li>
<li>在释放一个封锁之后，事务不再申请和获得其它任何封锁。</li>
</ul>
  <strong>即事务的执行分为两个阶段：</strong><ul>
<li>第一阶段是获得封锁的阶段，称为扩展阶段。</li>
<li>第二阶段是释放封锁的阶段，称为收缩阶段。</li>
</ul>
</li>
<li>实现分布式锁的三种方式：基于数据库实现、基于 redis 实现、基于 zookeeper 实现。</li>
<li>分布式事务实现方式（保证主从数据库数据一致性的解决方法）<ul>
<li>XA（2PC）：二阶段提交，分投票阶段（prepare）和执行阶段（commit/rollback）</li>
<li>XA（3PC）：三阶段提交，分cancommit、precommit 和 docommit 三个阶段。相比 2pc，3pc 引入了超时机制，但依然没有解决数据不一致问题。</li>
<li>消息队列（如 RocketMQ）</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤器<ul>
<li>本质是一个很长的二进制向量和一系列随机映射函数（多次哈希）</li>
<li>优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难    </li>
</ul>
  <strong>使用场景</strong><ul>
<li>黑名单</li>
<li>单词拼写检查</li>
<li>Key-Value缓存系统的Key校验（结合缓存穿透）</li>
<li>ID校验，比如订单系统查询某个订单ID是否存在，如果不存在就直接返回。</li>
</ul>
</li>
<li>范式<br>  <strong>官方解释</strong><ul>
<li>第一范式 (1NF)：属性不可分</li>
<li>第二范式 (2NF)：每个非主属性完全函数依赖于键码</li>
<li>第三范式 (3NF)：非主属性不传递函数依赖于键码    </li>
</ul>
  <strong>通俗解释</strong><ul>
<li>第一范式 (1NF)：<ol>
<li>每一列属性都是不可再分的属性值，确保每一列的原子性</li>
<li>两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据</li>
</ol>
</li>
<li>第二范式 (2NF)：确保数据库表中的每一列都和主键相关。每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。</li>
<li>第三范式 (3NF)：数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a–&gt;b–&gt;c  属性之间含有这样的关系，是不符合第三范式的。</li>
</ul>
  <strong>例：</strong>比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话），这样一个表结构，就存在上述关系。 学号–&gt; 所在院校 –&gt; (院校地址，院校电话)。这样的表结构，我们应该拆开来，如下：（学号，姓名，年龄，性别，所在院校）–（所在院校，院校地址，院校电话）</li>
<li>为什么不用UUID做主键？<ul>
<li>不易于存储：UUID太长，有128位</li>
<li>信息不安全：基于MAC地址生成UUID的算法可能导致MAC地址泄露</li>
<li>对于MySQL，UUID的无序性会导致数据位置频繁变动，影响性能</li>
</ul>
</li>
<li>为什么建表时加Not Null Default？<ul>
<li>不好比较，NULL是一种类型，比较时只能用is not null 和is null来进行比较，碰到运算符时，一律返回null</li>
<li>影响索引效率</li>
</ul>
</li>
<li>SQLite为什么不适合用在大型项目上<ul>
<li>并发低</li>
<li>写入慢</li>
<li>在大数据量的情况下表现差</li>
<li>为已有的表加索引较慢</li>
</ul>
</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p><strong>知识点</strong></p>
<ul>
<li>MySQL 的 InnoDB 存储引擎和 MyISAM 存储引擎比较</li>
<li>MySQL 的主从复制</li>
</ul>
<p><strong>详细</strong></p>
<ul>
<li>MySQL处理死锁的方法：过期策略（等待超时）、检测消除策略（根据事务和锁的方向判断是否有环来检测，通过回滚解除死锁）</li>
<li>MySQL宕机如何恢复（简版）<ul>
<li>LSN(Log Sequence NO)：日志号，一个递增的64位整数，一个LSN表示一个（redo）Log结构。</li>
<li>CHECKPOINT：表示一个时间点，在CHECKPOINT LSN之前的更改都已经保存到了持久存储。恢复时只需从最后一个CHECKPOINT LSN开始。    </li>
</ul>
  <strong>恢复过程</strong><ol>
<li>定位到最近的一个checkpoint；</li>
<li>分析redo log，标识出未提交的事务</li>
<li>顺序执行redo log</li>
<li>rollback未提交的事务</li>
</ol>
</li>
<li>为什么 MySQL 有 binlog，还有 redolgo？<ul>
<li>这个是因为MySQL体系结构的原因，MySQL是多存储引擎的，不管使用那种存储引擎，都会有binlog，而不一定有redo log，简单的说，binlog是MySQL Server层的，redo log是InnoDB层的。    </li>
</ul>
  <strong>对于一条写语句，innodb 在 commit 时的执行顺序如下：</strong><ul>
<li>会话发起 COMMIT 动作</li>
<li>存储引擎层开启[Prepare]状态：在对应的 Redo 日志记录上打上 Prepare 标记</li>
<li>写入 binlog 并执行 fsync(刷盘)</li>
<li>在 redo 日志记录上打上 COMMIT 标记表示记录提交完成</li>
</ul>
</li>
<li>mysql 和 redis 的区别：<ul>
<li>mysql 是关系型数据库，redis 是非关系型的内存键值数据库；</li>
<li>redis 是内存数据库，而mysql是存储在磁盘的，因此对于更大规模的数据，mysql 更适用；</li>
<li>redis 的 key-value 值的查询速度高于 mysql，因此适合用作缓存。</li>
</ul>
</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><strong>知识点</strong></p>
<ul>
<li>redis 的数据类型、数据结构</li>
<li>redis 的 8 种数据淘汰策略</li>
<li>redis 的两种数据持久化方法</li>
</ul>
<p><strong>详细</strong></p>
<ul>
<li>redis的字符串是如何实现的？<ul>
<li>redis构建了一个简单动态字符串（Simple Dynamic String），简称SDS。里面包含三个变量：len（字符串长度）、free（空闲未使用的长度）、buf[]（字符数组）</li>
<li>SDS可动态扩展，在追加新字符串时，会做以下两步：<ol>
<li>计算free空间大小是否足够</li>
<li>若不够，则开辟空间至满足所需大小，分以下两种情况讨论：<ul>
<li>若len &lt; 1M，则开辟大小len长度的空闲空间；</li>
<li>否则，开辟1M的空闲空间</li>
</ul>
</li>
</ol>
</li>
</ul>
  <strong>redis字符串的性能优势</strong><ul>
<li>快速获取字符串长度</li>
<li>避免缓冲区溢出</li>
<li>降低空间分配次数提升内存使用效率</li>
</ul>
</li>
<li>缓存穿透、缓存击穿和缓存雪崩<br>  <strong>缓存穿透</strong><ul>
<li>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求</li>
<li>解决方法：使用布隆过滤器或缓存空对象</li>
</ul>
  <strong>缓存击穿</strong><ul>
<li>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，引起数据库压力瞬间增大</li>
<li>解决方法：访问数据库时对key加互斥锁</li>
</ul>
  <strong>缓存雪崩</strong><ul>
<li>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。</li>
<li>解决方法：缓存数据的过期时间设置随机；如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中；访问数据库加互斥锁</li>
</ul>
</li>
</ul>
<hr>
<h1 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/sort-algorithms/euivj1/">排序算法全解析</a></p>
</blockquote>
<h2 id="需要注意的对比"><a href="#需要注意的对比" class="headerlink" title="需要注意的对比"></a>需要注意的对比</h2><ol>
<li>三种O(n2)时间复杂度和三种O(nlogn)时间复杂度排序算法的比较</li>
<li>计数排序、基数排序和桶排序</li>
</ol>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p>数组和链表的区别</p>
<ul>
<li>数组大小固定，链表大小可动态扩展</li>
<li>数组在内存中是顺序存储的，链表不一定</li>
<li>数组可通过下标访问，访问效率高；链表除了两端结点，都需要通过遍历访问元素，访问效率低</li>
<li>数组从栈上分配内存，链表从堆上分配内存</li>
</ul>
</li>
<li><p>异或运算的特点</p>
<ul>
<li>任何数和自身异或的结果为0</li>
<li>0和任何数异或的结果为该数</li>
</ul>
</li>
<li><p>栈和堆的区别</p>
<ul>
<li>栈由系统自动分配，堆是人为申请开辟</li>
<li>栈由系统分配，分配速度较快，堆分配速度较慢</li>
<li>栈获得的空间较小，堆获得的空间较大</li>
<li>栈是连续的存储空间，堆是不连续的空间（地址空间连续，物理存储空间不连续）</li>
<li>栈一般存放基本类型的变量或对象的引用变量；堆一般存储new创建的数组或对象</li>
</ul>
</li>
<li><p>2的31次方=2147483648</p>
</li>
</ol>
<hr>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><ol>
<li><p>一个日志有用户登入登出时间，求该日志覆盖的时间段里同时在线人数的峰值</p>
<ul>
<li>创建时间数组，遍历log，若该条数据的登入登出时间在某个时间段内，则将该时间段内对应的数组元素的值+1</li>
</ul>
</li>
<li><p>有一个10G的url黑名单，要你判断当前url是否存在于黑名单中</p>
<ul>
<li>使用布隆过滤器</li>
</ul>
</li>
</ol>
<h1 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h1><ol>
<li><p>小明有100根香蕉，他离家50米。小明一次最多能背50根香蕉，但他每走一米要吃掉一根香蕉，那么小明最多能背回家多少根香蕉？<br><strong>答：</strong>设小明走了x米后停下，回去取剩下的50根香蕉，则小明再折回x处时，总共剩下的香蕉需小于等于50，方可一次背回家中，故得到方程：（50-2x + 50-x）&lt;= 50，解得x=17，那么50-17*2 = 16根</p>
</li>
<li><p>记a = x + y, b = xy, 求xn + yn</p>
<ul>
<li>记rn = xn + yn，则rn = ar(n - 1) - br(n - 2);</li>
<li>n相关的都是幂</li>
</ul>
</li>
</ol>
<hr>
<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>您好，我叫邹润鑫。本科在南京理工大学 - 材料科学与工程学院就读，获学士学位；目前在北京大学软件与微电子学院就读研二。<br>我于 2021.07 - 2022.01 在字节跳动实习，主要做广告实时数据架构相关，较了解 kafka、flink 等工具。<br>研二时参加北京大学“挑战杯”比赛，参赛项目是“基于深度学习的颈椎操训练”小程序，我负责后端开发，获二等奖。<br>主要使用 java 语言。大概是这些，谢谢。</p>
<hr>
<h1 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h1><p>字节跳动（2021.07.05 - 2022.01.21）</p>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/%E5%AE%9E%E4%B9%A0_1.jpg" class="" title="核心链路架构图">
<h2 id="sss-任务迁移-flink"><a href="#sss-任务迁移-flink" class="headerlink" title="sss 任务迁移 flink"></a>sss 任务迁移 flink</h2><blockquote>
<p>基本背景：待迁移的是三个 spark 引擎核心粒度（ad、adv、creative）聚合任务，迁至 flink streaming 引擎。<br>请求 flink 同学新支持 feature：将 map 类型字段（metric_data）在 sink kafka 时展开。</p>
</blockquote>
<p><strong>验数</strong><br>新 feature 存在问题时：flink 任务各指标统计比 spark 多 30% - 50%。<br>解决办法：</p>
<ol>
<li>新建另一不带 feature 的 flink 任务，与 spark 对比验数，值对齐，但开会和 flink 同学讨论，不认可结果；</li>
<li>去掉带 feature flink 任务的新 feature，与 spark 对比验数，值对齐；重新添加 feature，值不对齐。flink 同学认可结果，修复上线。<strong>（关键词：主观能动性、问题复现）</strong></li>
</ol>
<p>问题原因：新 feature 在反序列化过程中复⽤了上⼀条数据 map 的 json node。但因为⼴告数据每个 map 的 key 不完全⼀样，因此导致下⼀条数据反序列化时会带上上⼀条数据的 key 值。</p>
<p><strong>flink 反压</strong><br>上线 creative 粒度（粒度最细）聚合任务时，flink 任务反压明显，表现为输出算子的 inpool 利用率极高；<br>解决办法：调大输出算子并发度 parallelism，由 30 -&gt; 50。（最初 30 的确定，是为了 kafka 攒 batch）。并发度低，输出算子压力大。</p>
<p><strong>logstash 输出乱序问题</strong></p>
<blockquote>
<p>任务上线后，发现数据和真实的对不上。有两个小时对不上，这两个小时里各有一次上线，因此猜测是上线导致。</p>
</blockquote>
<p>原因猜测：logstash 并发读数据时，因为各线程消费数据后处理速度有快有慢，若先消费数据的后处理完，则某指标的小数值将覆盖大数值，导致数变小。<br>解决办法：logstash 写 es 时，新增 version 字段。每次写 es 前会对比该字段（同一 doc_id)，若值比 es 中的要小，则丢弃。（es 中 doc_id 是主键）</p>
<h2 id="pre-agg-spark-迁-flink"><a href="#pre-agg-spark-迁-flink" class="headerlink" title="pre_agg spark 迁 flink"></a>pre_agg spark 迁 flink</h2><blockquote>
<p>基本背景：待迁移的是 pre_agg_common 和 pre_agg_core 两个任务，由 spark streaming(1.5min 聚合) 迁至 flink streaming(1min 聚合) 引擎，聚合字段使用的是数据进来时新添加的处理时刻 process_time。<br>请求 flink 同学支持新 feature：flink sql 的无状态聚合。</p>
</blockquote>
<p><strong>为什么需要无状态聚合：</strong>pre_agg 任务的目的是减少数据量，降低下游维度拼接任务的输入 qps；且下游有各粒度聚合任务，因此必须保证每条聚合输出的数据彼此无关联。<br><strong>无状态聚合基本原理：</strong>每次 cp 不记录聚合状态，只记录 commit offset，如此，每次聚合都是从 0 开始。<br><strong>迁 flink 过程遇到的问题：</strong>无状态聚合 feature 没有问题，但任务若需要新增减维度，则需要切 checkpoint，但我们需要的是不切 checkpoint。<br><strong>为什么需要不切 cp：</strong>若切了 cp，在任务停止和重新启动成功的这段时间里，可能存在数据丢失。因为没有上次 cp 的 commit offset 保存，则会从 kafka 最新消息处开始消费，因此导致数据丢失。</p>
<p><strong>原来是怎么做到的：切 cp，流程如下：</strong></p>
<ol>
<li>主 spark 任务在某时刻停止产出；</li>
<li>备 spark 任务在某时刻开始产出，该时刻与主 spark 任务停止产出时刻相同；同时设置另一停止产出时刻；切 checkpoint；</li>
<li>备 spark 任务停止，启动主 spark 任务。主 spark 任务和备 spark 任务的 cp 相同。<br> <strong>为什么 flink 不用这个方式切 cp：因为 flink 任务不支持指定 checkpoint 存储地址，存储地址依据任务名自动生成。同时也解释了为什么不用核心粒度聚合任务切 cp 的方式。</strong></li>
</ol>
<p><strong>目前的解决办法：</strong>聚合的维度使用 concat 拼接成一个字段，在 select 时用 first_value() 方法选 key 的各维度第一个值。</p>
<p><strong>补充：核心粒度聚合任务切 cp 流程：</strong></p>
<ol>
<li>设置主 flink 任务停止产出时间；</li>
<li>设置备 flink 任务开始产出时间，与主 flink 任务停止产出时间一致；新增备 flink 任务停止产出时间；切 checkpoint；</li>
<li>设置主 flink 任务开始产出时间，与备 flink 任务停止产出时间一致，启动主 flink 任务；切 cp；<br>因为是 1 小时聚合，使用的字段 monitor_ts 是整点的（不含分秒），因此即使任务不是整点上线，group by tumble(monitor_ts, INTERVAL 1 HOUR)，但基于字段形成的 1 小时窗口，仍是整点的。因此整点切换 cp 是没有问题的。</li>
</ol>
<h1 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h1><h2 id="挑战杯"><a href="#挑战杯" class="headerlink" title="挑战杯"></a>挑战杯</h2><ol>
<li><p>Flask + SQLAlchemy + MySQL的颈椎操——挑战杯项目<br><strong>介绍项目</strong></p>
<ul>
<li>我们的项目是一个叫“轻松颈椎操”的微信小程序，因为目前现代人看电脑和手机的时间很长，颈椎负担比较大，因此开发这个小程序，人们可以按照小程序上的提示进行颈椎操的锻炼，保护颈椎。这个小程序大概实现以下功能：用户登录进入小程序后，首先进入训练室页面（这也是我们的主界面），在训练室界面会展示可选的颈椎操项目，用户点击任意一个项目，会进入颈椎操视频教学的播放界面，用户按照视频教学进行颈椎锻炼。此外，每个用户有自己的个人信息界面和打卡记录界面，并可以查看自己的历史得分记录。</li>
</ul>
<p><strong>算法策略</strong></p>
<ul>
<li>服务端获取用户的训练视频，每120帧选取一帧存储，将存储的图片传入百度api，获取各个肢体部位的坐标（选择了眼、耳、鼻、下颌、手肘和手腕），将坐标画图连线，计算夹角，与同一时刻前后5秒的所有标准图片的夹角比较计算得分，其中的最高分即为该肢体动作的得分，最后返回所有动作得分的标准差</li>
</ul>
<p><strong>可以改进的地方？</strong></p>
<ul>
<li>使用token提高安全性，token由用户的user_id+服务端密钥结合，通过hash算法计算得到，在用户登录成功后返回给前端；前端每次调用接口，均需携带token验证身份；token需设置有效期，如3小时；在有效期内，用户再次登录小程序时，服务端只需验证token即可，无需再请求wx服务端获取openid验证身份，减少用户进入小程序的等待时长</li>
<li>使用redis数据库缓存token，加快身份认证过程</li>
</ul>
<p><strong>开发过程遇到的困难？</strong></p>
<ul>
<li>微信的登陆：查看了wx的小程序开发者文档，登陆流程大致如下：用户进入小程序时，前端会获取到此次登陆的code，传入服务端，服务端根据该code，结合自己的appid和secret，调用wx.login()查询用户的openid，最后服务端根据该openid获取用户在数据库中的数据</li>
<li>原先计划在controller层同时实现逻辑处理和数据库操作，但想着每一份代码都会因此较为庞大，重用性和可维护性不强，就想结合自己曾学过的MVC框架将其分了层，分为了controller和dao层，dao层负责数据库处理，controller层负责逻辑处理</li>
<li>登陆功能上，区分了三类用户：老用户、新用户和游客，老用户在查询数据库的时候即可获取数据，新用户和游客则需在user_info和user_record表上插入新纪录，游客和新用户的区别是是否授权给小程序，若授权，则在user_info表上较游客多了头像和昵称信息</li>
<li>打分上，在计算出得分后，不仅在user_score表插入新纪录，同时需更新user_record表和day_times表，user_record表表中参数有total_times、total_days和continuous_days，total_times需加1；total_days和continuous_days根据当天是否已更新该参数决定是否更新，实现思路是：找到该用户的user_record记录，根据update_date和当天的日期差是否大于1来决定是否更新；day_times表存储的是用户每天的锻炼次数，根据当天是否已有记录，来决定当天是添加记录还是将记录值+1。</li>
<li>sqlchemy的queery返回的是对象的list，但前端需要的是数据字典的list，因此在每个dao文件内新增了to_dict()函数将对象转化为dict</li>
</ul>
<p><strong>对flask的理解？</strong><br>因为这是我第一次接触python的web应用程序开发，flask是学长选择和配置的，因此理解不深，主要是开发过程中遇到的问题时，在解决过程中产生一些体会，比如说：</p>
<ul>
<li>app.py是应用程序的入口，该入口在启动时会调用主目录下的__init__.py文件，因此在该py文件下需导入sqlalchemy的model文件和controller里的文件，以构造数据库表和路由准备。</li>
<li>该__init__.py文件下的build_sample_db()语句每次会刷新数据库，因此在model无更改的情况下应注释掉，否则数据库数据会被刷新（即消失）</li>
</ul>
<p><strong>对sqlalchemy的理解？</strong></p>
<ul>
<li>sqlalchemy是一个有名的ORM框架，实现了关系型数据库的表结构到python类对象的映射。对表记录的操作可以转变为对类对象的操作，加快了开发速度。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><p><strong>2021/6/3周四下午四点，字节跳动广告研发部门后端一面（约50mins）</strong><br><strong>计算机网络</strong></p>
<ol>
<li>分别介绍一下OSI的七层网络模型</li>
<li>ip在那一层，ipv4和ipv6的区别</li>
<li>TCP的三次握手过程</li>
</ol>
<p><strong>操作系统</strong></p>
<ol>
<li>简单介绍一下进程和线程</li>
<li>线程通信方式</li>
<li>介绍死锁，举个简单例子</li>
</ol>
<p><strong>Java</strong></p>
<ol>
<li>三大特性，编译时多态和运行时多态的区别</li>
<li>重写和重载</li>
<li>Java的“==”和equals的区别</li>
<li>equals的执行过程</li>
<li>String为什么要用final修饰</li>
<li>StringBuilder和StringBuffer</li>
<li>10万字符的拼接用String还是StringBuilder，为什么用StringBuilder（因为会不断创建String对象）</li>
<li>Java支持多继承吗</li>
<li>抽象类和接口的区别</li>
<li>Synchronized的作用</li>
<li>Java的线程池类型</li>
</ol>
<p><strong>Mysql</strong></p>
<ol>
<li>索引的数据结构</li>
<li>b+树和b树的区别</li>
<li>简单讲一下事务（事务的四大特性）</li>
<li>事务的隔离级别，分别解决了什么问题</li>
<li>举个脏读的例子，那幻读呢</li>
<li>Mysql的两种存储引擎，区别</li>
</ol>
<p>一道sql题：表里有四列，id、name、class、score，找到各班的成绩最高的同学，返回name、class和score（“没啥问题”，其实有问题）<br>一道层序遍历，手撕TreeNode结点</p>
<p><strong>2021/6/9周四下午五点，字节跳动广告研发部门后端二面（43mins）</strong></p>
<ol>
<li>问项目，提建议</li>
<li>索引的作用</li>
<li>索引的数据结构</li>
<li>事务是什么</li>
<li>Java中的staic、final的作用</li>
<li>HashMap的线程安全的类</li>
</ol>
<p>一道删除链表重复结点题<br>一道查找二叉树的所有路径的题<br>（全程很着急）</p>
<p><strong>2021/6/18周五下午4点，字节跳动广告研发部门后端三面（53mins）</strong></p>
<ol>
<li>win如何查看进程、线程</li>
<li>进程一定会有线程吗</li>
<li>进程和线程的区别</li>
<li>多进程和多线程的区别</li>
<li>多进程什么情况下应用、多线程的应用场景</li>
<li>线程挂掉进程挂掉吗</li>
<li>子进程挂掉父进程会挂掉吗</li>
<li>为什么用flask，flask的特点</li>
<li>项目用了get还是post，它俩的区别</li>
<li>如何理解get方法用来获取资源、post传输资源</li>
<li>什么情况必须用get、post</li>
<li>了解header吗</li>
<li>请求头的信息，不是包头</li>
<li>返回前端json，有约定返回格式</li>
<li>cookie存在哪里</li>
<li>请求头有哪些</li>
<li>常见的返回状态码</li>
<li>永久性重定向和临时性重定向的区别、使用场景</li>
<li>用过什么数据结构</li>
<li>用栈的场景</li>
<li>JVM的栈溢出、堆溢出</li>
<li>栈、堆存储什么类型的数据</li>
<li>为什么基本类型数据用栈存储</li>
<li>实现一个栈 —— 代码：实现pop()、push()、getMin()，保持栈元素相对位置不变</li>
</ol>
<p><strong>2021/6/18周五下午六点，字节跳动广告研发部门hr面（53mins）</strong></p>
<ol>
<li>目前还有其他面试吗</li>
<li>为什么选择快手</li>
<li>你怎么看字节跳动这家公司</li>
<li>每周能做到全勤吗</li>
</ol>
<p>反问：如果顺利入职，我需要准备那些方面的内容</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/31/%E9%80%89%E8%B0%83%E7%9B%B8%E5%85%B3/"><img class="prev-cover" src="/img/beijing.jpg" onerror="onerror=null;src='/img/touxiang.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">选调相关</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/05/Java/"><img class="next-cover" src="/img/beijing.jpg" onerror="onerror=null;src='/img/touxiang.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Java</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zourunxin"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">勤加注释！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E4%B8%80%E5%8F%A5%E7%AD%94%E4%B8%80%E5%8F%A5%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%87%AA%E9%A1%BE%E8%87%AA%E7%AD%94"><span class="toc-text">面试问一句答一句，不要自顾自答</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode"><span class="toc-text">Leetcode</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%88%AC"><span class="toc-text">一般</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%EF%BC%88dfs%EF%BC%89"><span class="toc-text">递归（dfs）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%EF%BC%88backTrack%EF%BC%89"><span class="toc-text">回溯（backTrack）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-text">广度优先遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">反转链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-text">树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-text">图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E9%95%BF%E5%BA%A6%EF%BC%88%E4%B8%8D%E8%A6%81%E6%B1%82%E8%BF%9E%E7%BB%AD%EF%BC%89"><span class="toc-text">无序数组计算最长递增子序列长度（不要求连续）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95"><span class="toc-text">经典算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">0-1 背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-text">编辑距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%A6%82%E7%8E%87%E6%B1%82-Pi"><span class="toc-text">通过概率求 Pi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%B3%95"><span class="toc-text">高精度法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2"><span class="toc-text">柱状图中最大矩形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E5%8C%BA%E9%97%B4%E5%92%8C%E4%B8%8E-M-%E6%95%B4%E9%99%A4%E7%9A%84%E5%8C%BA%E9%97%B4%E4%B8%AA%E6%95%B0"><span class="toc-text">数组中找出区间和与 M 整除的区间个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95"><span class="toc-text">蓄水池算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-text">网络基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E7%B3%BB%E7%BB%9F"><span class="toc-text">一般系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java"><span class="toc-text">Java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%AF%86"><span class="toc-text">通识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL"><span class="toc-text">MySQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">需要注意的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-text">思考题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E5%8A%9B%E9%A2%98"><span class="toc-text">智力题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86"><span class="toc-text">实习经历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sss-%E4%BB%BB%E5%8A%A1%E8%BF%81%E7%A7%BB-flink"><span class="toc-text">sss 任务迁移 flink</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pre-agg-spark-%E8%BF%81-flink"><span class="toc-text">pre_agg spark 迁 flink</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87"><span class="toc-text">项目准备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%91%E6%88%98%E6%9D%AF"><span class="toc-text">挑战杯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E7%BB%8F"><span class="toc-text">面经</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/01/26/%E9%87%91%E8%9E%8D%E6%9C%AF%E8%AF%AD/" title="金融术语">金融术语</a><time datetime="2022-01-26T05:47:08.000Z" title="Created 2022-01-26 13:47:08">2022-01-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/01/23/hello-world/" title="Hello World">Hello World</a><time datetime="2022-01-23T14:49:13.969Z" title="Created 2022-01-23 22:49:13">2022-01-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/01/19/%E7%94%9F%E6%B4%BB%E6%94%BB%E7%95%A5/" title="生活攻略">生活攻略</a><time datetime="2022-01-19T02:39:43.000Z" title="Created 2022-01-19 10:39:43">2022-01-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/01/18/%E4%B9%B0%E4%B9%B0%E4%B9%B0%E6%94%BB%E7%95%A5/" title="买买买攻略">买买买攻略</a><time datetime="2022-01-18T14:52:34.000Z" title="Created 2022-01-18 22:52:34">2022-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/25/%E8%AF%BE%E7%A8%8B/" title="课程">课程</a><time datetime="2021-10-25T05:20:25.000Z" title="Created 2021-10-25 13:20:25">2021-10-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div></div></body></html>