<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="准备 leetcode的《校招基础知识讲解》leetcode的《计算机网络面试突击》leetcode的《Java面试突击》leetcode的《排序算法全解析》以下内容是基于以上书籍的总结和补充：  计算机网络需要注意的对比 http的九种请求方法 get和post方法的对比（六种） http和https的请求过程 http和https的对比（http的缺点，https的缺点） http1.1的新特">
<meta property="og:type" content="article">
<meta property="og:title" content="面试">
<meta property="og:url" content="http://example.com/2021/05/03/%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="准备 leetcode的《校招基础知识讲解》leetcode的《计算机网络面试突击》leetcode的《Java面试突击》leetcode的《排序算法全解析》以下内容是基于以上书籍的总结和补充：  计算机网络需要注意的对比 http的九种请求方法 get和post方法的对比（六种） http和https的请求过程 http和https的对比（http的缺点，https的缺点） http1.1的新特">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-05-03T07:37:48.000Z">
<meta property="article:modified_time" content="2021-09-23T04:23:33.280Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://example.com/2021/05/03/%E9%9D%A2%E8%AF%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-23 12:23:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-05-03T07:37:48.000Z" title="Created 2021-05-03 15:37:48">2021-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-09-23T04:23:33.280Z" title="Updated 2021-09-23 12:23:33">2021-09-23</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook">leetcode的《校招基础知识讲解》</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/">leetcode的《计算机网络面试突击》</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/java-interview-highlights/">leetcode的《Java面试突击》</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/sort-algorithms/euivj1/">leetcode的《排序算法全解析》</a><br>以下内容是基于以上书籍的总结和补充：</p>
</blockquote>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="需要注意的对比"><a href="#需要注意的对比" class="headerlink" title="需要注意的对比"></a>需要注意的对比</h3><ol>
<li>http的九种请求方法</li>
<li>get和post方法的对比（六种）</li>
<li>http和https的请求过程</li>
<li>http和https的对比（http的缺点，https的缺点）</li>
<li>http1.1的新特性，http2.0的新特性</li>
<li>cookie和session的对比（三点）</li>
<li>TCP粘包问题及解决方法</li>
<li>http请求用到的协议</li>
<li>路由算法</li>
<li>http五类状态码和9个状态码</li>
<li>再看一遍HTTP/3</li>
</ol>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li><p>TCP四次挥手过程中的CLOSED_WAIT和TIME_WAIT：<br>服务器在收到客户端发送的FIN报文并回答了ACK报文后，会进入CLOSED_WAIT状态，以保证服务器在关闭连接之前将待发送的数据发送完成。<br>客户端在收到服务器发送的FIN报文并回答了ACK报文后，会进入TIME_WAIT状态。TIME_WAIT本质是一个2MSL的计时器，MSL（Maximum Segment Lifetime）指一段 TCP 报文在传输过程中的最大生命周期。2MSL是为了确保服务器已经收到了客户端发送的ACK确认报文。<br>TIME_WAIT状态可能导致的问题：在高并发短连接的业务场景中，服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的处在TIME_WAIT状态的连接，服务器维护每个连接都需要一个socket。也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。<br>解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。</p>
</li>
<li><p>HTTPs<br>HTTPs是以安全为目标的HTTP通道，在http的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPs在HTTP的基础下加入SSL/TLS协议</p>
<p><strong>加密算法：</strong></p>
<ul>
<li>对称加密算法</li>
<li>非对称加密算法</li>
<li>哈希算法</li>
</ul>
</li>
<li><p>四层负载均衡和七层负载均衡<br>四层负载均衡：是通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器与请求客户端建立TCP连接，然后发送Client请求的数据。<br>七层负载均衡：也称内容交换，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的服务器。七层负载均衡服务器起了一个代理服务器的作用<br><strong>区别：</strong></p>
<ul>
<li>四层负载服务器不需要和客户端建立TCP连接，但七层负载服务器需要，并起到了代理服务器的作用。</li>
<li>七层负载服务器可以有效防止SYN Flood攻击，使网站更安全</li>
<li>七层负载服务器使整个网络更“智能化”，能把对图片类的请求转发到图片服务器并可以使用缓存技术，对文字的请求转发到文字服务器并可以使用压缩技术</li>
</ul>
</li>
<li><p>DNS解析过程</p>
<ul>
<li>在浏览器中输入域名后，浏览器首先检查缓存中是否有该域名解析过的ip地址，若有，解析结束</li>
<li>若没有，浏览器会到操作系统缓存中（即hosts文件）查看是否有该域名对应的ip地址，若命中，解析结束；</li>
<li>若没有找到，就会请求本地域名服务器来解析，一般情况下解析到这步就完成了</li>
<li>若还没有，本地域名服务器则会迭代查询（一般情况下）根域名服务器，顶级域名服务器和权限域名服务器，找到目标ip，缓存和返回给用户，解析结束</li>
</ul>
</li>
<li><p>客户端和服务器是如何建立连接的<br>通过socket。socket作为一种通信机制，可用于对ip地址和端口号进行描述。一般过程大概如下：服务端至少两个socket，其中一个用于接受客户端发来的连接请求，并不负责与客户端通信。每当服务器成功接受客户端的请求时，在服务器端会创建一个与客户端进行通信的socket。在客户端，通过创建一个socket对象对TCP连接初始化</p>
</li>
<li><p>TCP和UDP的区别</p>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/3.png" class="">
<ul>
<li>TCP保证可靠交付（序列号和确认、超时重传、流量控制、拥塞控制），UDP尽最大努力交付，可靠性由应用层保证</li>
<li>TCP仅支持一对一通信，UDP支持一对一、一对多、多对一和多对多通信</li>
</ul>
</li>
<li><p>HTTP/2.0的多路复用</p>
<ul>
<li>HTTP/1.1：虽然实现了长连接和流水线，服务端能接收多个请求，但在响应过程中，服务端是顺序（串行）发送响应报文的，若某一报文阻塞，则后续已经准备好的报文同样会被阻塞无法发送，导致响应效率降低</li>
<li>HTTP/2.0：实现了多路复用，二进制帧头对所在流进行了标识，在客户端收到后可根据标识进行拼接。因此在服务端可实现并行发送响应</li>
</ul>
</li>
<li><p>数字证书的内容</p>
<ul>
<li><p>证书的版本信息；</p>
</li>
<li><p>证书的序列号，每个证书都有一个唯一的证书序列号；</p>
</li>
<li><p>证书所使用的签名算法；</p>
</li>
<li><p>证书的发行机构名称，命名规则一般采用X.500格式；</p>
</li>
<li><p>证书的有效期，通用的证书一般采用UTC时间格式；</p>
</li>
<li><p>证书所有人的名称，命名规则一般采用X.500格式；</p>
</li>
<li><p>证书所有人的公开密钥；</p>
</li>
<li><p>证书发行者对证书的签名。</p>
</li>
</ul>
</li>
<li><p>HTTP/3</p>
<ul>
<li>HTTP/3 是在 QUIC 基础上发展起来的，其底层使用 UDP 进行数据传输，上层仍然使用 HTTP/2。在 UDP 与 HTTP/2 之间存在一个 QUIC 层，其中 TLS 加密过程在该层进行处理。</li>
</ul>
</li>
<li><p>客户端最多与服务器同时建立多少个TCP连接<br><strong>背景：</strong>网络通信过程中服务端监听一个固定的端口,客户端主动发起连接请求后要经过三次握手才能与服务器建立起一个tcp连接    </p>
<ul>
<li>客户端每次发起一个tcp连接时,系统会随机选取一个空闲的端口,该端口是独占的不能与其他tcp连接共享,因此理论上一台机器有多少空闲的端口,就能对外发起多少个tcp连接</li>
<li>根据tcp/ip协议,端口port使用16位无符号整数unsigned short来存储,因此本地端口一共有2^16=65536个,即0-65535,其中0~1023是预留端口,0有特殊含义不能使用,1024以下端口都是超级管理员用户(如root)才可以使用,因此就算使用root权限,一台机器最多能使用的端口也只有65535个</li>
<li>但实际上linux限制了可使用端口号区间为[32768, 60999]，即实际对外可建立的连接默认最大只有28232个</li>
</ul>
<p><strong>服务端最多可建立连接数</strong></p>
<ul>
<li>因为受服务器资源、操作系统的限制,linux内核默认文件描述符最大值是1024,也就是说默认支持最大并发连接是1024个</li>
</ul>
</li>
<li><p>TCP攻击</p>
<ul>
<li>Flood攻击：如发送海量的SYN报文，请求连接而又不建立连接</li>
<li>连接耗尽攻击：TCP三次握手建立连接后不再发送报文一直维持连接，消耗TCP连接资源</li>
</ul>
<p><strong>如何防范SYN泛洪攻击</strong></p>
<ul>
<li>降低SYN timeout，使主机尽快释放半连接及其占用的资源；</li>
<li>设置SYN cookie，如果短时间内收到了某个IP的重复SYN请求，我们就可以认为受到了攻击</li>
</ul>
</li>
<li><p>TCP半连接队列和全连接队列</p>
<ul>
<li>半连接队列：也称SYN队列，客户端发来SYN连接请求时，服务端会把该连接存储到半连接队列</li>
<li>全连接队列：也称accept队列，第三次握手时服务端接收到客户端发来的ACK后，内核会将半连接移除，然后创建全新的连接，将其添加到accept队列。</li>
</ul>
<p><strong>TCP/IP协议中，listen()、connect()和accept()函数和三次握手间的关系</strong></p>
<ul>
<li>服务器调用listen监听特定端口号</li>
<li>客户端调用connect来请求与服务端通过三次握手建立TCP连接</li>
<li>服务器的listen()函数负责三次握手的交互过程。连接建立后，往accept队列中添加一个成功的连接。</li>
<li>服务器调用accept()从accept队列中取出一条成功的tcp连接</li>
</ul>
</li>
<li><p>UDP如何保证可靠性</p>
<ul>
<li>有序性：添加序列号</li>
<li>丢包：确认和超时重传</li>
<li>协议字段：标识当前使用的协议</li>
</ul>
</li>
<li><p>Unicode 和 UTF-8 有何区别</p>
<ul>
<li>Unicode 是「字符集」，UTF-8 是「编码规则」</li>
<li>广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和 UTF-8、UTF-16、UTF-32 等等编码……</li>
</ul>
<p><strong>其中</strong></p>
<ol>
<li>字符集：为每一个「字符」分配一个唯一的 ID（学名为码位/码点/Code Point）</li>
<li>编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）</li>
</ol>
</li>
<li><p>OSI七层网络模型和各层协议</p>
<ul>
<li>应用层：通过应用程序间的交互来完成特定的网络应用。有DNS协议、HTTP协议、DHCP协议、FTP协议、SMTP、POP3、IMAP协议</li>
<li>表示层：使通信的应用程序能够解释交换数据的含义。（编码和解码）</li>
<li>会话层：负责建立、管理和终止表示层实体之间的通信会话。</li>
<li>传输层：为两台主机进程之间的通信提供服务。有TCP、UDP协议</li>
<li>网络层：选择合适的网间路由和交换节点，确保数据按时成功传送。有IP协议、ICMP协议</li>
<li>数据链路层：将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。有CSMA/CD协议、ARP协议（ARP缓存表存在内存里）、PPP协议</li>
<li>物理层：实现计算机节点之间比特流的透明传送</li>
</ul>
<p><strong>OSI七层网络模型和TCP/IP网络模型</strong></p>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/7.jpg" class=""></li>
<li><p>TLS 握手详细过程</p>
<ul>
<li>“client hello”消息：客户端通过发送”client hello”消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个”client random”随机字符串。</li>
<li>“server hello”消息：服务器发送”server hello”消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和”server random”随机字符串。</li>
<li>验证：客户端对服务器发来的证书进行验证，确保对方的合法身份。</li>
<li>“premaster secret”字符串：客户端向服务器发送另一个随机字符串”premaster secret (预主密钥)”，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。</li>
<li>使用私钥：服务器使用私钥解密”premaster secret”。</li>
<li>生成共享密钥：客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 KEY。</li>
<li>客户端就绪：客户端发送经过共享密钥 KEY加密过的”finished”信号。</li>
<li>服务器就绪：服务器发送经过共享密钥 KEY加密过的”finished”信号。</li>
<li>达成安全通信：握手完成，双方使用对称加密进行安全通信。</li>
</ul>
</li>
<li><p>ipv4和ipv6的区别</p>
<ul>
<li>地址长度：ipv4的地址长度为32位（4bytes），ipv6的地址长度为128位（16bytes）</li>
<li>地址表示：ipv4地址用小数表示，ipv6地址用十六进制表示</li>
<li>包头大小：ipv4包头的基本大小是20bytes（可扩展40bytes），ipv6是40bytes</li>
<li>安全性：ipv6内置了IPsec，提供身份验证和加密。但在ipv4中是可选的，如果在适当的IPv4选项格式中实现AH和ESP头，IPv4也可以使用这种安全性功能</li>
</ul>
</li>
<li><p>DNS污染、DNS劫持</p>
<ul>
<li>DNS污染：指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。范例，访问Youtube、Facebook之类网站等出现的状况。</li>
<li>DNS劫持：就是指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。</li>
</ul>
</li>
</ol>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="需要注意的对比："><a href="#需要注意的对比：" class="headerlink" title="需要注意的对比："></a>需要注意的对比：</h3><ol>
<li>进程间的六种通信方式和线程间的三种通信方式</li>
<li>进程的六种调度算法</li>
<li>虚拟内存的六种页面置换算法</li>
<li>磁盘的三种磁盘调度算法</li>
<li>死锁的四个必要条件及解决的策略</li>
<li>再看一遍进程同步</li>
</ol>
<h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><ol>
<li><p>进程和线程</p>
<ul>
<li>进程是操作系统分配资源的基本单位,线程是CPU调度的基本单位</li>
<li>系统开销上：创建、切换和销毁进程都比创建、切换和销毁线程的开销要大</li>
<li>通信上：线程可通过共享进程内存空间实现通信，进程需借助IPC通信</li>
<li>一个进程由一个或多个线程组成（至少有一个线程），线程是一个进程中代码的不同执行路线</li>
<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；</li>
</ul>
<p><strong>为什么使用多线程而不是多进程</strong></p>
<ul>
<li>创建和销毁上：线程分配的资源少，效率更高</li>
<li>上下文切换上：线程切换较进程切换开销少</li>
</ul>
</li>
<li><p>虚拟内存<br>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而使程序拥有更大的可用内存。<br>操作系统将内存抽象成地址空间，每个程序用有自己的地址空间。这些地址空间被切割成一个个块，每一块称为一页，同时物理内存也被分割成相同大小的块，物理内存的块称为页框。页和页框存在映射关系，但无需将页映射到连续的物理内存，也无需全部映射到物理内存。在程序运行过程中，若所需的页不在内存中，同时内存中没有足够的空间存放新页，操作系统则会调用页面置换算法，将选择的页置换到磁盘，同时调入所需的页进入内存。</p>
</li>
<li><p>六种页面置换算法：</p>
<ul>
<li>最佳（OPT）</li>
<li>先进先出（FIFO）</li>
<li>第二次机会算法</li>
<li>最近最久未使用（LRU）</li>
<li>最近未使用（NRU)</li>
<li>时钟和改进时钟算法（CLOCK）</li>
</ul>
</li>
<li><p>协程：<br>又称微线程，有点像子程序，但在子程序执行过程中，可以产生中断，转而执行其它程序，待其他程序执行完毕后，转回来执行原来的程序。这一过程不是函数调用，也没有发生线程切换，因此效率极高。</p>
</li>
<li><p>逻辑地址到物理地址的转化<br>MMU从虚拟地址中根据页大小计算出页号，与页表寄存器的页表始址结合计算出页面中该页号的物理地址。若计算结果大于页表长度，则产生越界中断；否则取出该地址的页框号，与页面偏移量结合起来即为物理地址。</p>
</li>
<li><p>用户态和内核态<br>用户态：运行应用程序<br>内核态：运行操作系统程序，操作硬件</p>
<p><strong>区别：</strong></p>
<ul>
<li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其占有的处理器是可被抢占的</li>
<li>处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。</li>
</ul>
<p><strong>通常来说，以下三种情况会导致用户态到内核态的切换：</strong></p>
<ul>
<li>系统调用</li>
<li>异常</li>
<li>外围设备中断</li>
</ul>
</li>
<li><p>线程间通信方式：</p>
<ul>
<li>消息队列</li>
<li>全局变量</li>
<li>使用事件CEvent类实现</li>
</ul>
</li>
<li><p>进程切换和线程切换的区别<br>进程切换分两步：</p>
<ul>
<li>切换页目录以使用新的地址空间</li>
<li>切换内核栈和硬件上下文。<br>对于linux来说，线程和进程的最大区别就在于地址空间。<br>对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。所以明显是进程切换代价大</li>
</ul>
</li>
<li><p>虚拟内存的页和段的区别</p>
<ul>
<li>页的大小固定，段的大小可动态扩展</li>
<li>分页存在内存碎片，分段没有</li>
<li>分页地址是一维的，分段地址是二维的</li>
<li>分页透明，分段需要程序员显示的划分每个段</li>
</ul>
<p><strong>操作系统分页的好处：</strong></p>
<ul>
<li>是操作系统实现虚拟内存的基础</li>
<li>允许进程申请的内存空间不连续</li>
<li>减少内存碎片</li>
</ul>
<p><strong>分页为什么是一维的：</strong></p>
<ul>
<li>操作时给出地址，即可根据该地址计算出页号和页内偏移量（这得益于页大小是固定的），而不需要显示划分</li>
</ul>
</li>
<li><p>如何避免内核态和用户态的频繁切换</p>
<ul>
<li>减少线程切换。如使用无锁并发编程（CAS算法）、避免创建不必要的线程、使用线程</li>
<li>若是因为I/O导致的切换，则使用用户进程缓冲区，并结合使用预读和延迟写方法</li>
</ul>
</li>
<li><p>线程共享进程哪些资源，独有哪些资源</p>
<ul>
<li>共享：堆、全局变量、静态变量、文件等公共资源</li>
<li>不共享：栈、寄存器（进程的副本）</li>
</ul>
</li>
<li><p>fork函数</p>
<ul>
<li>fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，这两个进程可以做相同的事，但如果初始参数或传入的变量不同，两个进程也可以做不同的事</li>
<li>fork被调用后，返回给父进程子进程的进程id；返回给子进程0；如果出现错误，返回一个负值</li>
</ul>
</li>
<li><p>进程通信的管道类型：<br><strong>管道本质是FIFO文件</strong></p>
<ul>
<li>匿名管道：管道是半双工的，数据只能单向通信；需要双方通信时，需要建立起两个管道；只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。</li>
<li>命名管道：可在同一台计算机的不同进程之间或在跨越一个网络的不同计算机的不同进程之间，也仅支持半双工通信。</li>
</ul>
<p><strong>管道通信的缺点</strong></p>
<ul>
<li>仅支持半双工通信，要想全双工需要额外开一个管道</li>
<li>管道存在内存中，缓冲区有限</li>
<li>若管道已满，写进程会被阻塞；若管道已空，读进程会被阻塞</li>
</ul>
</li>
<li><p>IPC区别</p>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/2.png" class=""></li>
<li><p>单核cpu多任务下，单线程执行快还是多线程执行快</p>
<ul>
<li>如果是cpu密集型作业：单线程执行快，因为多线程切换会浪费cpu时间</li>
<li>如果是I/O密集型作业：多线程执行快，因为能充分利用线程阻塞期间cpu的时间</li>
</ul>
</li>
<li><p>线程挂掉后进程一定会挂吗？</p>
<ul>
<li>总体来说，线程没有独立的地址空间，如果崩溃，会产生SIGSEGV (Segmentation Violation/Fault)信号，如果没有错误处理的handler，OS一般直接杀死进程。</li>
<li>但就算是有handler了处理，一般也会导致程序崩溃，因为很有可能其他线程或者进程的数据被破坏了。</li>
</ul>
</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="需要注意的对比-1"><a href="#需要注意的对比-1" class="headerlink" title="需要注意的对比"></a>需要注意的对比</h3><ol>
<li>三种O(n2)时间复杂度和三种O(nlogn)时间复杂度排序算法的比较</li>
<li>计数排序、基数排序和桶排序</li>
</ol>
<h3 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h3><ol>
<li><p>数组和链表的区别</p>
<ul>
<li>数组大小固定，链表大小可动态扩展</li>
<li>数组在内存中是顺序存储的，链表不一定</li>
<li>数组可通过下标访问，访问效率高；链表除了两端结点，都需要通过遍历访问元素，访问效率低</li>
<li>数组从栈上分配内存，链表从堆上分配内存</li>
</ul>
</li>
<li><p>异或运算的特点</p>
<ul>
<li>任何数和自身异或的结果为0</li>
<li>0和任何数异或的结果为该数</li>
</ul>
</li>
<li><p>栈和堆的区别</p>
<ul>
<li>栈由系统自动分配，堆是人为申请开辟</li>
<li>栈由系统分配，分配速度较快，堆分配速度较慢</li>
<li>栈获得的空间较小，堆获得的空间较大</li>
<li>栈是连续的存储空间，堆是不连续的空间（地址空间连续，物理存储空间不连续）</li>
<li>栈一般存放基本类型的变量或对象的引用变量；堆一般存储new创建的数组或对象</li>
</ul>
</li>
<li><p>2的31次方=2147483648</p>
</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="需要注意的对比-2"><a href="#需要注意的对比-2" class="headerlink" title="需要注意的对比"></a>需要注意的对比</h3><ol>
<li>MySQL的InnoDB存储引擎和MyISAM存储引擎比较</li>
<li>数据库的事务四大特性、四种并发一致性问题和四个隔离级别</li>
<li>背下InnoDB（第8点）</li>
<li>索引优化</li>
<li>关系数据库设计理论</li>
<li>redis的数据类型、数据结构</li>
<li>redis的8种数据淘汰策略</li>
<li>redis的两种数据持久化方法</li>
<li>mysql的主从复制</li>
<li>再看一遍封锁</li>
<li>再看一遍MVCC</li>
<li>再看一遍Next-Key Locks</li>
</ol>
<h3 id="补充-3"><a href="#补充-3" class="headerlink" title="补充"></a>补充</h3><ol>
<li><p>数据库索引：<br>索引是对数据库表中的一个或多个列进行排序的结构。它有以下优点：</p>
<ul>
<li>通过创建唯一索引，能够在索引和数据上建立一对一的映射，增加数据的唯一性的特点；</li>
<li>能够提高数据的检索和排序速度</li>
<li>能够加快表与表之间的连接速度</li>
<li>建立索引后，在信息查询过程中可以使用优化隐藏器</li>
</ul>
<p><strong>同时它有以下缺点（索引建多的坏处）</strong></p>
<ul>
<li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li>
<li>更多的索引意味着也需要更多的空间</li>
<li>数据量小的表不需要建立索引，建立会增加额外的索引开销</li>
</ul>
</li>
<li><p>联合索引<br>又叫复合索引，即多列索引。查询时需遵循最左侧原则，即数据的最左匹配特性。联合索引可以在指定值查询、范围查询和排序中使用，但需注意的是，一旦使用了范围查询，则范围查询列以后的所有列索引失效</p>
</li>
<li><p>聚簇索引和非聚簇索引的区别：</p>
<ul>
<li>聚簇索引查询结果的顺序就是数据的物理存储的顺序，非聚簇索引则与数据的物理存储顺序无关；</li>
<li>聚簇索引的叶结点就是数据节点，非聚簇索引的叶结点还是索引</li>
<li>聚簇索引具有唯一性，一张表只能设置一个聚簇索引</li>
</ul>
</li>
<li><p>红黑树：</p>
<ul>
<li>一种二叉查找树，但在每个节点增加一个存储位表示结点的颜色，可以是Red或Black</li>
<li>通过对任何一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的</li>
</ul>
<p><strong>红黑树的五个性质：</strong></p>
<ul>
<li>每个节点要么是红的要么是黑的</li>
<li>根节点是黑的</li>
<li>每个叶节点（叶节点即指树尾端NIL指针或NULL结点）都是黑的</li>
<li>如果一个结点是红的，那么它的两个儿子都是黑的</li>
<li>对于任意结点而言，其到叶结点的所有路径都包含相同数目的黑结点</li>
</ul>
</li>
<li><p>B/B+树的优点——与红黑树比（二叉树）：</p>
<ul>
<li>出度更多，树高h更小，在查找过程中磁盘IO次数更少</li>
</ul>
</li>
<li><p>B+树相对B树的优点：</p>
<ul>
<li>非叶结点不保存数据，仅保留指向下一结点的指针，磁盘页（每一结点）能存储更多指针，较B树能有更大的出度，树高更小；</li>
<li>B+树查询必须查找到叶子节点，查询更稳定</li>
<li>B+树的范围查找较B树更快，将随机IO变为顺序IO（B+树索引是有序的，它的叶子结点是双向连接，即同时用双向链表维护叶结点）</li>
</ul>
</li>
<li><p>B+树索引和hash索引的区别</p>
<ul>
<li>时间复杂度上，B+树索引为O(logn)，hash索引为O(1)</li>
<li>B+树索引支持排序和分组，但hash索引不支持</li>
<li>B+树索引支持部分查找和精确查找，hash索引仅支持精确查找</li>
</ul>
</li>
<li><p>InnoDB是MySQL的默认存储引擎，实现了四个标准的隔离级别，默认级别是可重复读。在可重复读级别下，通过多版本并发控制（MVCC）+ Next-Key Locks防止幻影读。InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。<br><strong>特点：</strong></p>
<ul>
<li>主索引是聚簇索引，在索引中保留了数据，避免直接读磁盘，加快了查询效率；</li>
<li>从磁盘读取数据时，使用可预测性读；</li>
<li>对于频繁查询的数据，会自动创建自适应哈希索引；</li>
<li>使用插入缓冲区加速插入操作</li>
<li>支持在线热备份</li>
</ul>
</li>
<li><p>mysql和redis的区别：</p>
<ul>
<li>mysql是关系型数据库，redis是非关系型的内存键值数据库；</li>
<li>redis是内存数据库，而mysql是存储在磁盘的，因此对于更大规模的数据，mysql更适用</li>
<li>redis的key-value值的查询速度高于mysql，因此适合用作缓存</li>
</ul>
</li>
<li><p>对什么样的表和列应该建立索引</p>
<ul>
<li>经常需要搜索、范围查询和排序的列</li>
<li>在作为主键的列</li>
<li>经常用在连接的列，即外键上</li>
</ul>
</li>
<li><p>索引失效</p>
<ul>
<li>查询条件中有or，则部分条件中的索引失效。若想索引生效，则or查询中的每一列均需加索引</li>
<li>复合索引不满足最左侧原则</li>
<li>Like中以‘%’开头</li>
<li>需要类型转换</li>
<li>where中索引列有运算</li>
<li>where中索引列使用了函数</li>
<li>如果mysql觉得全表扫描更快时（数据量少）</li>
</ul>
</li>
<li><p>为什么建表时加Not Null Default？</p>
<ul>
<li>不好比较，NULL是一种类型，比较时只能用is not null 和is null来进行比较，碰到运算符时，一律返回null</li>
<li>影响索引效率</li>
</ul>
</li>
<li><p>为什么不用UUID做主键？</p>
<ul>
<li>不易于存储：UUID太长，有128位</li>
<li>信息不安全：基于MAC地址生成UUID的算法可能导致MAC地址泄露</li>
<li>对于MySQL，UUID的无序性会导致数据位置频繁变动，影响性能</li>
</ul>
</li>
<li><p>SQLite为什么不适合用在大型项目上</p>
<ul>
<li>并发低</li>
<li>写入慢</li>
<li>在大数据量的情况下表现差</li>
<li>为已有的表加索引较慢</li>
</ul>
</li>
<li><p>缓存穿透、缓存击穿和缓存雪崩</p>
<p><strong>缓存穿透</strong></p>
<ul>
<li>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求</li>
<li>解决方法：使用布隆过滤器或缓存空对象</li>
</ul>
<p><strong>缓存击穿</strong></p>
<ul>
<li>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，引起数据库压力瞬间增大</li>
<li>解决方法：访问数据库时对key加互斥锁</li>
</ul>
<p><strong>缓存雪崩</strong></p>
<ul>
<li>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。</li>
<li>解决方法：缓存数据的过期时间设置随机；如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中；访问数据库加互斥锁</li>
</ul>
</li>
<li><p>MySQL处理死锁的方法<br>过期策略（等待超时）、检测消除策略（根据事务和锁的方向判断是否有环来检测，通过回滚解除死锁）</p>
</li>
<li><p>分布式事务相关（保证主从数据库数据一致性的解决方法）</p>
<ul>
<li>XA（2PC）：二阶段提交，分投票阶段（prepare）和执行阶段（commit/rollback）</li>
<li>XA（3PC）：三阶段提交，分cancommit、precommit和docommit三个阶段</li>
</ul>
<p><em>相比2pc，3pc引入了超时机制，但依然没有解决数据不一致问题</em></p>
<ul>
<li>消息队列（如RocketMQ）</li>
</ul>
</li>
<li><p>乐观锁和悲观锁</p>
<ul>
<li>乐观锁：假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会对数据是否冲突进行检测。乐观锁适用于读操作多的场景，可通过CAS和版本快照实现</li>
<li>悲观锁：在访问某条数据时，为避免该数据被修改，会对该数据进行加锁以防止并发，保证同步区的互斥性。适合写操作多的场景，可java中synchronize关键字（的重量级锁）实现</li>
</ul>
</li>
<li><p>redis的字符串是如何实现的？</p>
<ul>
<li>redis构建了一个简单动态字符串（Simple Dynamic String），简称SDS。里面包含三个变量：len（字符串长度）、free（空闲未使用的长度）、buf[]（字符数组）</li>
<li>SDS可动态扩展，在追加新字符串时，会做以下两步：<ol>
<li>计算free空间大小是否足够</li>
<li>若不够，则开辟空间至满足所需大小，分以下两种情况讨论：<ul>
<li>若len &lt; 1M，则开辟大小len长度的空闲空间；</li>
<li>否则，开辟1M的空闲空间</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>redis字符串的性能优势</strong></p>
<ul>
<li>快速获取字符串长度</li>
<li>避免缓冲区溢出</li>
<li>降低空间分配次数提升内存使用效率</li>
</ul>
</li>
<li><p>索引的数据结构</p>
<ul>
<li>Hash结构</li>
<li>二叉搜索树</li>
<li>红黑树</li>
<li>B树</li>
<li>B+树</li>
</ul>
</li>
<li><p>两段锁协议<br><strong>规则</strong></p>
<ul>
<li>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁。</li>
<li>在释放一个封锁之后，事务不再申请和获得其它任何封锁。</li>
</ul>
<p><strong>即事务的执行分为两个阶段：</strong></p>
<ul>
<li>第一阶段是获得封锁的阶段，称为扩展阶段。</li>
<li>第二阶段是释放封锁的阶段，称为收缩阶段。</li>
</ul>
</li>
<li><p>InnoDB的七种类型的锁：</p>
<ul>
<li>共享/排它锁(Shared and Exclusive Locks)</li>
<li>意向锁(Intention Locks)</li>
<li>记录锁(Record Locks)</li>
<li>间隙锁(Gap Locks)</li>
<li>临键锁(Next-key Locks)</li>
<li>插入意向锁(Insert Intention Locks)</li>
<li>自增锁(Auto-inc Locks)</li>
</ul>
<p><strong>InnoDB什么时候行锁什么时候表锁</strong></p>
<ul>
<li>InnoDB行锁是通过索引上的索引项来实现的，InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁</li>
</ul>
</li>
<li><p>MySQL宕机如何恢复（简版）</p>
<ul>
<li>LSN(Log Sequence NO)：日志号，一个递增的64位整数，一个LSN表示一个（redo）Log结构。</li>
<li>CHECKPOINT：表示一个时间点，在CHECKPOINT LSN之前的更改都已经保存到了持久存储。恢复时只需从最后一个CHECKPOINT LSN开始。</li>
</ul>
<p><strong>恢复过程</strong></p>
<ol>
<li>定位到最近的一个checkpoint；</li>
<li>分析redo log，标识出未提交的事务</li>
<li>顺序执行redo log</li>
<li>rollback未提交的事务</li>
</ol>
</li>
<li><p>布隆过滤器</p>
<ul>
<li>本质是一个很长的二进制向量和一系列随机映射函数（多次哈希）</li>
<li>优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>黑名单</li>
<li>单词拼写检查</li>
<li>Key-Value缓存系统的Key校验（结合缓存穿透）</li>
<li>ID校验，比如订单系统查询某个订单ID是否存在，如果不存在就直接返回。</li>
</ul>
</li>
<li><p>实现分布式锁的三种方式</p>
<ul>
<li>基于数据库实现</li>
<li>基于redis实现</li>
<li>基于zookeeper实现</li>
</ul>
</li>
<li><p>主键索引和非主键索引区别</p>
<ul>
<li>主键索引也被称为聚簇索引,叶子节点存放的是整行数据; 而非主键索引被称为二级索引,叶子节点存放的是主键的值。</li>
<li>因此查询过程中，主键索引仅需查询该索引的b+树，非主键索引在查询完该索引的b+树时，仅获得主键值，因此仍需到主键索引的b+树上再查一次数据</li>
</ul>
</li>
<li><p>范式<br><strong>官方解释</strong></p>
<ul>
<li>第一范式 (1NF)：属性不可分</li>
<li>第二范式 (2NF)：每个非主属性完全函数依赖于键码</li>
<li>第三范式 (3NF)：非主属性不传递函数依赖于键码</li>
</ul>
<p><strong>通俗解释</strong></p>
<ul>
<li>第一范式 (1NF)：<ol>
<li>每一列属性都是不可再分的属性值，确保每一列的原子性</li>
<li>两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据</li>
</ol>
</li>
<li>第二范式 (2NF)：确保数据库表中的每一列都和主键相关。每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。</li>
<li>第三范式 (3NF)：数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a–&gt;b–&gt;c  属性之间含有这样的关系，是不符合第三范式的。</li>
</ul>
<p><strong>例：</strong>比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话），这样一个表结构，就存在上述关系。 学号–&gt; 所在院校 –&gt; (院校地址，院校电话)。这样的表结构，我们应该拆开来，如下：（学号，姓名，年龄，性别，所在院校）–（所在院校，院校地址，院校电话）</p>
</li>
<li><p>事务是什么</p>
<ul>
<li>事务是一组不可再分割的操作集合（工作逻辑单元）；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；</li>
</ul>
</li>
<li><p>为什么 MySQL 有 binlog，还有 redolgo？</p>
<ul>
<li>这个是因为MySQL体系结构的原因，MySQL是多存储引擎的，不管使用那种存储引擎，都会有binlog，而不一定有redo log，简单的说，binlog是MySQL Server层的，redo log是InnoDB层的。</li>
</ul>
<p><strong>对于一条写语句，innodb 在 commit 时的执行顺序如下：</strong></p>
<ul>
<li>会话发起 COMMIT 动作</li>
<li>存储引擎层开启[Prepare]状态：在对应的 Redo 日志记录上打上 Prepare 标记</li>
<li>写入 binlog 并执行 fsync(刷盘)</li>
<li>在 redo 日志记录上打上 COMMIT 标记表示记录提交完成</li>
</ul>
</li>
</ol>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="需要注意的对比-3"><a href="#需要注意的对比-3" class="headerlink" title="需要注意的对比"></a>需要注意的对比</h3><ol>
<li>再看一遍Linux的文件系统、文件、进程管理</li>
<li>再看一遍socket</li>
</ol>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol>
<li><p>IO多路复用</p>
<ul>
<li>指单个进程同时处理多个网络连接的IO的能力</li>
<li>Linux下提供了select、poll和epoll系统调用实现IO多路复用</li>
<li>当用户进程调用了select，会进入阻塞状态。select会轮询负责的所有socket，当select中的某个socket数据准备好时，select会返回。这个时候用户进程再调用read操作，将数据从内核缓冲区拷贝到用户进程缓冲区</li>
</ul>
</li>
<li><p>进程的内存结构</p>
</li>
</ol>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/1.png" class="">

<ol start="3">
<li><p>Nginx的优点</p>
<ul>
<li>内存消耗少</li>
<li>稳定性高： 用于反向代理，宕机的概率微乎其微</li>
<li>支持高并发连接：原因主要是Nginx使用了最新的epoll（Linux2.6内核）和kqueue（freeBSD）网路I/O模型</li>
<li>支持热部署：启动容易，且能够在不间断服务的情况下，对软件版本进行升级</li>
<li>支持Rewrite重写 </li>
<li>成本低廉</li>
<li>配置简单  </li>
</ul>
</li>
<li><p>常用操作<br><strong>查看端口号被哪个进程占用</strong></p>
<ul>
<li>lsof -i:端口号</li>
<li>netstat -tunlp|grep 端口号</li>
</ul>
<p><strong>进程查看和杀死命令</strong></p>
<ul>
<li>ps命令用于查看当前正在运行的进程</li>
<li>kill命令用于终止进程</li>
</ul>
</li>
<li><p>硬链接和软链接</p>
<ul>
<li>硬链接：文件名指向索引节点</li>
<li>软链接：特殊的文件，存储另一文件的路径信息</li>
</ul>
</li>
<li><p>零拷贝对比</p>
<table>
<thead>
<tr>
<th align="center">拷贝方式</th>
<th align="center">CPU拷贝次数</th>
<th align="center">DMA拷贝次数</th>
<th align="center">上下文切换次数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">传统方式</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">mmap + write</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">sendfile</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">sendfile + DMA</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
</tbody></table>
<p><strong>缺点</strong></p>
<ul>
<li>mmap + write：当mmap一个文件时，若该文件被另一个进程所截获，则write系统调用会因为访问非法地址而被SIGBUS信号终止。 可通过使用文件的租界锁解决</li>
<li>sendfile：仅适用于无需用户态处理的程序</li>
<li>sendfile + DMA：除了sendfile一样的问题，还有需要硬件和驱动程序的支持</li>
</ul>
</li>
<li><p>Ctrl + C/Z</p>
<ul>
<li>ctrl + C：强制中断执行当前交互程序的进程</li>
<li>ctrl + Z：将任务中断,但是此任务并没有结束,他仍然在进程中他只是维持挂起的状态</li>
</ul>
</li>
<li><p>实体链接和符号链接的区别</p>
<ul>
<li>实体链接不能对目录进行链接，符号链接可以</li>
</ul>
</li>
<li><p>waitpid()和wait()相比的区别</p>
<ul>
<li>多了参数pid，指示一个子进程的ID，表示只关心这个子进程退出的SIGCHILD信号</li>
<li>多了options参数，可选为 WNOHANG 和 WUNTRACED 两个选项，若参数为 WNOHANG，可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</li>
</ul>
</li>
</ol>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li><p>一个日志有用户登入登出时间，求该日志覆盖的时间段里同时在线人数的峰值</p>
<ul>
<li>创建时间数组，遍历log，若该条数据的登入登出时间在某个时间段内，则将该时间段内对应的数组元素的值+1</li>
</ul>
</li>
<li><p>有一个10G的url黑名单，要你判断当前url是否存在于黑名单中</p>
<ul>
<li>使用布隆过滤器</li>
</ul>
</li>
</ol>
<h2 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h2><ol>
<li><p>小明有100根香蕉，他离家50米。小明一次最多能背50根香蕉，但他每走一米要吃掉一根香蕉，那么小明最多能背回家多少根香蕉？<br><strong>答：</strong>设小明走了x米后停下，回去取剩下的50根香蕉，则小明再折回x处时，总共剩下的香蕉需小于等于50，方可一次背回家中，故得到方程：（50-2x + 50-x）&lt;= 50，解得x=17，那么50-17*2 = 16根</p>
</li>
<li><p>记a = x + y, b = xy, 求xn + yn</p>
<ul>
<li>记rn = xn + yn，则rn = ar(n - 1) - br(n - 2);</li>
<li>n相关的都是幂</li>
</ul>
</li>
</ol>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="需要注意的对比-4"><a href="#需要注意的对比-4" class="headerlink" title="需要注意的对比"></a>需要注意的对比</h3><ol>
<li>关键字 synchronized 和 volatile 的区别（五种）（再看一遍）</li>
<li>Object类中的通用方法（至少背6个）</li>
<li>再看一遍synchronized和ReentrantLock</li>
<li>再看一遍线程池参数</li>
<li>再看一遍向线程池提交任务的过程</li>
<li>再看一遍关闭线程池的方法</li>
<li>再看一遍Java反射和泛型</li>
<li>再看一遍ArrayList、HashMap、ConcurrentHashMap</li>
<li>背下HashMap和HashTable的区别</li>
<li>Java并发里的JUC-AQS</li>
<li>再看一遍设计模式中的单例模式</li>
<li>再看一遍面向对象思想</li>
</ol>
<h3 id="补充-4"><a href="#补充-4" class="headerlink" title="补充"></a>补充</h3><ol>
<li><p>ArrayList相关</p>
<ul>
<li>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</li>
<li>数组的默认大小为 10。</li>
</ul>
<p><strong>扩容过程</strong></p>
<ul>
<li>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够</li>
<li>如果不够时，需要使用 grow() 方法进行扩容，新容量大约是旧容量的 1.5 倍左右。</li>
<li>扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中</li>
</ul>
</li>
<li><p>Hashmap相关</p>
<ul>
<li>Hashmap的存储结构为Entry类型的数组，使用拉链法解决冲突，JDK1.7使用头插法插入结点，JDK1.8使用尾插法插入节点（避免循环引用）</li>
<li>默认大小为16，容量必须为2的整数次幂，每次扩容为原来容量的两倍</li>
<li>默认装载因子为0.75，即当Hashmap中键值对数量大于等于容量*0.75时，Hashmap将自动扩容</li>
<li>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。</li>
<li>Hashmap是线程不安全的</li>
</ul>
<p><strong>put操作过程</strong></p>
<ol>
<li>判定键是否为null，若为null，则插入到或更新第0个桶的位置处；</li>
<li>若不为null，计算hash值并确定桶下标</li>
<li>遍历该桶上的链表的所有结点，查看是否有待插入key的键值对</li>
<li>若有，则更新该key的值</li>
<li>否则，插入该键值对</li>
</ol>
<p><strong>扩容过程</strong></p>
<ul>
<li>创建一个新的HashMap，该map的容量为原容量的两倍</li>
<li>调用resize()把原HashMap中的键值对重新插入到newTable中</li>
</ul>
<p><strong>Map的容量为什么必须为2的n次方</strong></p>
<ul>
<li>在查找过程中，根据key计算得到hash值后，需取模计算桶下标。若桶的大小为2的整数次方，则对capacity取模的过程可转化为对capacity - 1做与运算的过程，这个计算方式效率更高</li>
<li>在扩容重新计算桶下标过程中，若容量为2的整数次方，以原容量为16为例，则新容量为32。则原来hash值在第五位为0的键值对在新map中仍在与原map相同下标的桶处；为1的键值对在新map中为在原map桶中下标+16的桶处</li>
</ul>
<p><strong>HashMap为什么是线程不安全</strong></p>
<ul>
<li>JDK1.7中会在transfer()过程中出现循环引用</li>
<li>JDK1.8中会在put操作过程中造成数据覆盖</li>
</ul>
<p><strong>循环引用</strong></p>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A81.png" class="">
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A82.png" class="">
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A83.png" class="">
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A84.png" class=""></li>
<li><p>Hashtable和ConcurrentHashMap</p>
<ul>
<li>HashTable类使用synchronize来做线程安全，全局只有一把锁</li>
<li>ConcurrentHashMap在JDK1.7使用segmant（分段锁）实现，自JDK 1.8使用CAS（Compare and Swap）操作实现，</li>
<li>ConcurrentHashMap也实现了在链表长度大于等于8时自动转化为红黑树</li>
</ul>
<p><strong>CAS操作</strong></p>
<ul>
<li>CAS的问题：在高并发情况下，CPU开销较大；只适用于变量，不能保证代码块的原子性；ABA问题</li>
<li>CAS适用场景：线程冲突小的场景（可能还有任务执行时间短的场景）</li>
</ul>
<p><strong>ConcurrentHashMap中的size操作（JDK1.7）</strong></p>
<ul>
<li>每个segment中维护一个count变量，记录该segment中键值对的数量</li>
<li>size操作会统计所有segment的count并累计起来</li>
<li>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</li>
</ul>
</li>
<li><p>Java单例模式</p>
<ul>
<li>饿汉式：在类初始化时即实例化自己，天生线程安全（背下代码）</li>
<li>懒汉式：在调用的时候才实例化，非线程安全，可通过在方法上加同步、在代码块上加同步或使用静态内部类实现线程安全</li>
</ul>
</li>
<li><p>Java里的几种内部类：</p>
<ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>嵌套内部类</li>
<li>匿名内部类<br>内部类可以访问外部类的成员，在内部类构造的时候，会将外部类的引用传递进来，并且作为内部类的一个属性，所以内部类会持有一个其外部类的引用。</li>
</ul>
</li>
<li><p>为什么要有迭代器<br>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
</li>
<li><p>synchronized 是怎么实现的</p>
<ul>
<li>若是同步代码块，则在代码块前后分别添加monitorenter和monitorexit字节码指令。</li>
<li>若是同步方法，则JVM从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法</li>
</ul>
</li>
<li><p>synchronized 的四种锁状态</p>
<ul>
<li>无锁状态</li>
<li>偏向锁：通过对比 Mark Word 解决加锁问题，避免执行CAS操作。</li>
<li>轻量级锁：通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。</li>
<li>重量级锁：将除了拥有锁的线程以外的线程都阻塞。</li>
</ul>
<p><strong>膨胀式锁分配策略：</strong>锁可以升级但不可以降级</p>
</li>
<li><p>常见的五种运行时异常</p>
<ul>
<li>IndexOutOfBoundsException - 下标越界异常</li>
<li>NullPointerException - 空指针引用异常</li>
<li>ClassCastException - 类型强制转换异常</li>
<li>ArithmeticException - 算术运算异常</li>
<li>NegativeArraySizeException - 数组大小错误异常（数组大小为负数）</li>
</ul>
</li>
<li><p>Java常见的几种线程池（五种）</p>
<ul>
<li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程（数量没有限制）。</li>
<li>newFixedThreadPool：创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</li>
<li>newSingleThreadExecutor：只创建一个工作者线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
<li>newScheduleThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行</li>
</ul>
</li>
<li><p>AQS相关（AbstractQueuedSynchronizer–抽象队列同步器）</p>
<ul>
<li>就ReentrantLock来说，AQS是它的一个对象，是ReentrantLock用来实现加锁和释放锁的关键性的核心组件</li>
<li>核心变量state：0表示未上锁，非0表示已上锁，非0值表示上锁的线程重入该锁的次数</li>
<li>记录加锁线程的变量：该变量记录加锁的线程，用于实现可重入锁</li>
<li>阻塞队列：ReentrantLock是互斥锁，所有申请锁失败的线程都会进入阻塞队列 </li>
</ul>
</li>
<li><p>Java的锁分类（7大类）</p>
<ul>
<li>偏向锁/轻量级锁/重量级锁</li>
<li>可重入锁/非可重入锁</li>
<li>共享锁/独占锁</li>
<li>公平锁/非公平锁</li>
<li>悲观锁/乐观锁</li>
<li>自旋锁/非自旋锁</li>
<li>可中断锁/不可中断锁</li>
</ul>
</li>
<li><p>start()和run()的区别</p>
<ul>
<li>当程序调用Thread类start()方法，会创建一个新线程。此时该线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，才开始执行run()方法。</li>
<li>当直接调用run()方法时，程序并不会创建新线程，run方法内部的代码将在当前线程上运行。</li>
</ul>
</li>
<li><p>Java创建线程的方式（也即如何实现多线程）</p>
<ul>
<li>通过继承Thread类：重写run()方法，调用start()方法创建新线程</li>
<li>通过实现Runnable接口或者Callable接口</li>
</ul>
<p><strong>补充</strong>：run()方法的方法体就是线程要完成的任务</p>
</li>
<li><p>ThreadLocal()类</p>
<ul>
<li>ThreadLocal是JDK包提供的一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据。通过get和set方法可以获取和设置当前线程对应的值。</li>
</ul>
</li>
<li><p>CopyOnWrite</p>
<ul>
<li>写时复制，在往集合中更新数据的时候，先拷贝存储的数组，然后添加元素到拷贝好的数组中，然后用现在的数组去替换成员变量的数组</li>
</ul>
</li>
<li><p>Scanner相关</p>
<ul>
<li>nextLine()在nextInt()方法后时，需添加多一个nextLine()在nextLine()之前，以捕获nextInt()方法后的回车符、</li>
</ul>
</li>
<li><p>重写和重载</p>
<ul>
<li>Override：重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。（返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类</li>
<li>Overload：重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。</li>
</ul>
</li>
<li><p>Java引用和C++指针的区别</p>
<ul>
<li>类型：引用其值为地址的数据元素，Java封装了的地址，可以转换成字符串查看，长度也可以不必担心。C++指针是一个装地址的变量，长度一般是计算机字长，可以认为是个int。</li>
<li>所占内存：引用声明时没有实体，不占空间。C++指针如果声明之后会用到才会赋值。如果用不到不会分配内存。</li>
<li>初始值：引用初始值为java关键字null。C++指针是int，如不初始化指针，那它的值就不是固定的了，这很危险。</li>
<li>计算：引用不可以计算。C++指针是int，他可以计算，如++或–，所以经常用指针来代替数组下标。</li>
<li>内存泄露：Java引用不会产生内存泄露。C++指针是容易产生内存泄露的，所以程序员要小心使用，及时回收。</li>
</ul>
</li>
<li><p>volatile为什么不能保证原子性？<br><strong>先解释下可见性</strong></p>
<ul>
<li>可见性与Java的内存模型有关，模型采用缓存与主存的方式对变量进行操作，也就是说，每个线程都有自己的缓存空间，对变量的操作都是在缓存中进行的，之后再将修改后的值返回到主存中，这就带来了问题，有可能一个线程在将共享变量修改后，还没有来的及将缓存中的变量返回给主存中，另外一个线程就对共享变量进行修改，那么这个线程拿到的值是主存中未被修改的值，这就是可见性的问题。</li>
<li>volatile很好的保证了变量的可见性，变量经过volatile修饰后，对此变量进行写操作时，汇编指令中会有一个LOCK前缀指令，并引发两件事情：</li>
</ul>
<ol>
<li>将当前处理器缓存行的数据写回到系统内存</li>
<li>这个写回内存的操作会使得在其他处理器缓存了该内存地址无效</li>
</ol>
<ul>
<li>即当一个共享变量被volatile修饰时，它会保证修改的值被立即更新到主存，当有其他线程需要读取时，它会去内存中读取新值，这就保证了可见性。</li>
</ul>
<p><strong>但原子性上</strong></p>
<ul>
<li>在某一时刻线程1将i的值load取出来，放置到cpu缓存中，然后再将此值放置到寄存器A中，然后A中的值自增1（寄存器A中保存的是中间值，没有直接修改i，因此其他线程并不会获取到这个自增1的值）。如果在此时线程2也执行同样的操作，获取值i==10,自增1变为11，然后马上刷入主内存。此时由于线程2修改了i的值，实时的线程1中的i==10的值缓存失效，重新从主内存中读取，变为11。接下来线程1恢复。将自增过后的A寄存器值11赋值给cpu缓存i。这样就出现了线程安全问题。</li>
</ul>
</li>
<li><p>抽象类和接口<br><strong>相同点</strong></p>
<ul>
<li>都不能被实例化</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>接口是对某一个行为动作的抽象，而抽象类是对类的抽象（包括了属性和对应的行为）</li>
<li>接口可以实现多实现，抽象类只能单继承</li>
<li>接口中定义的方法不能实现，抽象类中的方法可以部分实现。</li>
<li>接口中的域默认的为public static final，即不可更改的动作。而抽象类中可以被任意权限修饰符修饰，static/非static，final/非final，可以有抽象方法和非抽象方法。<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/4.png" class=""></li>
</ul>
<p><strong>interface的应用场合</strong></p>
<ul>
<li>类与类之前需要特定的接口进行协调，而不在乎其如何实现。</li>
<li>作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。</li>
<li>需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。</li>
<li>需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。</li>
</ul>
<p><strong>abstract class的应用场合</strong><br><em>一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：</em></p>
<ul>
<li>定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。</li>
<li>某些场合下，只靠纯粹的接口不能满足类与类之间的协调，而需要类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。</li>
<li>规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能</li>
</ul>
</li>
<li><p>Java内存模型</p>
<ul>
<li>Java内存模型规定了所有变量都存储在主内存内，此处主内存隶属于Java虚拟机内存的一部分，而虚拟机内存是操作系统分配的。每条Java线程还有自己的工作内存(类比上面的高速缓存)，工作内存中保存了被该线程使用到的变量的主内存的副本，线程对变量的所有操作都在工作内存中进行，Java线程之间的变量值传递都通过主内存来完成。<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/5.jpg" class=""></li>
</ul>
<p><strong>Java内存模型定义了8种原子性操作，其中前4条是作用于主内存，后4条作用于工作内存：</strong></p>
<ul>
<li>lock 锁定，将一个变量标识为线程独占状态</li>
<li>unlock 解锁，将锁定状态的变量解除锁定，释放后的变量才可以被其他变量锁定</li>
<li>read 读取，将变量从主内存传输到线程的工作内存中，待之后的load加载</li>
<li>write 写入，把store操作从工作内存中得到的变量值写入主内存的变量中</li>
<li>load 加载，将read后从主内存得到的变量值加载到工作内存的变量副本中</li>
<li>use 使用，把工作内存中的一个变量值传递给字节码执行引擎，等待字节码指令使用</li>
<li>assign 赋值，把一个从执行引擎接收到的值赋值给工作内存的变量</li>
<li>store 存储，把工作内存中一个变量的值传送到主内存中，以便随后的write使用</li>
</ul>
</li>
<li><p>Java的”==”和”equals”</p>
<ul>
<li>“==”仅适用于基本类型数据（如字符）比较，若用于对象（如字符串），则比较的是对象地址；”equals”用于比较对象，但该方法不能作用于基本数据类型的变量</li>
<li>此外，”euqals”用于对象的比较，比如：”Hello”.equals(greating)，而equalsIgnoreCase()方法还可实现不区分大小写比较两个字符串</li>
</ul>
</li>
<li><p>String相关</p>
<ul>
<li>String类用final修饰，代表String类不可被继承。</li>
<li>用于存储字符串值的char[] value数组用private和final修饰，其中，final可以保证value的引用地址不会被修改，但是不能保证数组中的值不会被修改，而private修饰符能够保证值不会被外部修改。这样就能保证String类的不可变性。</li>
</ul>
<p><strong>不可变性的好处</strong></p>
<ul>
<li>使得JVM可以实现字符串常量池；字符串常量池可以在程序运行时节约很多内存空间，因为不同的字符串变量指向相同的字面量时，都是指向字符串常量池中的同一个对象。这样一方面能够节约内存，另一方面也提升了性能。</li>
<li>保证了安全性。比如：若在HashMap中使用StringBuilder作为键的类型，因为StringBuilder可以改变，则可能导致HashMap中某个键被改变成与另一键相同，从而出现键不唯一的情况</li>
</ul>
<p><strong>equals源码分析</strong></p>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/6.png" class=""></li>
<li><p>Java线程的状态</p>
<ul>
<li>初始状态（NEW）：线程已经构建，尚未启动。</li>
<li>运行状态（RUNNABLE）：包括就绪（READY）和运行中（RUNNING）两种状态，统称为运行状态。</li>
<li>阻塞状态（BLOCKED）：线程被锁阻塞。</li>
<li>等待状态（WAITING）：线程需要等待其他线程做出特定动作（通知或中断）。</li>
<li>超时等待状态（TIME_WAITING）：不同于等待状态，超时等待状态可以在指定的时间自行返回。</li>
<li>终止状态（TERMINATED）：当前线程已经执行完毕。</li>
</ul>
<p><strong>阻塞状态</strong></p>
<ul>
<li>线程争用锁失败进入阻塞状态</li>
</ul>
<p><strong>等待状态</strong></p>
<ul>
<li>锁对象调用wait()方法（无指定超时时间）后线程进入等待状态</li>
</ul>
<p><strong>超时等待状态</strong></p>
<ul>
<li>线程调用sleep(int timeout)或锁对象wait(int timeout)方法后线程进入超时等待状态，在等待指定时间后会返回</li>
</ul>
<p><strong>sleep()和wait()方法区别</strong></p>
<ul>
<li>sleep()方法仅支持超时等待，wait()支持等待和超时等待状态</li>
<li>sleep()释放CPU执行权，但不释放同步锁；wait()释放CPU执行权，也释放同步锁，使得其他线程可以使用同步控制块或者方法。</li>
<li>只有锁对象才能调用wait()和notify()方法，sleep()方法不由锁对象调用</li>
</ul>
</li>
<li><p>Java的static关键字<br><strong>static方法（静态方法）</strong></p>
<ul>
<li>静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的</li>
<li>静态方法中不能访问类的非静态成员变量和非静态成员方法，但非静态成员方法中是可以访问静态成员方法/变量的</li>
<li>最常见的static方法就是main方法，因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。</li>
</ul>
<p><strong>static变量（静态变量）</strong></p>
<ul>
<li>静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。</li>
<li>非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li>
<li>static成员变量的初始化顺序按照定义的顺序进行初始化。</li>
</ul>
<p><strong>static代码块（静态代码块）</strong></p>
<ul>
<li>static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</li>
</ul>
<p><strong>补充</strong></p>
<ul>
<li>通过this能够访问静态成员变量</li>
<li>static不允许用来修饰局部变量（Java中是这样）</li>
<li>static代码块先于构造方法执行，因为static代码块在类加载的时候就执行，构造方法在创建对象的时候才执行</li>
</ul>
</li>
<li><p>Java的final关键字<br><strong>final类</strong></p>
<ul>
<li>当用final修饰一个类时，表明这个类不能被继承。</li>
<li>final类中的所有成员方法都会被隐式地指定为final方法。</li>
</ul>
<p><strong>final方法</strong></p>
<ul>
<li>把方法锁定，以防任何继承类重写</li>
<li>类的private方法会隐式地被指定为final方法</li>
</ul>
<p><strong>final变量</strong></p>
<ul>
<li>如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改</li>
<li>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象</li>
</ul>
</li>
<li><p>Java类加载机制</p>
<img src="/2021/05/03/%E9%9D%A2%E8%AF%95/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.png" class=""></li>
<li><p>线程安全问题</p>
<ul>
<li>运算结果错误（i++）</li>
<li>对象没有在正确的时间、地点被发布或初始化</li>
<li>活跃性问题，如死锁、活锁、饥饿</li>
</ul>
</li>
</ol>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="需要注意的对比-5"><a href="#需要注意的对比-5" class="headerlink" title="需要注意的对比"></a>需要注意的对比</h3><ol>
<li>背下JVM的运行时数据区域</li>
<li>背下类的加载过程</li>
<li>背下GC ROOTS的四类对象</li>
<li>再看一遍CMS和G1收集器</li>
<li>背下JVM的内存分配与回收策略</li>
</ol>
<h3 id="补充-5"><a href="#补充-5" class="headerlink" title="补充"></a>补充</h3><ol>
<li>JVM的回收过程<br>它的过程大致如下：调用垃圾回收器——判断对象是否可回收（引用计数法和根搜索算法）——调用垃圾回收算法（标记—清除算法、复制算法、标记—整理算法、分代收集算法）</li>
</ol>
<ol start="2">
<li><p>双亲委派模型</p>
<ul>
<li>类加载器之间有层级关系，从上到下依次为：启动类加载器、扩展类加载器、应用程序类加载器和用户自定义类加载器。除了顶层的启动加载类（又称引导加载类），其他的类加载器（扩展类加载器、应用程序类加载器、用户自定义加载器）都要有自己的父类加载器</li>
<li>类加载器间的父子关系一般通过组合关系实现，而不是继承关系</li>
<li>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</li>
</ul>
<p><strong>好处：</strong>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p>
<p><strong>补充：</strong>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
</li>
<li><p>内存泄漏相关</p>
<ul>
<li>定义：内存泄漏是指程序动态分配的堆内存因某种原因程序未释放或无法释放，造成系统内存浪费的情况。它会导致程序运行速度减慢甚至系统崩溃的后果</li>
<li>Java的内存泄漏和C++的内存泄露有什么不同：在C++中，如果需要动态分配一块内存，程序员需要负责这块内存的整个生命周期，这样很灵活，但过程却很繁琐，程序员容易因为疏忽忘记释放内存，从而导致内存泄漏；在Java有垃圾回收机制，它负责自动回收不再使用的内存</li>
<li>Java中还会有内存泄漏的情况吗？ 有，Java 的内存泄露通常情况下表现为一个内存对象的生命周期超出了程序需要它的时间长度。比如无效的使用static字段</li>
</ul>
</li>
<li><p>引用计数法和根搜索算法（或可达性分析法）</p>
<ul>
<li>引用计数法根据对象的引用计数判断对象是否可回收，若对象的引用计数为0，则回收对象；根搜索算法回收的是从GC ROOTS开始搜索不可达的对象</li>
<li>引用计数法存在循环引用的问题，根搜索算法可能导致浮动垃圾和对象消失问题</li>
</ul>
</li>
<li><p>JVM的根搜索算法——三色标记</p>
<ul>
<li>三色标记分别是：黑色、灰色、白色<br>黑色：根对象，或者该对象与它的子对象都被扫描过<br>灰色：对象本身被扫描，但是还有没扫描该对象的子对象<br>白色：未被扫描的对象，如果扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</li>
<li>浮动垃圾：GC中已经标黑的对象，在并发过程中引用链断掉，导致实际应为白色的垃圾对象仍是黑色的现想。解决办法：留给下次垃圾回收处理</li>
<li>对象消失问题需满足以下两个必要条件：<ol>
<li>赋值器插入了一条或多条从黑色对象到白色对象的引用</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ol>
<strong>解决办法</strong><ul>
<li>增量更新（CMS使用）：当一个白色对象被黑色对象引用，将黑色对象重新标记为灰色，让垃圾回收器重新扫描。</li>
<li>原始快照（G1使用）：在灰色对象要删除和白色对象的引用时，将该引用记录下来，在并发扫描结束后，重现这些记录的引用，类似浮动垃圾的处理</li>
</ul>
</li>
</ul>
</li>
<li><p>JVM的栈和堆</p>
<ul>
<li>栈中存放基本类型的数据或对象的引用变量，堆存放的是new创建的数组或对象</li>
<li>栈中的对象可以共享，堆中的不可以</li>
<li>栈的存取速度较快</li>
<li>栈中数据大小和生命周期可以确定，当没有引用指向数据时，数据便会消失；堆中的对象由垃圾回收器负责回收，因此大小和生命周期都不确定</li>
</ul>
</li>
</ol>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ol>
<li>Spring AOP实现原理<ul>
<li>AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。</li>
<li>OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。</li>
<li>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</li>
</ul>
<strong>实现AOP的技术，主要分为两大类：</strong><ul>
<li>一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；</li>
<li>二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</li>
</ul>
</li>
</ol>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>  您好，我叫邹润鑫，本科毕业于南京理工大学，专业是材料科学与工程，获学士学位。目前就读于北京大学软件与微电子学院电子信息专业软件工程方向。目前我研一，即将进入研二。我主要使用的编程语言是Java，同时会一点python。了解计算机网络、操作系统和数据库方面的基础知识。目前做过微信小程序的项目开发和爬虫，希望今天的面试能有个良好的表现，谢谢</p>
<h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><h3 id="挑战杯"><a href="#挑战杯" class="headerlink" title="挑战杯"></a>挑战杯</h3><ol>
<li><p>Flask + SQLAlchemy + MySQL的颈椎操——挑战杯项目<br><strong>介绍项目</strong></p>
<ul>
<li>我们的项目是一个叫“轻松颈椎操”的微信小程序，因为目前现代人看电脑和手机的时间很长，颈椎负担比较大，因此开发这个小程序，人们可以按照小程序上的提示进行颈椎操的锻炼，保护颈椎。这个小程序大概实现以下功能：用户登录进入小程序后，首先进入训练室页面（这也是我们的主界面），在训练室界面会展示可选的颈椎操项目，用户点击任意一个项目，会进入颈椎操视频教学的播放界面，用户按照视频教学进行颈椎锻炼。此外，每个用户有自己的个人信息界面和打卡记录界面，并可以查看自己的历史得分记录。</li>
</ul>
<p><strong>算法策略</strong></p>
<ul>
<li>服务端获取用户的训练视频，每120帧选取一帧存储，将存储的图片传入百度api，获取各个肢体部位的坐标（选择了眼、耳、鼻、下颌、手肘和手腕），将坐标画图连线，计算夹角，与同一时刻前后5秒的所有标准图片的夹角比较计算得分，其中的最高分即为该肢体动作的得分，最后返回所有动作得分的标准差</li>
</ul>
<p><strong>可以改进的地方？</strong></p>
<ul>
<li>使用token提高安全性，token由用户的user_id+服务端密钥结合，通过hash算法计算得到，在用户登录成功后返回给前端；前端每次调用接口，均需携带token验证身份；token需设置有效期，如3小时；在有效期内，用户再次登录小程序时，服务端只需验证token即可，无需再请求wx服务端获取openid验证身份，减少用户进入小程序的等待时长</li>
<li>使用redis数据库缓存token，加快身份认证过程</li>
</ul>
<p><strong>开发过程遇到的困难？</strong></p>
<ul>
<li>微信的登陆：查看了wx的小程序开发者文档，登陆流程大致如下：用户进入小程序时，前端会获取到此次登陆的code，传入服务端，服务端根据该code，结合自己的appid和secret，调用wx.login()查询用户的openid，最后服务端根据该openid获取用户在数据库中的数据</li>
<li>原先计划在controller层同时实现逻辑处理和数据库操作，但想着每一份代码都会因此较为庞大，重用性和可维护性不强，就想结合自己曾学过的MVC框架将其分了层，分为了controller和dao层，dao层负责数据库处理，controller层负责逻辑处理</li>
<li>登陆功能上，区分了三类用户：老用户、新用户和游客，老用户在查询数据库的时候即可获取数据，新用户和游客则需在user_info和user_record表上插入新纪录，游客和新用户的区别是是否授权给小程序，若授权，则在user_info表上较游客多了头像和昵称信息</li>
<li>打分上，在计算出得分后，不仅在user_score表插入新纪录，同时需更新user_record表和day_times表，user_record表表中参数有total_times、total_days和continuous_days，total_times需加1；total_days和continuous_days根据当天是否已更新该参数决定是否更新，实现思路是：找到该用户的user_record记录，根据update_date和当天的日期差是否大于1来决定是否更新；day_times表存储的是用户每天的锻炼次数，根据当天是否已有记录，来决定当天是添加记录还是将记录值+1。</li>
<li>sqlchemy的queery返回的是对象的list，但前端需要的是数据字典的list，因此在每个dao文件内新增了to_dict()函数将对象转化为dict</li>
</ul>
<p><strong>对flask的理解？</strong><br>因为这是我第一次接触python的web应用程序开发，flask是学长选择和配置的，因此理解不深，主要是开发过程中遇到的问题时，在解决过程中产生一些体会，比如说：</p>
<ul>
<li>app.py是应用程序的入口，该入口在启动时会调用主目录下的__init__.py文件，因此在该py文件下需导入sqlalchemy的model文件和controller里的文件，以构造数据库表和路由准备。</li>
<li>该__init__.py文件下的build_sample_db()语句每次会刷新数据库，因此在model无更改的情况下应注释掉，否则数据库数据会被刷新（即消失）</li>
</ul>
<p><strong>对sqlalchemy的理解？</strong></p>
<ul>
<li>sqlalchemy是一个有名的ORM框架，实现了关系型数据库的表结构到python类对象的映射。对表记录的操作可以转变为对类对象的操作，加快了开发速度。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><p><strong>2021/6/3周四下午四点，字节跳动广告研发部门后端一面（约50mins）</strong><br><strong>计算机网络</strong></p>
<ol>
<li>分别介绍一下OSI的七层网络模型</li>
<li>ip在那一层，ipv4和ipv6的区别</li>
<li>TCP的三次握手过程</li>
</ol>
<p><strong>操作系统</strong></p>
<ol>
<li>简单介绍一下进程和线程</li>
<li>线程通信方式</li>
<li>介绍死锁，举个简单例子</li>
</ol>
<p><strong>Java</strong></p>
<ol>
<li>三大特性，编译时多态和运行时多态的区别</li>
<li>重写和重载</li>
<li>Java的“==”和equals的区别</li>
<li>equals的执行过程</li>
<li>String为什么要用final修饰</li>
<li>StringBuilder和StringBuffer</li>
<li>10万字符的拼接用String还是StringBuilder，为什么用StringBuilder（因为会不断创建String对象）</li>
<li>Java支持多继承吗</li>
<li>抽象类和接口的区别</li>
<li>Synchronized的作用</li>
<li>Java的线程池类型</li>
</ol>
<p><strong>Mysql</strong></p>
<ol>
<li>索引的数据结构</li>
<li>b+树和b树的区别</li>
<li>简单讲一下事务（事务的四大特性）</li>
<li>事务的隔离级别，分别解决了什么问题</li>
<li>举个脏读的例子，那幻读呢</li>
<li>Mysql的两种存储引擎，区别</li>
</ol>
<p>一道sql题：表里有四列，id、name、class、score，找到各班的成绩最高的同学，返回name、class和score（“没啥问题”，其实有问题）<br>一道层序遍历，手撕TreeNode结点</p>
<p><strong>2021/6/9周四下午五点，字节跳动广告研发部门后端二面（43mins）</strong></p>
<ol>
<li>问项目，提建议</li>
<li>索引的作用</li>
<li>索引的数据结构</li>
<li>事务是什么</li>
<li>Java中的staic、final的作用</li>
<li>HashMap的线程安全的类</li>
</ol>
<p>一道删除链表重复结点题<br>一道查找二叉树的所有路径的题<br>（全程很着急）</p>
<p><strong>2021/6/18周五下午4点，字节跳动广告研发部门后端三面（53mins）</strong></p>
<ol>
<li>win如何查看进程、线程</li>
<li>进程一定会有线程吗</li>
<li>进程和线程的区别</li>
<li>多进程和多线程的区别</li>
<li>多进程什么情况下应用、多线程的应用场景</li>
<li>线程挂掉进程挂掉吗</li>
<li>子进程挂掉父进程会挂掉吗</li>
<li>为什么用flask，flask的特点</li>
<li>项目用了get还是post，它俩的区别</li>
<li>如何理解get方法用来获取资源、post传输资源</li>
<li>什么情况必须用get、post</li>
<li>了解header吗</li>
<li>请求头的信息，不是包头</li>
<li>返回前端json，有约定返回格式</li>
<li>cookie存在哪里</li>
<li>请求头有哪些</li>
<li>常见的返回状态码</li>
<li>永久性重定向和临时性重定向的区别、使用场景</li>
<li>用过什么数据结构</li>
<li>用栈的场景</li>
<li>JVM的栈溢出、堆溢出</li>
<li>栈、堆存储什么类型的数据</li>
<li>为什么基本类型数据用栈存储</li>
<li>实现一个栈 —— 代码：实现pop()、push()、getMin()，保持栈元素相对位置不变</li>
</ol>
<p><strong>2021/6/18周五下午六点，字节跳动广告研发部门hr面（53mins）</strong></p>
<ol>
<li>目前还有其他面试吗</li>
<li>为什么选择快手</li>
<li>你怎么看字节跳动这家公司</li>
<li>每周能做到全勤吗</li>
</ol>
<p>反问：如果顺利入职，我需要准备那些方面的内容</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/31/%E9%80%89%E8%B0%83%E7%9B%B8%E5%85%B3/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/touxiang.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">选调相关</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/05/Java/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/touxiang.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Java</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zourunxin"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">勤加注释！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-text">准备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">需要注意的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-text">需要注意的对比：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-1"><span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%AF%B9%E6%AF%94-1"><span class="toc-text">需要注意的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-2"><span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%AF%B9%E6%AF%94-2"><span class="toc-text">需要注意的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-3"><span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%AF%B9%E6%AF%94-3"><span class="toc-text">需要注意的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-text">思考题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E5%8A%9B%E9%A2%98"><span class="toc-text">智力题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%AF%B9%E6%AF%94-4"><span class="toc-text">需要注意的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-4"><span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%AF%B9%E6%AF%94-5"><span class="toc-text">需要注意的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-5"><span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87"><span class="toc-text">项目准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%91%E6%88%98%E6%9D%AF"><span class="toc-text">挑战杯</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E7%BB%8F"><span class="toc-text">面经</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/25/%E8%AF%BE%E7%A8%8B/" title="课程">课程</a><time datetime="2021-10-25T05:20:25.000Z" title="Created 2021-10-25 13:20:25">2021-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/25/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/" title="工作积累">工作积累</a><time datetime="2021-10-25T05:16:26.000Z" title="Created 2021-10-25 13:16:26">2021-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/25/%E5%B7%A5%E5%85%B7%E7%B1%BB/" title="工具类">工具类</a><time datetime="2021-10-25T04:13:44.000Z" title="Created 2021-10-25 12:13:44">2021-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/09/22/hello-world/" title="Hello World">Hello World</a><time datetime="2021-09-22T15:33:18.000Z" title="Created 2021-09-22 23:33:18">2021-09-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/31/%E9%80%89%E8%B0%83%E7%9B%B8%E5%85%B3/" title="选调相关">选调相关</a><time datetime="2021-05-31T14:57:21.000Z" title="Created 2021-05-31 22:57:21">2021-05-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div></div></body></html>