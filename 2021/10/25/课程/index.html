<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>课程 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="OS 该笔记由观看哈工大的李治军老师的操作系统整理而成   冯诺伊曼机的本质：取指执行 BIOS：base I&#x2F;O system 操作系统存在磁盘 0 磁道 0 扇区（也称引导扇区），开机后被读到 0x7c00 处 引导扇区代码：bootsect.s（s 代表汇编文件）   数据挖掘复习第2讲 – 认识数据 属性分类：标称属性、二元属性、序数属性、数值属性（选择题）  基本统计描述该如何使用  使">
<meta property="og:type" content="article">
<meta property="og:title" content="课程">
<meta property="og:url" content="http://example.com/2021/10/25/%E8%AF%BE%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="OS 该笔记由观看哈工大的李治军老师的操作系统整理而成   冯诺伊曼机的本质：取指执行 BIOS：base I&#x2F;O system 操作系统存在磁盘 0 磁道 0 扇区（也称引导扇区），开机后被读到 0x7c00 处 引导扇区代码：bootsect.s（s 代表汇编文件）   数据挖掘复习第2讲 – 认识数据 属性分类：标称属性、二元属性、序数属性、数值属性（选择题）  基本统计描述该如何使用  使">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-10-25T05:20:25.000Z">
<meta property="article:modified_time" content="2021-10-25T10:54:07.279Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://example.com/2021/10/25/%E8%AF%BE%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '课程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-25 18:54:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">课程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-10-25T05:20:25.000Z" title="Created 2021-10-25 13:20:25">2021-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-10-25T10:54:07.279Z" title="Updated 2021-10-25 18:54:07">2021-10-25</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><blockquote>
<p>该笔记由观看哈工大的李治军老师的操作系统整理而成</p>
</blockquote>
<ol>
<li>冯诺伊曼机的本质：取指执行</li>
<li>BIOS：base I/O system</li>
<li>操作系统存在磁盘 0 磁道 0 扇区（也称引导扇区），开机后被读到 0x7c00 处</li>
<li>引导扇区代码：bootsect.s（s 代表汇编文件）</li>
</ol>
<hr>
<h1 id="数据挖掘复习"><a href="#数据挖掘复习" class="headerlink" title="数据挖掘复习"></a>数据挖掘复习</h1><h2 id="第2讲-–-认识数据"><a href="#第2讲-–-认识数据" class="headerlink" title="第2讲 – 认识数据"></a>第2讲 – 认识数据</h2><ol>
<li><p>属性分类：标称属性、二元属性、序数属性、数值属性（选择题）</p>
</li>
<li><p>基本统计描述该如何使用</p>
<ul>
<li>使用简单统计方法：总数、平均数、中位数、占比、标准差、方差等</li>
<li>环比、同比、超过阈值的变化、跟以前若干统计期的平均数相比</li>
<li>相关分析：找到两个变量之间的关联关系</li>
<li>回归分析：<ul>
<li>对具有相关关系的两个或两个以上变量之间数量变化的一般关系进行测定，确立一个相应的数学表达式，以便从一个已知量来推测另一个未知量</li>
<li>通过定性分析来确定哪个是自变量、哪个是因变量</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="第3讲-–-数据预处理"><a href="#第3讲-–-数据预处理" class="headerlink" title="第3讲 – 数据预处理"></a>第3讲 – 数据预处理</h2><ol>
<li><p>数据预处理的作用？（判断题）</p>
<ul>
<li>现实世界的数据库易受噪声、缺失值和不一致数据的侵扰，由于数据库太大，并且很有可能来自多个异种数据源，不正确、不完整、不一致是现实世界大型数据库和数据仓库的共同特点</li>
<li>低质量的数据将导致低质量的挖掘结果。通过数据预处理，可以提高数据的准确性、完整性和一致性，显著提高数据挖掘的质量</li>
</ul>
</li>
<li><p>什么是ETL，ETL 包括哪些主要步骤？（选择题）</p>
<ul>
<li>ETL 是 Extract-Transform-Load 的缩写。可以实现数据优化，以最小代价将针对日常业务操作的数据，转化为针对数据仓库而存储的决策支持型数据</li>
<li>主要步骤：数据的抽取（Extract）、转换（Transform）、装载（Load）的过程</li>
</ul>
</li>
<li><p>NoSQL 数据模型有哪些？与 SQL 模型相比，有什么区别和联系，各有什么优劣？（判断题）</p>
<ul>
<li>键值对模型：Redis、Berkeley DB，它的数据按照 key-value 的形式进行组织、索引和存储。KV 存储非常适合不涉及过多数据关系的业务数据，同时能有效减少读写磁盘的次数，比 SQL 数据库存储拥有更好的读写性能。但是如果 DBA 只对部分值进行查询或更新的时候，Key/Value 就显得效率低下了，sql 效率更高</li>
<li>文档模型：mongoDB，文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值，而且文档型数据库比键值数据库的查询效率更高</li>
<li>列族模型：Hbase。列式数据库是以列相关存储架构进行数据存储的数据库。列式存储以流的方式在列中存储所有的数据，主要适合于批量数据处理和即时查询。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的 IO 优势。但是插入更新慢，不适合数据老是变化</li>
<li>图模型：neo4j。使用图形化的模型进行查询的数据库，通过节点、边和属性等方式来表示和存储数据。对于数据量大，关联复杂的数据，图数据库优势很大，因为关系型数据库不擅长处理数据间的关系</li>
</ul>
</li>
<li><p>常见的数据预处理方法有哪些，分别如何处理？（关于预处理作用的判断题）</p>
<ul>
<li>数据清理：现实世界的数据一般是脏的、不完整的和不一致的。数据清理例程填充遗漏值，识别局外者、清除噪音（分箱 · 聚类 · 计算机和人工检查结合 · 回归），并纠正数据中的不一致。</li>
<li>数据集成与变换：将多个数据源中的数据结合，整合到一个数据仓库中。同时，为了更好的对数据仓库中的数据进行挖掘，也要对数据仓库中的数据进行交换。数据变换方法：规范化（最小-最大规范化）、数据泛化、属性构造、平滑、聚集等</li>
<li>数据归约：大数据环境下数据量太大，直接进行复杂的数据分析和挖掘效率太低，我们利用数据归约可以在不损失数据特征的前提下，减少数据量。归约后的数据集上的挖掘结果与原结果几乎相同</li>
<li>离散化和概念分层：数据离散化通过把值映射到区间，或者把概念标号变换为数值，以减少属性值数量，使连续值离散化。概念分层通过将标称数据变换到多个粒度层，实现在多个粒度层进行挖掘</li>
</ul>
</li>
<li><p>TF-IDF 算法是什么，有什么实际含义？（考小题）</p>
<ul>
<li>TF-IDF 算法用来选取一篇文章的代表性关键词，某个词在文章中的 TF-IDF 越大，那么一般而言这个词在这篇文章的重要性会越高</li>
<li>含义：<ol>
<li>TF 词频：代表性，出现的次数越多，TF 值越大。<br>TF = 某个词在文章中的出现次数/文章的总词数</li>
<li>IDF 逆文档频率：普遍性，在越多的地方出现，普遍性越强，IDF 值越小。如果一个词越常见，那么分母就越大，逆文档频率就越小越接近0。分母之所以要加1，是为了避免分母为0（即所有文档都不包含该词）<br>IDF = log(语料库的文档总数/(包含该词的文档数 + 1))</li>
</ol>
</li>
<li>比如：一篇文章，词频高在文章中往往是停用词：“的”、“是”、“了”等，这些在我们文档中最常见但却对结果毫无帮助、需要过滤掉的词，用 TF 可以统计到这些常用词并把他们过滤。当高频词过滤后就只需考虑剩下的有实际意义的词</li>
</ul>
</li>
</ol>
<h2 id="第4讲-–-分类基础；第五讲-–-决策树与链接分析"><a href="#第4讲-–-分类基础；第五讲-–-决策树与链接分析" class="headerlink" title="第4讲 – 分类基础；第五讲 – 决策树与链接分析"></a>第4讲 – 分类基础；第五讲 – 决策树与链接分析</h2><ol>
<li><p>什么是分类，什么是有指导/无指导学习</p>
<ul>
<li>分类是一种数据分析形式，它提取数据类的模型，由分类器或分类模型预测类别标号。</li>
<li>有指导学习：数据有标注，模型在已知样本属于哪个类的“指导”下进行训练。典型的方法有SVM、k近邻等</li>
<li>无指导学习：数据无标注，模型在不知道训练样本属于哪个类的前提下训练，典型的方法有聚类、PCA等</li>
</ul>
</li>
<li><p>事件间的关系有哪些？</p>
<ul>
<li>包含、相等、互不相容、互逆</li>
</ul>
</li>
<li><p>概率与频率的区别与联系？</p>
<ul>
<li>概率是某个事件的客观出现的可能性，是一个固定值，不因试验次数改变而改变</li>
<li>频率是某个事件在整体实验中出现的次数，占整体试验次数的比例。因此在试验过程中频率的值会改变，如果试验次数多的话，频率可能会在概率周围波动</li>
<li>频率和概率：概率是客观现实分析所得的事件发生可能性的固定值。频率是客观试验所得事件真实发生的比例</li>
</ul>
</li>
<li><p>什么是条件概率，条件概率有哪些性质？</p>
<ul>
<li>条件概率是指事件A在另一个事件B已经发生条件下的发生概率。条件概率表示为：P(A|B)</li>
<li>性质：<ol>
<li>非负性：对于任意的事件B，有P(B|A) &gt;= 0</li>
<li>规范性：对于必然事件S，有P(S|A) = 1</li>
<li>可列可加性</li>
</ol>
</li>
<li>条件概率也是概率，概率一般性质同样适用于条件概率</li>
</ul>
</li>
<li><p>贝叶斯公式、朴素贝叶斯分类、贝叶斯网络（12页）</p>
</li>
</ol>
<h2 id="第6讲-–-随机过程与抽样"><a href="#第6讲-–-随机过程与抽样" class="headerlink" title="第6讲 – 随机过程与抽样"></a>第6讲 – 随机过程与抽样</h2><ol>
<li><p>什么是马尔可夫模型，什么是转移概率，什么是 C-K 方程？（14页）</p>
</li>
<li><p>HMM 三大问题的求解算法是什么？（16页）</p>
</li>
</ol>
<h2 id="第7讲-–-聚类基础"><a href="#第7讲-–-聚类基础" class="headerlink" title="第7讲 – 聚类基础"></a>第7讲 – 聚类基础</h2><ol>
<li>划分聚类的算法思想、过程、典型算法、优点、缺点和可扩展点有哪些？（18页）</li>
</ol>
<h2 id="第8讲-–-高级聚类方法"><a href="#第8讲-–-高级聚类方法" class="headerlink" title="第8讲 – 高级聚类方法"></a>第8讲 – 高级聚类方法</h2><ol>
<li><p>判断对错（补充）（20页）</p>
</li>
<li><p>密度聚类的核心概念、算法思想、过程、优点、缺点是什么？（20页）</p>
</li>
<li><p>网格聚类的核心概念、算法思想、过程、优点、缺点是什么？（21页）</p>
</li>
<li><p>图聚类的核心概念、算法思想、过程、优点、缺点是什么？（21页）</p>
</li>
</ol>
<h1 id="第9讲（重点中的重点，简答题）–-频繁模式挖掘基础"><a href="#第9讲（重点中的重点，简答题）–-频繁模式挖掘基础" class="headerlink" title="第9讲（重点中的重点，简答题）– 频繁模式挖掘基础"></a>第9讲（重点中的重点，简答题）– 频繁模式挖掘基础</h1><p>全都要看</p>
<h2 id="第10讲-–-频繁模式挖掘进阶与关联规则"><a href="#第10讲-–-频繁模式挖掘进阶与关联规则" class="headerlink" title="第10讲 – 频繁模式挖掘进阶与关联规则"></a>第10讲 – 频繁模式挖掘进阶与关联规则</h2><ol>
<li>FP-TREE 方法是什么，如何挖掘 FP-TREE？（28页）</li>
</ol>
<h2 id="第12讲-–-群体智能挖掘"><a href="#第12讲-–-群体智能挖掘" class="headerlink" title="第12讲 – 群体智能挖掘"></a>第12讲 – 群体智能挖掘</h2><ol>
<li><p>以下哪一个不属于群体挖掘？（选择题）</p>
</li>
<li><p>描述某个指定算法的思想、过程等（32页）</p>
</li>
</ol>
<h2 id="第13讲-–-集成挖掘"><a href="#第13讲-–-集成挖掘" class="headerlink" title="第13讲 – 集成挖掘"></a>第13讲 – 集成挖掘</h2><ol>
<li>什么是 GMM，GMM 求解算法是什么，GMM 有何有点？（42页）</li>
</ol>
<h2 id="第14讲-–-复杂类型数据挖掘"><a href="#第14讲-–-复杂类型数据挖掘" class="headerlink" title="第14讲 – 复杂类型数据挖掘"></a>第14讲 – 复杂类型数据挖掘</h2><ol>
<li><p>Bagging 和 boosting 机制分别是什么，有什么异同点？（39页）</p>
</li>
<li><p>Bandit 策略是什么？</p>
</li>
</ol>
<hr>
<h1 id="RocketMQ开源课程"><a href="#RocketMQ开源课程" class="headerlink" title="RocketMQ开源课程"></a>RocketMQ开源课程</h1><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol>
<li>RocketMQ的官网上有Schedule Example，但是在github上的仓库里没有；同时也没有Simple Example的Send Message in One-Way</li>
<li>RocketMQ的github仓库里的docs里有cn和en，可查看是否哪里缺了对应的文档，进行补全</li>
</ol>
<h3 id="作业-–-ISSUE和PR"><a href="#作业-–-ISSUE和PR" class="headerlink" title="作业 – ISSUE和PR"></a>作业 – ISSUE和PR</h3><ul>
<li>ISSUE：查看issue列表并解答，最后把链接发给老师</li>
<li>PR：检查pr是否合格，可在代码间添加评论（可选），最终需在结尾处写上“LGTM”，再提交，把链接发给老师</li>
</ul>
<h3 id="贡献代码过程"><a href="#贡献代码过程" class="headerlink" title="贡献代码过程"></a>贡献代码过程</h3><ol>
<li>需同步本地仓库至最新（在IDEA的Terminal上）：<code>git remote add apache git@github.com:apache/rocketmq.git</code></li>
<li>修改代码</li>
<li>提交代码流程<ul>
<li>Git-commit</li>
<li>填写”commit message”</li>
</ul>
<strong>举例：</strong>优化代码的commit message：<code>code style(client):polish lite pull consumer code style</code><ul>
<li>commit and push（要求提交到develop分支）</li>
<li>创建issue，标题如“Polish lite pull consumer code style”，并填写内容（英文），右侧添加Label，拷贝问题编号</li>
<li>contribute-open a pull request（提交一个pr）。标题前面需写上前面拷贝的问题标号，如”[ISSUE #2941]Polish lite pull consumer code style”</li>
<li>测试，最后creat a pull request</li>
</ul>
</li>
</ol>
<h2 id="Configuration-System-md-技术文档翻译（作业）"><a href="#Configuration-System-md-技术文档翻译（作业）" class="headerlink" title="Configuration_System.md 技术文档翻译（作业）"></a>Configuration_System.md 技术文档翻译（作业）</h2><h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><p>本节重点介绍系统（JVM/OS）的配置 </p>
<h2 id="1-JVM-选项"><a href="#1-JVM-选项" class="headerlink" title="1 JVM 选项"></a><strong>1 JVM 选项</strong></h2><p>建议使用最新发布的 JDK 1.8 版本。设置相同的 Xms 和 Xmx 值以防止 JVM 调整堆大小，并获得更好的性能。一种通用的JVM配置如下： </p>
<pre><code>-server -Xms8g -Xmx8g -Xmn4g
</code></pre>
<p>设置 Direct ByteBuffer 内存大小。当 Direct ByteBuffer 达到指定大小时，将触发 Full GC：</p>
<pre><code>-XX:MaxDirectMemorySize=15g
</code></pre>
<p>如果你不在乎 RocketMQ broker 的启动时间，建议启用预分配 Java 堆以确保在 JVM 初始化期间为每个页面分配内存。你可以通过以下方式启用它： </p>
<pre><code>-XX:+AlwaysPreTouch
</code></pre>
<p>禁用偏向锁定可以减少 JVM 停顿： </p>
<pre><code>-XX:-UseBiasedLocking
</code></pre>
<p>关于垃圾收集器，推荐使用 JDK 1.8 的 G1 收集器： </p>
<pre><code>-XX:+UseG1GC -XX:G1HeapRegionSize=16m 
-XX:G1ReservePercent=25
-XX:InitiatingHeapOccupancyPercent=30
</code></pre>
<p>这些 GC 选项看起来有点激进，但事实证明它在生产环境中具有良好的性能 </p>
<p>不要把-XX:MaxGCPauseMillis 的值设置太小，否则JVM会使用一个小的新生代来实现这个目标，从而导致频繁发生minor GC。因此，建议使用滚动 GC 日志文件：</p>
<pre><code>-XX:+UseGCLogFileRotation 
-XX:NumberOfGCLogFiles=5 
-XX:GCLogFileSize=30m
</code></pre>
<p>写 GC 文件会增加 broker 的延迟，因此可以考虑将 GC 日志文件重定向到内存文件系统：</p>
<pre><code>-Xloggc:/dev/shm/mq_gc_%p.log123
</code></pre>
<h2 id="2-Linux-内核参数"><a href="#2-Linux-内核参数" class="headerlink" title="2 Linux 内核参数"></a>2 Linux 内核参数</h2><p>在 bin 文件夹里，有一个 os.sh 脚本，里面列出了许多的内核参数，只需稍作更改即可用于生产用途。需特别关注以下参数，如想了解更多细节，请参考/proc/sys/vm/* 的文档。 </p>
<ul>
<li><strong>vm.extra_free_kbytes</strong>：控制VM在后台回收（kswapd）开始的阈值和直接回收（通过分配进程）开始的阈值之间保留额外的空闲内存。通过使用这个参数，RocketMQ 可以避免在内存分配过程中出现高延迟。（与内核版本版本有关）</li>
</ul>
<ul>
<li><strong>vm.min_free_kbytes</strong>：该值不应设置低于1024KB，否则系统将遭到破坏，并且在高负载环境下容易出现死锁。 </li>
</ul>
<ul>
<li><strong>vm.max_map_count</strong>：规定进程可以拥有的最大内存映射区域数。 RocketMQ 使用 mmap 来加载 CommitLog 和 ConsumeQueue，因此建议将此参数设置为较大的值。 </li>
</ul>
<ul>
<li><strong>vm.swappiness</strong>：定义内核交换内存页的频率。该值若较大，则会导致频繁交换，较小则会减少交换量。为了避免交换延迟，建议将此值设为 10。 </li>
</ul>
<ul>
<li><strong>File descriptor limits</strong>：RocketMQ 需要给文件（CommitLog 和 ConsumeQueue）和网络连接分配文件描述符。因此建议将该值设置为 655350。 </li>
</ul>
<ul>
<li><strong>Disk scheduler</strong>：推荐使用deadline I/O 调度器，它可以为请求提供有保证的延迟。</li>
</ul>
<h2 id="RocketMQ文件刷盘机制"><a href="#RocketMQ文件刷盘机制" class="headerlink" title="RocketMQ文件刷盘机制"></a>RocketMQ文件刷盘机制</h2><p>本文参考了李伟老师的《RocketMQ分布式消息中间件核心原理与最佳实践》一书和<a target="_blank" rel="noopener" href="https://blog.csdn.net/AllENNNNNNN_/article/details/117550585">PatrickkZ博主的博客RocketMQ源码解析之消息存储</a></p>
<p><strong>前言</strong><br>这里推荐两个看源码较好用的快捷键，可以提高源码阅读效率（win10系统）：</p>
<ol>
<li>ctrl + alt + h：查看方法的调用链</li>
<li>ctrl + h：查看类的继承关系和接口实现关系</li>
</ol>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>消息存储完成后，会被操作系统持久化到磁盘，也就是刷盘。<br>RocketMQ 支持两种刷盘方式，根据<code>DefaultMessageStore.getMessageStoreConfig().getFlushDiskType()</code>获取到的 FlushDiskType 来判定是同步刷盘或是异步刷盘，若 FlushDiskType 为 SYNC_FLUSH，则表示同步刷盘；若为 ASYNC_FLUSH，则为异步刷盘。 RocketMQ 默认为异步刷盘，且若想使用同步刷盘，则需调用 MessageStoreConfig.setFlushDiskType() 更改 FlushDiskType 为 SYNC_FLUSH。</p>
<p>RocketMQ文件刷盘机制大致分以下两部分介绍：</p>
<ol>
<li>刷盘服务线程的类型、创建和启动</li>
<li>消息刷盘的逻辑</li>
</ol>
<h2 id="刷盘服务线程的类型和创建、启动"><a href="#刷盘服务线程的类型和创建、启动" class="headerlink" title="刷盘服务线程的类型和创建、启动"></a>刷盘服务线程的类型和创建、启动</h2><h3 id="刷盘服务线程类型"><a href="#刷盘服务线程类型" class="headerlink" title="刷盘服务线程类型"></a>刷盘服务线程类型</h3><p>消息刷盘线程分别由三个类实现：<code>GroupCommitService、FlushRealTimeService、CommitRealTimeService</code>，其中 GroupCommitService 负责同步刷盘服务，FlushRealTimeService 负责异步刷盘服务，CommitRealTimeService 负责异步转存服务。这三种类都是CommitLog的内部类，且都继承自 FlushCommitLogService 类。</p>
<h3 id="刷盘服务线程何时创建"><a href="#刷盘服务线程何时创建" class="headerlink" title="刷盘服务线程何时创建"></a>刷盘服务线程何时创建</h3><p>我们先来看看调用链：<code>BrokerStartup.createBrokerController() -&gt; BrokerController.initialize() -&gt; DefaultMessageStore.DefaultMessageStore() -&gt; CommitLog.CommitLog()</code>，到构造CommitLog对象的时候停止，看一下CommitLog的构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public CommitLog(final DefaultMessageStore defaultMessageStore) &#123;</span><br><span class="line">    this.mappedFileQueue = new MappedFileQueue(defaultMessageStore.getMessageStoreConfig().getStorePathCommitLog(),</span><br><span class="line">        defaultMessageStore.getMessageStoreConfig().getMappedFileSizeCommitLog(), defaultMessageStore.getAllocateMappedFileService());</span><br><span class="line">    this.defaultMessageStore = defaultMessageStore;</span><br><span class="line"></span><br><span class="line">    if (FlushDiskType.SYNC_FLUSH == defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">        // 同步刷盘</span><br><span class="line">        this.flushCommitLogService = new GroupCommitService();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 异步刷盘</span><br><span class="line">        this.flushCommitLogService = new FlushRealTimeService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 异步转存</span><br><span class="line">    this.commitLogService = new CommitRealTimeService();</span><br><span class="line"></span><br><span class="line">    this.appendMessageCallback = new DefaultAppendMessageCallback(defaultMessageStore.getMessageStoreConfig().getMaxMessageSize());</span><br><span class="line">    batchEncoderThreadLocal = new ThreadLocal&lt;MessageExtBatchEncoder&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected MessageExtBatchEncoder initialValue() &#123;</span><br><span class="line">            return new MessageExtBatchEncoder(defaultMessageStore.getMessageStoreConfig().getMaxMessageSize());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.putMessageLock = defaultMessageStore.getMessageStoreConfig().isUseReentrantLockWhenPutMessage() ? new PutMessageReentrantLock() : new PutMessageSpinLock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，CommitLog 对象在 Broker 启动时的<code>BrokerStartup.createBrokerController()</code>方法中经过一系列调用创建，在创建 CommitLog 对象的时候，会根据<code>DefaultMessageStore.getMessageStoreConfig().getFlushDiskType()</code>值决定创建 GroupCommitService 或 FlushRealTimeService 对象，创建的对象由 FlushCommitLogService 类型的 flushCommitLogService 引用，也就是说，RocketMQ 每次启动仅能支持一种刷盘方式：同步或异步，而不同时支持同步和异步刷盘方式。同时会创建 CommitRealTimeService 对象，该对象由 FlushCommitLogService 类型的 commitLogService 引用</p>
<h3 id="刷盘服务线程何时启动"><a href="#刷盘服务线程何时启动" class="headerlink" title="刷盘服务线程何时启动"></a>刷盘服务线程何时启动</h3><p> 还是看调用链：<code>BrokerStartup.main() -&gt; start() -&gt; BrokerController.start() -&gt; DefaultMessageStore.start() -&gt; CommitLog.start()</code>，可以知道，在创建完 BrokerController 对象后启动 BrokerController 时，会调用<code>CommitLog.start()</code>方法，我们看一下这个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">    this.flushCommitLogService.start();</span><br><span class="line"></span><br><span class="line">    if (defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">        this.commitLogService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看出，进入该方法后，flushCommitLogService 线程会被启动。同时，根据<code>defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()</code>是否开启异步转存服务（默认不开启）决定是否启动commitLogService线程</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>到这里我们知道了，刷盘线程有三种，分别提供同步刷盘、异步刷盘和异步转存服务。</li>
<li>其中，默认使用的是异步刷盘，同时默认不使用异步转存服务（即 transientStorePoolEnable 默认为 false），也就是说，RocketMQ 默认仅创建和启动 FlushRealTimeService 线程。</li>
<li>此外，我们还知道了，刷盘服务线程在创建BrokerController的时候创建，在启动BrokerController的时候被启动。</li>
<li>当内存缓存池 TransientStorePool 可用时（（即 transientStorePoolEnable 为 true），消息会先提交到 TransientStorePool 中的 WriteBuffer 内部，再提交到 MappedFile 的 FileChannle 中，此时异步刷盘服务就是 CommitRealTimeService。<br>最后，我们下面来看一下消息是如何被线程刷到磁盘上的。</li>
</ol>
<h2 id="消息刷盘的逻辑"><a href="#消息刷盘的逻辑" class="headerlink" title="消息刷盘的逻辑"></a>消息刷盘的逻辑</h2><h3 id="消息刷盘的方法-–-handleDiskFlush"><a href="#消息刷盘的方法-–-handleDiskFlush" class="headerlink" title="消息刷盘的方法 – handleDiskFlush()"></a>消息刷盘的方法 – handleDiskFlush()</h3><p>在<code>CommitLog.putMessage()</code>方法中，会完成消息写到内存中的任务（这个过程不展开说了，需要了解的读者可以到我开头提到的参考书或博客看看），在该方法的末尾，会调用 handleDiskFlush() ，部分代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public PutMessageResult putMessage(final MessageExtBrokerInner msg) &#123;</span><br><span class="line"></span><br><span class="line">    // 消息存储到内存的过程（省略）</span><br><span class="line"></span><br><span class="line">    if (null != unlockMappedFile &amp;&amp; this.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line">        this.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PutMessageResult putMessageResult = new PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line"></span><br><span class="line">    // Statistics</span><br><span class="line">    storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();</span><br><span class="line">    storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());</span><br><span class="line"></span><br><span class="line">    // 刷盘，消息持久化</span><br><span class="line">    handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line">    // 主从同步</span><br><span class="line">    handleHA(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">    return putMessageResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>CommitLog.handleDiskFlush()</code>方法中，会根据 flushDiskType 值来决定是同步刷盘还是异步刷盘，下面我们分别进行介绍</p>
<h3 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h3><p>同步刷盘大致可以分为两部分：</p>
<ol>
<li>构造写消息请求并唤醒刷盘线程</li>
<li>刷盘线程执行run()代码体进行消息刷盘</li>
</ol>
<p><strong>1. 构造写消息请求并唤醒刷盘线程</strong></p>
<p>下面来看看<code>CommitLog.handleDiskFlush()</code>方法，在该方法里实现了同步刷盘和异步刷盘的逻辑。我们先看同步刷盘的逻辑：在该部分代码中主要做了以下四件事（结合代码）：</p>
<ul>
<li><em>@1：</em>根据 getFlushDiskType() 方法获得的 flushDiskType 变量的值判断是否使用同步刷盘，若是（即该变量值为 SYNC_FLUSH），则获取 flushCommitLogService 同步刷盘线程</li>
<li><em>@2：</em>构造刷盘请求，该请求为一个 GroupCommitRequest 对象</li>
<li><em>@3：</em>将刷盘请求放入线程（即 GroupCommitService 对象）的写请求队列</li>
<li><em>@4：</em>同步等待获取结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void handleDiskFlush(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt) &#123;</span><br><span class="line">    // Synchronization flush</span><br><span class="line">    if (FlushDiskType.SYNC_FLUSH == this.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">        final GroupCommitService service = (GroupCommitService)  this.flushCommitLogService;      //@1 </span><br><span class="line">        if (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">            GroupCommitRequest request = new GroupCommitRequest  (result.getWroteOffset() + result.getWroteBytes());   //@2</span><br><span class="line">            service.putRequest(request);   //@3</span><br><span class="line">            CompletableFuture&lt;PutMessageStatus&gt; flushOkFuture = request.future();   //@4</span><br><span class="line">            PutMessageStatus flushStatus = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                flushStatus = flushOkFuture.get(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout(),</span><br><span class="line">                        TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; catch (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">                //flushOK=false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flushStatus != PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">                log.error(&quot;do groupcommit, wait for flush failed, topic: &quot; + messageExt.getTopic() + &quot; tags: &quot; + messageExt.getTags()</span><br><span class="line">                    + &quot; client address: &quot; + messageExt.getBornHostString());</span><br><span class="line">                putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            service.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 异步刷盘</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来进入<code>CommitLog.GroupCommitService.putRequest()</code>方法，可知该方法做了如下两件事（代码注释）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void putRequest(final GroupCommitRequest request) &#123;</span><br><span class="line">    synchronized (this.requestsWrite) &#123;</span><br><span class="line">        // 1. 将刷盘请求添加进写请求队列</span><br><span class="line">        this.requestsWrite.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">    // 2. 唤醒刷盘线程处理请求</span><br><span class="line">    this.wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看<code>ServiceThread.wakeup()</code>方法，查看代码可知，该方法用于唤醒刷盘线程，以实现主线程（存储消息线程）和刷盘线程间的协调</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void wakeup() &#123;</span><br><span class="line">    // hasNotified默认为false，因此compareAndSet方法返回true，同时会将hasNotified修改为true</span><br><span class="line">    if (hasNotified.compareAndSet(false, true)) &#123;</span><br><span class="line">        // waitPoint 是 CountDownLatch2 类型对象，count 值为1，因此 countDown 执行后会唤醒刷盘线程</span><br><span class="line">        waitPoint.countDown(); // notify</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以知道，到这里，刷盘线程被唤醒了。接下来，刷盘线程将执行相应的 run()方法，完成自己的工作</strong></p>
<p><strong>2. 刷盘线程执行 run()代码体进行消息刷盘</strong></p>
<p>我们查看同步刷盘线程的<code>CommitLog.GroupCommitService.run()</code>方法，可以知道线程的执行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    CommitLog.log.info(this.getServiceName() + &quot; service started&quot;);</span><br><span class="line"></span><br><span class="line">    // 刷盘线程是否停止</span><br><span class="line">    while (!this.isStopped()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.waitForRunning(10);   // @1</span><br><span class="line">            this.doCommit();   // @2</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            CommitLog.log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Under normal circumstances shutdown, wait for the arrival of the</span><br><span class="line">    // request, and then flush</span><br><span class="line">    // 若线程已经停止，则在等待一段时间后，将剩余的刷盘请求进行刷盘</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(10);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        CommitLog.log.warn(&quot;GroupCommitService Exception, &quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.swapRequests();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.doCommit();</span><br><span class="line"></span><br><span class="line">    CommitLog.log.info(this.getServiceName() + &quot; service end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>该方法是线程的主要执行逻辑，解释如下</strong></p>
<ul>
<li><p><em>@1：</em><code>this.waitForRunning(10);</code>语句，进入该方法查看，可知该方法交换了读写队列，这个操作有以下好处：实现了读写分离，使刷盘线程在写消息（读读消息队列）的时候，存储消息的线程仍然可以将写请求添加到写消息队列，避免产生锁竞争。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void waitForRunning(long interval) &#123;</span><br><span class="line">    // hasNotified在上面的wakeup()唤醒刷盘线程后已变为true，因此该if语句返回true，同时hasNotified变回false</span><br><span class="line">    if (hasNotified.compareAndSet(true, false)) &#123;</span><br><span class="line">        // 交换读写队列</span><br><span class="line">        this.onWaitEnd();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //entry to wait</span><br><span class="line">    waitPoint.reset();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        waitPoint.await(interval, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        log.error(&quot;Interrupted&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        hasNotified.set(false);</span><br><span class="line">        this.onWaitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><em>@2：</em><code>this.doCommit(); </code>语句，进入该方法查看可知，该方法是线程刷盘过程的主要实现，解释如下：</p>
<ul>
<li><em>Ⅰ：</em> 对读请求队列加锁</li>
<li><em>Ⅱ：</em> 遍历读请求队列，取出读请求队列中的刷盘请求。从这里可以看出，RocketMQ 是一次处理一批刷盘请求</li>
<li><em>Ⅲ：</em> 因为消息可能分别存在了两个 mappedFile 中，因此需要至少刷盘两次。每次刷盘会更新 flushOK 变量，该变量值由刷盘后消息的偏移量和请求消息的偏移量的比较来确定，用于判断此次刷盘是否结束。若尚未结束，则进行第二次刷盘。刷盘调用的是 MappedFileQueue.flush() 方法，此时开始真正刷盘，具体细节放到了后面</li>
<li><em>Ⅳ：</em> 唤醒等待刷盘结果的线程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void doCommit() &#123;</span><br><span class="line">    synchronized (this.requestsRead) &#123;   // Ⅰ</span><br><span class="line">        if (!this.requestsRead.isEmpty()) &#123;   // 走这里</span><br><span class="line">            for (GroupCommitRequest req : this.requestsRead) &#123;   // Ⅱ</span><br><span class="line">                // There may be a message in the next file, so a maximum of</span><br><span class="line">                // two times the flush</span><br><span class="line">                boolean flushOK = CommitLog.this.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line">                for (int i = 0; i &lt; 2 &amp;&amp; !flushOK; i++) &#123;   // Ⅲ</span><br><span class="line">                    // 调用MappedFileQueue的flush()方法刷盘</span><br><span class="line">                    CommitLog.this.mappedFileQueue.flush(0);</span><br><span class="line">                    flushOK = CommitLog.this.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                req.wakeupCustomer(flushOK ? PutMessageStatus.PUT_OK : PutMessageStatus.FLUSH_DISK_TIMEOUT);   // Ⅳ</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long storeTimestamp = CommitLog.this.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">            if (storeTimestamp &gt; 0) &#123;</span><br><span class="line">                CommitLog.this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.requestsRead.clear();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Because of individual messages is set to not sync flush, it</span><br><span class="line">            // will come to this process</span><br><span class="line">            CommitLog.this.mappedFileQueue.flush(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h3><p>起点仍然是CommitLog.handleDiskFlush()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void handleDiskFlush(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt) &#123;</span><br><span class="line">    </span><br><span class="line">    // 同步刷盘过程（省略）</span><br><span class="line"></span><br><span class="line">    // Asynchronous flush</span><br><span class="line">    else &#123;</span><br><span class="line">        if (!this.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">            // 若没有开启内存缓存池，则唤醒 flushCommitLogService</span><br><span class="line">            flushCommitLogService.wakeup();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 否则唤醒 commitLogService</span><br><span class="line">            commitLogService.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FlushRealTimeService 在启动后，会在死循环中周期性的进行刷盘操作</strong></p>
<p><strong>FlushRealTimeService.run()</strong><br>该方法实现了异步刷盘的主逻辑。这里面有几个比较重要的参数，如下：</p>
<ul>
<li>boolean flushCommitLogTimed：休眠策略，为 true 时，调用 Thread.sleep()休眠，为 false 时，调用 waitForRunning（）休眠，每次休眠时长 500ms，默认 false</li>
<li>int interval：休眠时长，也作刷盘周期，默认为 500ms</li>
<li>int flushPhysicQueueLeastPages：每次刷盘至少要刷多少页内容，每页大小为 4 k，默认每次要刷 4 页</li>
<li>int flushPhysicQueueThoroughInterval：两次刷写之间的最大时间间隔，默认 10 s</li>
</ul>
<p>接下来结合代码解释该方法的主逻辑：</p>
<ul>
<li><em>@1：</em> 若距离上次刷盘时间间隔大于 flushPhysicQueueThoroughInterval，则将 flushPhysicQueueLeastPages 设置为0，表明将所有内存缓存全部刷到文件中</li>
<li><em>@2：</em> 根据不同休眠策略，进行休眠等待，默认 flushCommitLogTimed 为 false，即默认走 @3</li>
<li><em>@3：</em> 默认走这里，调用 ServiceThread.waitForRunning()方法，休眠 interval 大小的时长</li>
<li><em>@4：</em> 与同步刷盘一样，刷盘时调用的是 MappedFileQueue.flush()方法</li>
<li><em>@5：</em> 若线程被停止了，则重试 RETRY_TIMES_OVER（默认为10）大小的次数，每次重试进行一次刷盘，直到内存中所有消息完成刷盘</li>
</ul>
<p><strong>从 <em>@3</em> 语句中我们会以为异步刷盘是每隔 500ms 刷盘一次，但结合 CommitLog.handleDiskFlush() 方法，可以知晓每异步写入一条消息，都会触发 flushCommitLogService.wakeup() 直接中断 this.waitForRunning(interval)。因此异步刷盘并非想当然的每隔500ms flush一盘。而是如果没有新的消息写入，会休眠 500ms，但收到了新的消息后，可以被唤醒，做到消息及时被刷盘，而不是一定要等 500 ms。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    CommitLog.log.info(this.getServiceName() + &quot; service started&quot;);</span><br><span class="line"></span><br><span class="line">    while (!this.isStopped()) &#123;</span><br><span class="line">        boolean flushCommitLogTimed = CommitLog.this.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();</span><br><span class="line"></span><br><span class="line">        int interval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();</span><br><span class="line">        int flushPhysicQueueLeastPages = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();</span><br><span class="line"></span><br><span class="line">        int flushPhysicQueueThoroughInterval =</span><br><span class="line">            CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();</span><br><span class="line"></span><br><span class="line">        boolean printFlushProgress = false;</span><br><span class="line"></span><br><span class="line">        // Print flush progress</span><br><span class="line">        long currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">        if (currentTimeMillis &gt;= (this.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;   // @1</span><br><span class="line">            this.lastFlushTimestamp = currentTimeMillis;</span><br><span class="line">            flushPhysicQueueLeastPages = 0;</span><br><span class="line">            printFlushProgress = (printTimes++ % 10) == 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (flushCommitLogTimed) &#123;   // @2</span><br><span class="line">                Thread.sleep(interval);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.waitForRunning(interval);   // @3</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (printFlushProgress) &#123;</span><br><span class="line">                this.printFlushProgress();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long begin = System.currentTimeMillis();</span><br><span class="line">            CommitLog.this.mappedFileQueue.flush(flushPhysicQueueLeastPages);   // @4</span><br><span class="line">            long storeTimestamp = CommitLog.this.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">            if (storeTimestamp &gt; 0) &#123;</span><br><span class="line">                CommitLog.this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">            long past = System.currentTimeMillis() - begin;</span><br><span class="line">            if (past &gt; 500) &#123;</span><br><span class="line">                log.info(&quot;Flush data to disk costs &#123;&#125; ms&quot;, past);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            CommitLog.log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);</span><br><span class="line">            this.printFlushProgress();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Normal shutdown, to ensure that all the flush before exit</span><br><span class="line">    boolean result = false;</span><br><span class="line">    for (int i = 0; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++) &#123;   // @5</span><br><span class="line">        result = CommitLog.this.mappedFileQueue.flush(0);</span><br><span class="line">        CommitLog.log.info(this.getServiceName() + &quot; service shutdown, retry &quot; + (i + 1) + &quot; times &quot; + (result ? &quot;OK&quot; : &quot;Not OK&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.printFlushProgress();</span><br><span class="line"></span><br><span class="line">    CommitLog.log.info(this.getServiceName() + &quot; service end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="消息最终刷盘"><a href="#消息最终刷盘" class="headerlink" title="消息最终刷盘"></a>消息最终刷盘</h3><p><strong>无论是同步刷盘还是异步刷盘，在主流程的逻辑处理完后，最终都是调用 MappedFileQueue 的 flush()方法进行消息刷盘</strong></p>
<p><strong>MappedFileQueue.flush()</strong><br>该方法的主要逻辑解释如下（结合代码）：</p>
<ul>
<li><em>@1：</em> flushedWhere 记录了最后一条被刷到文件的内容的全局物理偏移量。所以此次刷盘就要根据偏移量，找到本次要刷盘的起始点位于哪个mappedFile，该 mappedFile 存储在 CopyOnWriteArrayList 类型的列表里</li>
<li><em>@2：</em> 调用 MappedFile.flush()方法刷盘</li>
<li><em>@3：</em> 更新 flushedWhere 值</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean flush(final int flushLeastPages) &#123;</span><br><span class="line">    boolean result = true;</span><br><span class="line">    MappedFile mappedFile = this.findMappedFileByOffset(this.flushedWhere, this.flushedWhere == 0);   // @1</span><br><span class="line">    if (mappedFile != null) &#123;</span><br><span class="line">        long tmpTimeStamp = mappedFile.getStoreTimestamp();</span><br><span class="line">        int offset = mappedFile.flush(flushLeastPages);   // @2</span><br><span class="line">        long where = mappedFile.getFileFromOffset() + offset;</span><br><span class="line">        result = where == this.flushedWhere;</span><br><span class="line">        this.flushedWhere = where;   // @3</span><br><span class="line">        if (0 == flushLeastPages) &#123;</span><br><span class="line">            this.storeTimestamp = tmpTimeStamp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>MappedFile.flush()</strong><br>同样结合代码分析主逻辑如下：</p>
<ul>
<li><em>@1：</em> 校验是否满足刷盘条件，该方法根据 flushLeastPages 的值，有两种处理逻辑<ol>
<li>若 flushLeastPages 值为0，对比 wrotePosition 和 flushedPosition 的值，若 flushedPosition &gt; wrotePosition，则返回 true</li>
<li>若 flushLeastPages 值大于0，则判断当前剩余未刷盘内容长度，是否超过最小刷盘长度 flushLeastPages，若超过，则返回 true，避免不必要的刷盘操作。</li>
</ol>
</li>
<li><em>@2：</em> 校验 mappedFile 是否还能用</li>
<li><em>@3：</em> 因为默认不开启内存缓存池（即 transientStorePoolEnable 默认为 false），所以将使用 @4 中的 mappedByteBuffer 存储消息</li>
<li><em>@4：</em> 最终调用 MappedByteBuffer.force()方法刷盘<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int flush(final int flushLeastPages) &#123;</span><br><span class="line">    if (this.isAbleToFlush(flushLeastPages)) &#123;   // @1</span><br><span class="line">        if (this.hold()) &#123;   // @2</span><br><span class="line">            int value = getReadPosition();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                //We only append data to fileChannel or mappedByteBuffer, never both.</span><br><span class="line">                if (writeBuffer != null || this.fileChannel.position() != 0) &#123;   // @3</span><br><span class="line">                    this.fileChannel.force(false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    this.mappedByteBuffer.force();   // @4</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                log.error(&quot;Error occurred when force data to disk.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.flushedPosition.set(value);</span><br><span class="line">            this.release();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.warn(&quot;in flush, hold failed, flush offset = &quot; + this.flushedPosition.get());</span><br><span class="line">            this.flushedPosition.set(getReadPosition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.getFlushedPosition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>至此消息最终刷到磁盘中，一次同步或异步刷盘结束</strong></p>
<h3 id="看代码笔记"><a href="#看代码笔记" class="headerlink" title="看代码笔记"></a>看代码笔记</h3><ol>
<li>在MessageStoreConfig类里我们查到”The maximum size of message,default is 4M”</li>
<li>在BrokerStartup的createBrokerController()方法里会创建BrokerController对象，然后调用initialize()方法，initialize()方法会创建DefaultMessageStore对象，调用DefaultMessageStore.load()方法，DefaultMessageStore对象会创建CommitLog对象</li>
<li>刷盘服务线程启动调用链：在BrokerController对象创建完成后，BrokerStartup.start() -&gt; BrokerController.start() -&gt; DefaultMessageStore.start() -&gt; CommitLog.start()</li>
<li>DefaultMessageStore.load()的调用链如下：load() -&gt; loadConsumeQueue() -&gt; ConsumeQueue.load() -&gt; MappedFileQueue.load()，之后，它会构造MappedFile对象</li>
<li>DefaultAppendMessageCallback对象在CommitLog对象构造的时候创建</li>
<li>MappedFile类对象在构造的时候会通过调用TransientStorePool.borrowBuffer()获取队首的ByteBuffer（TransientStorePool里有一个ByteBuffer的队列），作为MappedFile类对象的writeBuffer属性</li>
<li>TransientStorePool（但默认不创建）、CommitLog对象在构造DefaultMessageStore对象时创建，</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/10/25/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/touxiang.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">工作积累</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zourunxin"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">勤加注释！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OS"><span class="toc-text">OS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%A4%8D%E4%B9%A0"><span class="toc-text">数据挖掘复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E8%AE%B2-%E2%80%93-%E8%AE%A4%E8%AF%86%E6%95%B0%E6%8D%AE"><span class="toc-text">第2讲 – 认识数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E8%AE%B2-%E2%80%93-%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-text">第3讲 – 数据预处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E8%AE%B2-%E2%80%93-%E5%88%86%E7%B1%BB%E5%9F%BA%E7%A1%80%EF%BC%9B%E7%AC%AC%E4%BA%94%E8%AE%B2-%E2%80%93-%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E9%93%BE%E6%8E%A5%E5%88%86%E6%9E%90"><span class="toc-text">第4讲 – 分类基础；第五讲 – 决策树与链接分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E8%AE%B2-%E2%80%93-%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%8A%BD%E6%A0%B7"><span class="toc-text">第6讲 – 随机过程与抽样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E8%AE%B2-%E2%80%93-%E8%81%9A%E7%B1%BB%E5%9F%BA%E7%A1%80"><span class="toc-text">第7讲 – 聚类基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E8%AE%B2-%E2%80%93-%E9%AB%98%E7%BA%A7%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">第8讲 – 高级聚类方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC9%E8%AE%B2%EF%BC%88%E9%87%8D%E7%82%B9%E4%B8%AD%E7%9A%84%E9%87%8D%E7%82%B9%EF%BC%8C%E7%AE%80%E7%AD%94%E9%A2%98%EF%BC%89%E2%80%93-%E9%A2%91%E7%B9%81%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80"><span class="toc-text">第9讲（重点中的重点，简答题）– 频繁模式挖掘基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E8%AE%B2-%E2%80%93-%E9%A2%91%E7%B9%81%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99"><span class="toc-text">第10讲 – 频繁模式挖掘进阶与关联规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E8%AE%B2-%E2%80%93-%E7%BE%A4%E4%BD%93%E6%99%BA%E8%83%BD%E6%8C%96%E6%8E%98"><span class="toc-text">第12讲 – 群体智能挖掘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E8%AE%B2-%E2%80%93-%E9%9B%86%E6%88%90%E6%8C%96%E6%8E%98"><span class="toc-text">第13讲 – 集成挖掘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E8%AE%B2-%E2%80%93-%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98"><span class="toc-text">第14讲 – 复杂类型数据挖掘</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ%E5%BC%80%E6%BA%90%E8%AF%BE%E7%A8%8B"><span class="toc-text">RocketMQ开源课程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%94%E8%AE%B0"><span class="toc-text">笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-%E2%80%93-ISSUE%E5%92%8CPR"><span class="toc-text">作业 – ISSUE和PR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A1%E7%8C%AE%E4%BB%A3%E7%A0%81%E8%BF%87%E7%A8%8B"><span class="toc-text">贡献代码过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Configuration-System-md-%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%EF%BC%88%E4%BD%9C%E4%B8%9A%EF%BC%89"><span class="toc-text">Configuration_System.md 技术文档翻译（作业）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE"><span class="toc-text">系统配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JVM-%E9%80%89%E9%A1%B9"><span class="toc-text">1 JVM 选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Linux-%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0"><span class="toc-text">2 Linux 内核参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E6%96%87%E4%BB%B6%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6"><span class="toc-text">RocketMQ文件刷盘机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E6%9C%8D%E5%8A%A1%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%88%9B%E5%BB%BA%E3%80%81%E5%90%AF%E5%8A%A8"><span class="toc-text">刷盘服务线程的类型和创建、启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E6%9C%8D%E5%8A%A1%E7%BA%BF%E7%A8%8B%E7%B1%BB%E5%9E%8B"><span class="toc-text">刷盘服务线程类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E6%9C%8D%E5%8A%A1%E7%BA%BF%E7%A8%8B%E4%BD%95%E6%97%B6%E5%88%9B%E5%BB%BA"><span class="toc-text">刷盘服务线程何时创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E6%9C%8D%E5%8A%A1%E7%BA%BF%E7%A8%8B%E4%BD%95%E6%97%B6%E5%90%AF%E5%8A%A8"><span class="toc-text">刷盘服务线程何时启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%88%B7%E7%9B%98%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-text">消息刷盘的逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%88%B7%E7%9B%98%E7%9A%84%E6%96%B9%E6%B3%95-%E2%80%93-handleDiskFlush"><span class="toc-text">消息刷盘的方法 – handleDiskFlush()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98"><span class="toc-text">同步刷盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98"><span class="toc-text">异步刷盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E5%88%B7%E7%9B%98"><span class="toc-text">消息最终刷盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0"><span class="toc-text">看代码笔记</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/25/%E8%AF%BE%E7%A8%8B/" title="课程">课程</a><time datetime="2021-10-25T05:20:25.000Z" title="Created 2021-10-25 13:20:25">2021-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/25/%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF/" title="工作积累">工作积累</a><time datetime="2021-10-25T05:16:26.000Z" title="Created 2021-10-25 13:16:26">2021-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/25/%E5%B7%A5%E5%85%B7%E7%B1%BB/" title="工具类">工具类</a><time datetime="2021-10-25T04:13:44.000Z" title="Created 2021-10-25 12:13:44">2021-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/09/22/hello-world/" title="Hello World">Hello World</a><time datetime="2021-09-22T15:33:18.000Z" title="Created 2021-09-22 23:33:18">2021-09-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/31/%E9%80%89%E8%B0%83%E7%9B%B8%E5%85%B3/" title="选调相关">选调相关</a><time datetime="2021-05-31T14:57:21.000Z" title="Created 2021-05-31 22:57:21">2021-05-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div></div></body></html>